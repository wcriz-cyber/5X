<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, viewport-fit=cover">
    <title>5X</title>
    <meta name="theme-color" content="#0b0e11">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="icon" type="image/png" href="icon.png">
    <!-- Fuentes vía Bunny Fonts —privacidad por defecto— -->
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link href="https://fonts.bunny.net/css?family=chakra-petch:500,700|inter:500,700,800|jetbrains-mono:500,700,800|orbitron:400,500,600,700,800,900|rajdhani:500,600,700,800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://s3.tradingview.com/tv.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <style>
        *, *::before, *::after { box-sizing: border-box; }
        html { overflow-x: hidden; max-width: 100vw; }
        
        #section-chat { padding: 0; overflow: hidden; display: none; flex-direction: column; height: calc(100vh - var(--safe-top) - 50px); }
        #section-chat.active { display: flex !important; opacity: 1; animation: slide-in 0.25s cubic-bezier(0.16, 1, 0.3, 1); }

        /* Header */
        .chat-header { display: flex; align-items: center; gap: 10px; padding: 10px 14px; background: var(--surface); border-bottom: 1px solid var(--border); flex-shrink: 0; }
        .chat-header-avatar { width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, var(--brand), rgba(59,130,246,0.5)); display: flex; align-items: center; justify-content: center; color: #fff; flex-shrink: 0; }
        .chat-header-info { flex: 1; display: flex; flex-direction: column; gap: 1px; }
        .chat-header-name { font-family: var(--font-head); font-size: 13px; font-weight: 900; color: var(--text-primary); letter-spacing: 1px; }
        .chat-header-status { font-family: var(--font-head); font-size: 9px; color: var(--text-tertiary); letter-spacing: 0.5px; transition: color 0.3s; }
        .chat-header-status.online { color: var(--long); }

        /* Área de mensajes */
        .chat-messages { flex: 1; overflow-y: auto; padding: 12px 14px; display: flex; flex-direction: column; gap: 10px; scroll-behavior: smooth; overscroll-behavior: contain; -webkit-overflow-scrolling: touch; }
        .chat-messages::-webkit-scrollbar { width: 4px; }
        .chat-messages::-webkit-scrollbar-thumb { background: var(--border-strong); border-radius: 2px; }

        /* Estado vacío */
        .chat-empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; gap: 12px; color: var(--text-tertiary); text-align: center; padding: 40px 20px; }
        .chat-empty-state p { font-family: var(--font-head); font-size: 11px; font-weight: 600; line-height: 1.8; letter-spacing: 0.3px; }

        /* Burbujas */
        .chat-bubble-wrap { display: flex; flex-direction: column; max-width: 78%; gap: 2px; }
        .chat-bubble-wrap.mine { align-self: flex-end; align-items: flex-end; }
        .chat-bubble-wrap.theirs { align-self: flex-start; align-items: flex-start; }
        .chat-bubble { padding: 9px 13px; border-radius: 18px; font-family: var(--font-head); font-size: 12px; font-weight: 600; line-height: 1.55; letter-spacing: 0.2px; word-break: break-word; position: relative; }
        .chat-bubble-wrap.mine .chat-bubble { background: var(--brand); color: #fff; border-bottom-right-radius: 5px; }
        .chat-bubble-wrap.theirs .chat-bubble { background: var(--surface); border: 1px solid var(--border); color: var(--text-primary); border-bottom-left-radius: 5px; }
        .chat-bubble-wrap.theirs.superadmin .chat-bubble { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.1)); border-color: rgba(59,130,246,0.4); }
        .chat-bubble-meta { font-family: var(--font-num); font-size: 9px; color: var(--text-tertiary); padding: 0 4px; display: flex; align-items: center; gap: 4px; }
        .chat-bubble-wrap.mine .chat-bubble-meta { color: rgba(255,255,255,0.5); }
        .chat-check { color: var(--long); font-size: 10px; }
        .chat-sender-name { font-family: var(--font-head); font-size: 9px; font-weight: 800; letter-spacing: 0.5px; padding: 0 4px 2px; color: var(--brand); }

        /* Badge de fecha separador */
        .chat-date-sep { align-self: center; background: var(--surface); border: 1px solid var(--border); border-radius: 20px; padding: 2px 12px; font-family: var(--font-head); font-size: 9px; color: var(--text-tertiary); letter-spacing: 0.5px; margin: 4px 0; }

        /* Input bar */
        .chat-input-bar { display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: var(--surface); border-top: 1px solid var(--border); flex-shrink: 0; padding-bottom: calc(10px + var(--safe-bottom)); }
        .chat-input { flex: 1; background: var(--bg); border: 1px solid var(--border); border-radius: 22px; padding: 9px 14px; color: var(--text-primary); font-family: var(--font-head); font-size: 12px; font-weight: 600; outline: none; transition: border-color 0.2s; letter-spacing: 0.2px; }
        .chat-input:focus { border-color: var(--brand); }
        .chat-input::placeholder { color: var(--text-tertiary); }
        .chat-send-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--brand); border: none; color: #fff; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; transition: all 0.2s; box-shadow: 0 2px 8px rgba(59,130,246,0.4); }
        .chat-send-btn:active { transform: scale(0.9); }
        .chat-send-btn:disabled { background: var(--border); box-shadow: none; cursor: not-allowed; }

        /* Typing indicator */
        .chat-typing { display: flex; align-items: center; gap: 4px; padding: 8px 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 18px; border-bottom-left-radius: 5px; align-self: flex-start; }
        .chat-typing span { width: 6px; height: 6px; border-radius: 50%; background: var(--text-tertiary); animation: chat-bounce 1.2s infinite; }
        .chat-typing span:nth-child(2) { animation-delay: 0.2s; }
        .chat-typing span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes chat-bounce { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-5px); } }

        /* Aviso de chat sin configurar */
        .chat-notice { margin: 12px; padding: 12px 14px; background: rgba(245,158,11,0.08); border: 1px solid rgba(245,158,11,0.3); border-radius: 12px; font-family: var(--font-head); font-size: 10px; color: var(--warning); line-height: 1.7; letter-spacing: 0.3px; flex-shrink: 0; }

        /* ════════════════════════════════════════
           GATE.IO COMMAND DASHBOARD — PANEL 3
        ════════════════════════════════════════ */
        .gd-header {
            display: flex; align-items: center; justify-content: space-between;
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 14px; padding: 10px 14px; margin-bottom: 8px;
        }
        .gd-conn-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--text-tertiary); flex-shrink: 0;
            transition: background 0.5s, box-shadow 0.5s;
        }
        .gd-conn-dot.connected {
            background: var(--long);
            box-shadow: 0 0 8px var(--long);
            animation: pulse-ring 2s infinite;
        }
        .gd-brand {
            font-family: var(--font-head); font-size: 15px; font-weight: 900;
            letter-spacing: 2px; color: var(--brand);
        }
        .gd-conn-label {
            font-family: var(--font-head); font-size: 9px; font-weight: 700;
            color: var(--text-tertiary); letter-spacing: 1px;
            transition: color 0.4s;
        }
        .gd-conn-label.connected { color: var(--long); }
        .gd-update-time {
            font-family: var(--font-num); font-size: 10px; color: var(--text-tertiary);
        }
        .gd-refresh-btn {
            background: rgba(59,130,246,0.1); border: 1px solid rgba(59,130,246,0.3);
            border-radius: 8px; width: 28px; height: 28px; display: flex;
            align-items: center; justify-content: center; color: var(--brand);
        }

        /* MÉTRICAS GRID 3 COL */
        .gd-metrics-grid {
            display: grid; grid-template-columns: 1fr 1fr 1fr;
            gap: 6px; margin-bottom: 6px;
        }
        .gd-metric-card {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 14px; padding: 10px 8px; text-align: center;
            display: flex; flex-direction: column; gap: 2px;
            position: relative; overflow: hidden;
        }
        .gd-metric-label {
            font-family: var(--font-head); font-size: 8px; font-weight: 700;
            color: var(--text-tertiary); letter-spacing: 0.8px; text-transform: uppercase;
        }
        .gd-metric-value {
            font-family: var(--font-num); font-size: 15px; font-weight: 800;
            color: var(--text-primary); line-height: 1.1;
        }
        .gd-metric-sub {
            font-family: var(--font-num); font-size: 9px; color: var(--text-tertiary);
        }

        .gd-mc-progress {
            position: absolute; bottom: 0; left: 0; height: 2px;
            background: var(--brand); transition: width 0.3s linear; border-radius: 0;
        }
        .gd-mc-change {
            font-family: var(--font-num); font-size: 11px; font-weight: 800;
            padding: 1px 7px; border-radius: 6px; display: inline-block;
        }
        .gd-mc-change.up  { background: rgba(16,185,129,0.15); color: var(--long); }
        .gd-mc-change.down{ background: rgba(239,68,68,0.15);  color: var(--short); }

        /* PORTAFOLIO 5X — barra única horizontal rotatoria */
        .gd-portfolio-bar {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 14px; padding: 8px 10px; margin-top: 6px;
            display: flex; flex-direction: column; align-items: center;
            gap: 4px; min-height: 74px; /* ~20% menos que los 90px previos */
        }
        .gd-dual-label {
            font-family: var(--font-head); font-size: 8px; font-weight: 800;
            color: var(--text-tertiary); letter-spacing: 1.2px; text-transform: uppercase;
        }
        .gd-dual-scroll-wrap {
            width: 100%; overflow: hidden; position: relative; min-height: 36px;
        }
        .gd-dual-track {
            display: flex; transition: transform 0.45s cubic-bezier(0.4,0,0.2,1);
            width: 100%;
        }
        .gd-dual-slide {
            min-width: 100%; display: flex; align-items: center;
            justify-content: space-between; gap: 8px; padding: 0 4px;
            flex-shrink: 0;
        }
        /* Slide portfolio — fila horizontal compacta */
        .gd-slide-left  { display: flex; flex-direction: column; gap: 1px; }
        .gd-slide-right { display: flex; flex-direction: column; align-items: flex-end; gap: 1px; }
        .gd-slide-coin {
            font-family: var(--font-head); font-size: 18px; font-weight: 900; line-height: 1;
        }
        .gd-slide-detail {
            font-family: var(--font-num); font-size: 9px; color: var(--text-tertiary);
        }
        .gd-slide-inv {
            font-family: var(--font-num); font-size: 15px; font-weight: 800;
            color: var(--text-primary); line-height: 1;
        }
        .gd-slide-levels {
            font-family: var(--font-head); font-size: 9px; color: var(--text-tertiary);
        }
        /* Dots */
        .gd-dual-dots { display: flex; gap: 4px; align-items: center; }
        .gd-ddot {
            width: 5px; height: 5px; border-radius: 50%;
            background: var(--border); transition: all 0.3s; flex-shrink: 0;
        }
        .gd-ddot.active { background: var(--brand); width: 12px; border-radius: 3px; }

        
        :root {
            /* ── T11 SteelNoir Dark ── */
            --bg: #080808;
            --surface: #111111;
            --surface-glass: #080808;
            --card-bg: rgba(255,255,255,0.03);
            --border: #1c1c1c;
            --border-strong: #282828;
            --text-primary: #f5f5f5;
            --text-secondary: #888888;
            --text-tertiary: #444444;
            --brand: #d1d5db;
            --long: #34d399;
            --short: #f87171;
            --warning: #fbbf24;
            --danger: #ef4444;
            --zone-gold: #fbbf24;
            --zone-hot: #fb923c;
            --zone-warm: #888888;
            --radius-m: 6px;
            --chart-bg: #000000;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
            --skeleton: rgba(255,255,255,0.04);
            --font-main: 'Inter', sans-serif;
            --font-head: 'Inter', sans-serif;
            --font-num: 'JetBrains Mono', monospace;
            --fs-set-title: 12px;
            --fs-set-label: 11px;
            --fs-set-input: 16px;
        }
        
        /* ── T11 SteelNoir Claro ── */
        body.light-mode {
            --bg: #f9fafb; --surface: #ffffff; --surface-glass: #f9fafb;
            --card-bg: rgba(0,0,0,0.03); --border: #e5e7eb; --border-strong: #d1d5db;
            --text-primary: #111827; --text-secondary: #4b5563; --text-tertiary: #9ca3af;
            --chart-bg: #ffffff; --skeleton: rgba(0,0,0,0.06);
            --short: #dc2626; --danger: #dc2626; --long: #059669;
            --brand: #374151; --warning: #b45309;
            --zone-gold: #b45309; --zone-hot: #c2410c; --zone-warm: #6b7280;
        }
        /* ── Volcanic Claro (tercer tema) ── */
        body.volcanic-light {
            --bg: #fffaf5; --surface: #fff5ec; --surface-glass: #fffaf5;
            --card-bg: rgba(234,88,12,0.06); --border: #fed7aa; --border-strong: #fb923c;
            --text-primary: #1c0800; --text-secondary: #7c2d12; --text-tertiary: #c2410c;
            --chart-bg: #fff5ec; --skeleton: rgba(0,0,0,0.06);
            --short: #dc2626; --danger: #dc2626; --long: #15803d;
            --brand: #c2410c; --warning: #92400e;
            --zone-gold: #92400e; --zone-hot: #9a3412; --zone-warm: #c2410c;
            --font-main: 'Orbitron', sans-serif; --font-head: 'Orbitron', sans-serif;
            --radius-m: 10px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        
        /* APLICAMOS ORBITRON AL BODY */
        body { font-family: var(--font-main); font-weight: 500; background: var(--bg); color: var(--text-primary); padding-top: 0; padding-bottom: 0; overflow-x: hidden; max-width: 100vw; user-select: none; font-size: 16px; overscroll-behavior-y: none; transition: background 0.3s ease, color 0.3s ease; letter-spacing: 0.5px; }
        
        /* ... ESTILOS EXISTENTES ... */
        .bot-section { background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-m); padding: 10px; margin-bottom: 8px; }
        .bot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .bot-title { font-size: 18px; font-weight: 700; color: var(--text-primary); display: flex; align-items: center; gap: 4px; }
        .bot-toggle { position: relative; width: 54px; height: 28px; }
        .bot-toggle input { opacity: 0; width: 0; height: 0; }
        .bot-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #374151; transition: 0.3s; border-radius: 28px; }
        .bot-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: 0.3s; border-radius: 50%; }
        .bot-toggle input:checked + .bot-slider { background: linear-gradient(135deg, var(--long), #059669); }
        .bot-toggle input:checked + .bot-slider:before { transform: translateX(26px); }
        .bot-status { display: flex; align-items: center; gap: 4px; padding: 8px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 10px; font-size: 13px; margin-bottom: 8px; }
        .bot-status.inactive { background: rgba(107, 114, 128, 0.1); border-color: rgba(107, 114, 128, 0.3); color: var(--text-secondary); }
        .bot-status.active { background: rgba(16, 185, 129, 0.1); border-color: rgba(16, 185, 129, 0.3); color: var(--long); }
        .bot-param-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 6px; }
        .bot-param { background: rgba(255, 255, 255, 0.02); border: 1px solid var(--border); border-radius: 10px; padding: 8px; }
        .bot-param-label { font-size: 12px; color: var(--text-secondary); margin-bottom: 4px; display: block; }
        .bot-param-input { width: 100%; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px; color: var(--text-primary); font-family: var(--font-num); font-size: 14px; text-align: center; }
        .bot-param-input:focus { outline: none; border-color: var(--brand); }
        .bot-info { font-size: 12px; color: var(--text-tertiary); line-height: 1.6; padding: 6px; background: rgba(245, 158, 11, 0.05); border-left: 3px solid var(--warning); border-radius: 6px; }
        .bot-slot-pill { text-align:center; padding:4px 2px; border-radius:8px; font-size:9px; font-weight:700; background:var(--surface-2); border:1px solid var(--border); color:var(--text-tertiary); line-height:1.3; }
        .bot-slot-pill.manual { border-color:var(--border); color:var(--text-tertiary); }
        .bot-slot-pill.waiting { border-color:var(--brand); color:var(--brand); background:rgba(59,130,246,0.08); }
        .bot-slot-pill.buying { border-color:var(--long); color:var(--long); background:rgba(16,185,129,0.1); animation:pulse-ring 1.5s infinite; }
        .bot-slot-pill.trailing { border-color:var(--warning); color:var(--warning); background:rgba(245,158,11,0.1); animation:pulse-ring 1.5s infinite; }
        .bot-slot-pill.paused { border-color:var(--danger); color:var(--danger); background:rgba(239,68,68,0.08); }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--border-strong); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--brand); }
        
        /* APLICAR FUENTES ESPECÍFICAS */
        .brand-text, .nav-title, .setting-section-title, .theme-name-label { font-family: var(--font-head); }
        .ticker-price, .input-field, .stat-value, .u-val-primary { font-family: var(--font-num); }
        
        svg { fill: none; stroke: currentColor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 2; pointer-events: none; transition: all 0.3s ease; }
        @keyframes pulse-ring { 0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); } 70% { box-shadow: 0 0 0 6px rgba(59, 130, 246, 0); } 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); } }
        @keyframes slide-in { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes panel-fade-in { from { opacity: 0; } to { opacity: 1; } }
        @keyframes grow-up { from { height: 0; opacity: 0; } to { opacity: 1; } }
        @keyframes breathe-real { 0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.1); border-color: rgba(16, 185, 129, 0.3); } 50% { box-shadow: 0 0 15px 0 rgba(16, 185, 129, 0.3); border-color: var(--long); } 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.1); border-color: rgba(16, 185, 129, 0.3); } }
        @keyframes breathe-gold { 0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.3); transform: scale(1); background: rgba(245, 158, 11, 0.1); } 50% { box-shadow: 0 0 20px 0 rgba(245, 158, 11, 0.4); border-color: #f59e0b; transform: scale(1.02); background: rgba(245, 158, 11, 0.2); } 100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.3); transform: scale(1); background: rgba(245, 158, 11, 0.1); } }
        @keyframes breathe-radar { 
            0%   { box-shadow: 0 4px 12px rgba(0,0,0,0.2), 0 0 0 0 rgba(59,130,246,0); border-color: var(--border); transform: scale(1); } 
            40%  { box-shadow: 0 6px 28px rgba(59,130,246,0.35), 0 0 22px rgba(59,130,246,0.25); border-color: rgba(59,130,246,0.7); transform: scale(1.012); }
            60%  { box-shadow: 0 6px 28px rgba(59,130,246,0.35), 0 0 22px rgba(59,130,246,0.25); border-color: rgba(59,130,246,0.7); transform: scale(1.012); }
            100% { box-shadow: 0 4px 12px rgba(0,0,0,0.2), 0 0 0 0 rgba(59,130,246,0); border-color: var(--border); transform: scale(1); } 
        }
        @keyframes breathe-active-slot {
            0%   { box-shadow: 0 0 0 2px rgba(59,130,246,0.3), 0 0 0 rgba(59,130,246,0), 0 8px 25px rgba(0,0,0,0.3); border-color: rgba(59,130,246,0.5); }
            50%  { box-shadow: 0 0 0 3px rgba(59,130,246,0.7), 0 0 30px rgba(59,130,246,0.4), 0 8px 35px rgba(0,0,0,0.4); border-color: var(--brand); }
            100% { box-shadow: 0 0 0 2px rgba(59,130,246,0.3), 0 0 0 rgba(59,130,246,0), 0 8px 25px rgba(0,0,0,0.3); border-color: rgba(59,130,246,0.5); }
        }
        @keyframes gold-flash-anim { 0% { background-color: rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.3); box-shadow: 0 0 0 rgba(245, 158, 11, 0); } 50% { background-color: rgba(245, 158, 11, 0.25); border-color: rgba(245, 158, 11, 0.8); box-shadow: 0 0 15px rgba(245, 158, 11, 0.4); } 100% { background-color: rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.3); box-shadow: 0 0 0 rgba(245, 158, 11, 0); } }
        @keyframes gold-pulse-slot { 0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); border-color: var(--warning); background: rgba(245, 158, 11, 0.2); } 50% { box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); border-color: #fff; background: rgba(245, 158, 11, 0.5); } 100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); border-color: var(--warning); background: rgba(245, 158, 11, 0.2); } }
        
        .anim-click { transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1), background-color 0.2s, border-color 0.2s; }
        .anim-click:active { transform: scale(0.92); opacity: 0.8; }
        .anim-pulse { animation: pulse-ring 2s infinite; }
        .section-enter { animation: slide-in 0.4s cubic-bezier(0.16, 1, 0.3, 1); }
        .skeleton-box { background: var(--skeleton); background: linear-gradient(90deg, var(--skeleton) 25%, var(--card-bg) 50%, var(--skeleton) 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; border-radius: 4px; color: transparent !important; }
        .skeleton-text { display: inline-block; min-width: 40px; min-height: 1em; border-radius: 4px; }
        #toast { visibility: hidden; width: auto; max-width: 250px; background-color: var(--surface); border: 1px solid var(--border); color: var(--text-primary); text-align: center; border-radius: 16px; padding: 8px 16px; position: fixed; z-index: 9999; left: 50%; top: -100px; transform: translateX(-50%); font-weight: 700; font-size: 11px; font-family: var(--font-head); box-shadow: 0 4px 16px rgba(0,0,0,0.5); transition: top 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease; opacity: 0; backdrop-filter: blur(8px); }
        #toast.show { top: calc(15px + var(--safe-top)); visibility: visible; opacity: 1; }
        #toast.alert-mode { background-color: rgba(220, 38, 38, 0.9); color: #fff; border-color: var(--danger); }
        #toast.success-mode { background-color: rgba(16, 185, 129, 0.9); color: #fff; border-color: var(--long); }
        .fixed-header { position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; background: var(--bg); padding-top: var(--safe-top); transition: background 0.3s; border-bottom: none; }
        .app-header { display: flex; justify-content: space-between; align-items: center; height: 50px; padding: 0 16px; max-width: 1400px; margin: 0 auto; position: relative; }
        .brand-btn { display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 5px; position: relative; z-index: 50; transition: opacity 0.4s ease, transform 0.4s ease; opacity: 1; transform: translateX(0); }
        .theme-btn { width: 36px; height: 36px; border-radius: 50%; background: transparent; border: 1px solid var(--border); color: var(--text-primary); display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; position: relative; z-index: 50; transition: opacity 0.4s ease, transform 0.4s ease; opacity: 1; transform: translateX(0); }
        .brand-btn.hidden { opacity: 0; transform: translateX(-15px); pointer-events: none; }
        .theme-btn.hidden { opacity: 0; transform: translateX(15px); pointer-events: none; }
        
        /* USER MENU DROPDOWN */
        .user-menu-wrapper { position: relative; z-index: 200; }
        .user-btn { width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, var(--brand), rgba(59,130,246,0.6)); border: 1.5px solid var(--brand); color: #fff; display: flex; align-items: center; justify-content: center; font-size: 17px; flex-shrink: 0; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 0 10px rgba(59,130,246,0.3); }
        .user-btn:active { transform: scale(0.92); }
        .user-dropdown { position: absolute; top: calc(100% + 10px); right: 0; background: var(--surface); border: 1px solid var(--border); border-radius: 18px; min-width: 210px; box-shadow: 0 8px 32px rgba(0,0,0,0.45); overflow: hidden; display: none; animation: slide-in 0.25s cubic-bezier(0.16,1,0.3,1); z-index: 300; }
        .user-dropdown.open { display: block; }
        
        /* Fila 1: 5X + tema */
        .user-drop-row1 { padding: 14px 16px 12px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
        .user-drop-c5x { font-family: var(--font-head); font-size: 20px; font-weight: 900; color: var(--brand); letter-spacing: 2px; }
        .user-drop-theme-toggle { display: flex; align-items: center; gap: 5px; background: var(--bg); border: 1px solid var(--border); border-radius: 20px; padding: 5px 10px; cursor: pointer; transition: all 0.2s; }
        .user-drop-theme-toggle:active { transform: scale(0.94); background: rgba(59,130,246,0.1); border-color: var(--brand); }
        .user-drop-theme-label { font-family: var(--font-head); font-size: 9px; font-weight: 700; color: var(--text-tertiary); letter-spacing: 0.5px; }
        
        /* Fila 2: Cuenta */
        .user-drop-account { align-items: center; gap: 10px; padding: 12px 16px !important; background: rgba(66,133,244,0.04); border-bottom: 1px solid var(--border) !important; }
        .user-drop-account-info { flex: 1; display: flex; flex-direction: column; gap: 1px; }
        .user-drop-account-label { font-family: var(--font-head); font-size: 10px; font-weight: 800; color: var(--text-primary); letter-spacing: 0.5px; }
        .user-drop-account-sub { font-family: var(--font-num); font-size: 10px; color: var(--text-tertiary); }
        .user-drop-account-status { color: var(--text-tertiary); }
        
        /* Items generales */
        .user-drop-item { padding: 12px 16px; display: flex; align-items: center; gap: 10px; cursor: pointer; font-family: var(--font-head); font-size: 11px; font-weight: 700; color: var(--text-secondary); letter-spacing: 0.5px; transition: background 0.2s, color 0.2s; border-top: 1px solid var(--border); }
        .user-drop-item:first-child { border-top: none; }
        .user-drop-item:active { background: rgba(59,130,246,0.1); color: var(--brand); }
        .user-drop-item svg { flex-shrink: 0; color: var(--text-tertiary); }
        .user-drop-item:active svg { color: var(--brand); }
        
        /* Botón flotante para ir al Monitor ETF */
        .etf-float-btn {
            position: fixed !important;
            bottom: 84px !important;
            right: 14px !important;
            top: auto !important;
            left: auto !important;
            width: 54px !important;
            height: 54px !important;
            border-radius: 50% !important;
            background: var(--surface) !important;
            border: 1.5px solid var(--border-strong) !important;
            color: var(--text-primary) !important;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9997 !important;
            box-shadow:
                0 0 0 1px rgba(255,255,255,0.04) inset,
                0 4px 16px rgba(0,0,0,0.55),
                0 0 20px rgba(209,213,219,0.06) !important;
            transition: transform 0.18s cubic-bezier(.34,1.56,.64,1), box-shadow 0.18s ease, border-color 0.18s ease;
            animation: floatRadarPulse 3.5s ease-in-out infinite;
        }
        @keyframes floatRadarPulse {
            0%,100% { transform: translateY(0px); box-shadow: 0 0 0 1px rgba(255,255,255,0.04) inset, 0 4px 16px rgba(0,0,0,0.55), 0 0 20px rgba(209,213,219,0.06); }
            50%      { transform: translateY(-4px); box-shadow: 0 0 0 1px rgba(255,255,255,0.06) inset, 0 8px 24px rgba(0,0,0,0.6), 0 0 28px rgba(52,211,153,0.12); }
        }
        .etf-float-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.07), transparent 65%);
            pointer-events: none;
        }
        .etf-float-btn:hover  {
            animation: none;
            transform: translateY(-3px) scale(1.08) !important;
            border-color: var(--long) !important;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.06) inset, 0 6px 20px rgba(0,0,0,0.6), 0 0 24px rgba(52,211,153,0.2) !important;
        }
        .etf-float-btn:active {
            animation: none;
            transform: scale(0.93) !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4) !important;
        }
        .etf-float-btn.hidden { display: none !important; }
        
        /* SISTEMA DE 3 PANELES DESLIZABLES (ESTILO WHATSAPP) */
        .panels-wrapper {
            position: fixed;
            top: calc(var(--safe-top) + 50px);
            left: 0;
            width: 100%;
            height: calc(100vh - var(--safe-top) - 50px - var(--safe-bottom));
            overflow: hidden;
            z-index: 10;
        }
        /* ==========================================
           SISTEMA DE 4 PANELES DESLIZABLES
           ==========================================
           - Panel 0 (ID: panel0): Dashboard de Trading (5 slots)
           - Panel 1 (ID: panel1): Temporalidades + Chart + Radar
           - Panel 4 (ID: panel4): Vacío
           - Panel 5 (ID: panel5): Chart Secundario + 12 Niveles de Trading
           
           Cada panel ocupa 25% del ancho total (100% / 4)
           El contenedor total es 400% (4 × 100%)
           Las transformaciones mueven el contenedor en incrementos de 25%
        ========================================== */
        
        .panels-container {
            display: flex;
            width: 300%;
            height: 100%;
            transition: transform 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            will-change: transform;
            touch-action: pan-y;
        }
        .panels-container.is-dragging { transition: none !important; }
        
        .panel {
            width: 33.3333%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            flex-shrink: 0;
        }
        .panel-content { min-height: 100%; padding: 4px; }
        #panel0 { display:flex; flex-direction:column; }
        #panel0 .panel-content { flex:1; display:flex; flex-direction:column; min-height:0; overflow:hidden; }
        #dashboardsContainer { flex:1; display:flex; flex-direction:column; min-height:0; overflow-y:auto; overflow-x:hidden; -webkit-overflow-scrolling:touch; gap:0; padding-bottom:16px; }
        #dashboardsContainer .dashboard-card { flex:0 0 auto; min-height:122px; max-height:122px; margin:3px 4px !important; }
        

        
        /* Estilos para paneles vacíos */
        .empty-panel-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-tertiary);
            font-family: var(--font-head);
            text-align: center;
            padding: 40px 20px;
        }
        
        .empty-panel-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
        
        .empty-panel-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }
        
        .empty-panel-subtitle {
            font-size: 14px;
            opacity: 0.7;
        }
        
        /* Indicadores de panel — ocultos */
        .panel-indicators { display: none !important; }
        .panel-dot.active {
            background: var(--brand);
            width: 24px;
            border-radius: 4px;
        }
        
        /* Display de USDT disponible en header (reemplaza ticker en paneles 2 y 3) */
        .usdt-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--long);
            padding: 8px 20px;
            border-radius: 20px;
            font-family: var(--font-num);
            font-weight: 800;
            font-size: 18px;
            color: var(--long);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.15);
        }
        
        .usdt-label {
            font-family: var(--font-head);
            font-size: 13px;
            font-weight: 900;
            letter-spacing: 2px;
            color: var(--long);
        }
        
        .usdt-amount {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 800;
            color: var(--long);
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }
        
        
        .brand-text { font-family: var(--font-head); font-weight: 900; font-size: 24px; color: var(--brand); line-height: 1; }
        .ticker-container { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; width: 60%; max-width: 300px; z-index: 10; pointer-events: none; transition: all 0.5s cubic-bezier(0.25, 1, 0.5, 1); }
        .ticker-container.expanded { width: 95%; max-width: 600px; }
        .ticker-pill { display: flex; align-items: center; justify-content: center; gap: 12px; background: rgba(255,255,255,0.03); border: 1px solid var(--border); padding: 0 16px; border-radius: 24px; height: 40px; transition: all 0.4s ease; white-space: nowrap; overflow: hidden; width: 100%; pointer-events: auto; position: relative; }
        .ticker-pill.pinned-mode { border-color: var(--brand); background: rgba(59, 130, 246, 0.08); box-shadow: 0 0 10px rgba(59, 130, 246, 0.15); }
        .ticker-pill.scrolled-mode { background: rgba(59, 130, 246, 0.12); border-color: var(--brand); box-shadow: 0 4px 15px rgba(59, 130, 246, 0.25); }
        .ticker-group-left { display: flex; align-items: center; gap: 6px; flex: 0 0 auto; }
        .ticker-group-right { display: flex; align-items: center; gap: 8px; flex: 0 0 auto; }
        .ticker-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-secondary); transition: background 0.3s; flex-shrink: 0; }
        .ticker-dot.pulse { animation: pulse-ring 1.5s infinite; }
        .ticker-sym { font-family: var(--font-head); font-weight: 800; font-size: 14px; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; }
        .ticker-price { font-family: var(--font-num); font-weight: 800; font-size: 16px; color: var(--text-primary); }
        .ticker-pct { font-family: var(--font-num); font-weight: 700; font-size: 12px; padding: 2px 6px; border-radius: 6px; }
        .ticker-pct.up { background: rgba(16, 185, 129, 0.15); color: var(--long); }
        .ticker-pct.down { background: rgba(239, 68, 68, 0.15); color: var(--short); }
        .content-spacer {
            margin-top: calc(var(--safe-top) + 50px);
            width: 100%;
            max-width: min(800px, 100vw);
            margin-left: auto;
            margin-right: auto;
            padding: 0 4px;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .app-section { display: none; opacity: 0; transition: opacity 0.2s ease; width: 100%; box-sizing: border-box; overflow-x: hidden; }
        .app-section.active { display: block; opacity: 1; animation: slide-in 0.25s cubic-bezier(0.16, 1, 0.3, 1); }
        /* Padding mínimo solo en secciones de menú (no operate que usa panels-wrapper) */
        #section-settings.active,
        #section-etf.active,
        #section-log.active,
        #section-support.active,
        #section-strategy.active,
        #section-botdash.active { padding-top: 0; padding-bottom: 16px; }
        .scroll-hidden { opacity: 0 !important; pointer-events: none !important; max-height: 0px !important; padding-top: 0px !important; padding-bottom: 0px !important; transform: translateY(-20px); margin-top: 0 !important; margin-bottom: 0 !important; }
        .tf-bar { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; padding: 4px 12px 6px 12px; justify-content: center; background: var(--bg); border: none; margin: 0; box-shadow: none; overflow: hidden; max-height: 50px; opacity: 1; transform: translateY(0); transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, padding 0.4s ease, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .tf-btn { background: transparent; border: none; color: var(--text-tertiary); padding: 4px 0; text-align: center; font-family: sans-serif; font-size: 12px; font-weight: 700; border-radius: 8px 8px 0 0; transition: all 0.2s; }
        .tf-btn.active { color: var(--brand); background: rgba(59, 130, 246, 0.1); font-weight: 800; }
        
        /* SLOT NAV 8 SLOTS */
        
        .chart-wrapper { height: 280px; background: var(--chart-bg); margin: 0 10px 6px 10px; border-radius: var(--radius-m); border: 1px solid var(--border); overflow: hidden; position: relative; }
        .chart-wrapper.fullscreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 5000; margin: 0; border-radius: 0; border: none; padding-top: var(--safe-top); padding-bottom: var(--safe-bottom); background: var(--bg); }
        .price-lines-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 10; }
        .price-line { position: absolute; left: 0; right: 0; height: 2px; display: flex; align-items: center; }
        .price-line.avg-line { background: linear-gradient(90deg, transparent, rgba(92, 124, 138, 0.5) 5%, rgba(92, 124, 138, 0.5) 95%, transparent); }
        .price-line.target-line { background: linear-gradient(90deg, transparent, rgba(217, 158, 75, 0.5) 5%, rgba(217, 158, 75, 0.5) 95%, transparent); border-top: 2px dashed var(--warning); }
        .price-line.buy-line { background: linear-gradient(90deg, transparent, rgba(111, 156, 118, 0.3) 5%, rgba(111, 156, 118, 0.3) 95%, transparent); }
        .price-label { position: absolute; right: 10px; background: rgba(10, 14, 19, 0.9); padding: 3px 8px; border-radius: 4px; font-family: var(--font-num); font-size: 10px; font-weight: 800; white-space: nowrap; backdrop-filter: blur(4px); top: -12px; }
        .price-label.avg { color: var(--brand); border-left: 3px solid var(--brand); }
        .price-label.target { color: var(--warning); border-left: 3px solid var(--warning); }
        .price-label.buy { color: var(--long); border-left: 3px solid var(--long); }
        .chart-fs-btn { position: absolute; bottom: 10px; right: 10px; z-index: 20; width: 30px; height: 30px; background: rgba(128,128,128,0.2); border-radius: 6px; display: flex; align-items: center; justify-content: center; color: var(--text-primary); backdrop-filter: blur(4px); }
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; padding: 10px; }
        .input-group { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius-m); padding: 6px; text-align: center; transition: border-color 0.3s, background 0.3s; }
        .input-group:focus-within { border-color: var(--brand); }
        .input-label { font-size: 10px; color: var(--text-secondary); font-weight: 700; text-transform: uppercase; display: block; margin-bottom: 2px; }
        .input-field { width: 100%; background: transparent; border: none; color: var(--text-primary); font-family: var(--font-num); font-size: 15px; font-weight: 700; text-align: center; }
        .input-field.locked-input { color: var(--brand) !important; opacity: 1; cursor: context-menu; font-weight: 800; -webkit-text-fill-color: var(--brand); }
        .input-field.manual-edit { background: rgba(59, 130, 246, 0.15) !important; border-bottom: 2px solid var(--brand) !important; color: #fff !important; -webkit-text-fill-color: #fff !important; animation: pulse-ring 2s infinite; }
        .input-field.editing-mode { color: var(--text-primary) !important; -webkit-text-fill-color: var(--text-primary); border-bottom: 2px solid var(--brand); background: rgba(59, 130, 246, 0.1); opacity: 1; }
        
        .radar-ticker-large { 
            background: var(--surface); 
            border: 1px solid var(--border); 
            border-radius: 18px; 
            padding: 12px 14px;
            margin: 4px 10px 10px; 
            text-align: center; 
            position: relative; 
            cursor: pointer; 
            transition: background 0.3s, opacity 0.3s; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); 
            min-height: 110px;
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            user-select: none;
            animation: breathe-radar 3s ease-in-out infinite;
        }
        .radar-ticker-large:active { transform: scale(0.98); background: var(--card-bg); }
        .radar-ticker-large.flash-gold { animation: gold-flash-anim 2s infinite ease-in-out !important; }
        .radar-ticker-large.gold-mode-active { 
            animation: breathe-gold 2s infinite ease-in-out !important; 
            border-color: rgba(251, 191, 36, 0.4);
            background: rgba(251, 191, 36, 0.05) !important;
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.15) !important;
        }
        .radar-status-dot { position: absolute; top: 10px; left: 10px; width: 7px; height: 7px; border-radius: 50%; background: var(--long); box-shadow: 0 0 8px var(--long); }
        .radar-status-dot.offline { background: var(--danger); box-shadow: none; opacity: 0.5; }
        
        /* FUENTE JETBRAINS MONO PARA TODOS LOS NÚMEROS */
        .number-display,
        #resInv,
        #resAvg,
        #resTarget,
        .stat-val,
        .u-val-primary,
        .u-val-secondary,
        .etf-change-badge,
        .etf-score-display,
        #totalBalanceDisplay,
        #radarValue,
        .ticker-price,
        #t-price,
        #t-pct,
        input[type="number"],
        .level-price,
        .level-profit,
        .level-qty {
            font-family: 'JetBrains Mono', monospace !important;
            font-weight: 700 !important;
            letter-spacing: 0.3px !important;
        }
        
        .radar-header-line {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            width: 100%;
        }
        .radar-title-compact { 
            font-family: var(--font-head); 
            font-size: 11px;
            font-weight: 900; 
            color: var(--brand); 
            letter-spacing: 2px;
            display: flex; 
            align-items: center; 
            gap: 5px;
            text-transform: uppercase;
            opacity: 0.8;
        }
        .radar-balance-compact {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 800;
            color: var(--long);
            text-shadow: 0 0 12px rgba(16, 185, 129, 0.3);
            white-space: nowrap;
            letter-spacing: 0.5px;
        }
        
        .radar-token-centered { 
            font-family: var(--font-num); 
            font-weight: 800; 
            font-size: 26px; 
            color: var(--text-primary); 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            gap: 4px;
            text-align: center;
            width: 100%;
        }
        
        .dash-header-new {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
            gap: 0px;
        }
        .dash-app-label {
            font-family: var(--font-head);
            font-size: 10px;
            font-weight: 700;
            color: var(--text-tertiary);
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        .dash-coin-title {
            font-family: var(--font-head);
            font-weight: 900;
            font-size: 32px;
            color: var(--brand);
            text-transform: uppercase;
            line-height: 1.1;
        }

        /* GRID 6 CELDAS — 3 cols × 2 filas */
        .dash-compact-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: 52px 52px;
            gap: 4px;
        }
        /* ACTIVO — celda normal en col 1 fila 1 */
        .dash-cell-coin {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1px;
            overflow: hidden;
        }
        .dash-cell-coin-label {
            font-family: var(--font-head);
            font-size: 7px;
            font-weight: 700;
            color: var(--text-tertiary);
            letter-spacing: 1px;
            text-transform: uppercase;
            line-height: 1;
        }
        .dash-cell-coin-name {
            font-family: var(--font-head);
            font-weight: 900;
            font-size: 13px;
            color: var(--brand);
            text-transform: uppercase;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* CELDAS INDIVIDUALES */
        .dash-cell {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1px;
            position: relative;
            transition: all 0.2s;
            overflow: hidden;
        }
        .dash-cell:active { transform: scale(0.97); }
        .dash-cell.pressing {
            background: rgba(239, 68, 68, 0.1) !important;
            border-color: var(--danger) !important;
        }
        .dash-cell-label {
            font-family: var(--font-head);
            font-size: 7px;
            font-weight: 700;
            color: var(--text-tertiary);
            letter-spacing: 0.8px;
            text-transform: uppercase;
            line-height: 1;
        }
        .dash-cell-value {
            font-family: var(--font-num);
            font-size: 11px;
            font-weight: 800;
            color: var(--text-primary);
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .dash-cell-value.warning { color: var(--warning); }
        /* .dash-cell-manual — sin estilos propios, usa herencia de .dash-cell */

        /* DASHBOARD CARD — inactivo */
        .dashboard-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 18px;
            margin: 5px 6px;
            padding: 8px;
            box-shadow: 0 4px 14px rgba(0,0,0,0.25);
            position: relative;
            overflow: hidden;
            transition: all 0.35s ease;
            opacity: 1;
        }
        .dashboard-card::before {
            content: '';
            position: absolute; top: 0; left: 0;
            width: 100%; height: 2px;
            background: var(--border);
        }
        /* DASHBOARD CARD — ACTIVO: destaca claramente */
        .dashboard-card.slot-active {
            background: linear-gradient(145deg, rgba(59,130,246,0.10) 0%, var(--surface) 60%);
            border-color: var(--brand);
            border-width: 2px;
            box-shadow:
                0 0 0 3px rgba(59,130,246,0.22),
                0 8px 32px rgba(59,130,246,0.18),
                inset 0 1px 0 rgba(255,255,255,0.06);
            opacity: 1;
            transform: scale(1.012);
            animation: breathe-active-slot 2.5s ease-in-out infinite;
        }
        .dashboard-card.slot-active::before {
            background: linear-gradient(90deg, var(--brand), var(--long));
            height: 3px;
        }
        .dashboard-card.slot-active .dash-slot-label { color: var(--brand); }
        .dash-slot-label {
            font-family: var(--font-head);
            font-size: 8px; font-weight: 900; letter-spacing: 2px;
            color: var(--text-tertiary); text-align: right;
            margin-bottom: 4px; padding-right: 2px;
        }
        .dashboard-card.slot-active .dash-slot-label::before { content: '▶ '; color: var(--brand); }
        /* Icono inline dentro de celda — label + icono en fila */
        .dash-cell-label-row {
            display: flex; align-items: center; justify-content: space-between; gap: 2px;
        }
        .dash-cell-icon-btn {
            width: 28px; height: 28px; border-radius: 8px; flex-shrink: 0;
            border: 1px solid var(--border); background: var(--bg);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; opacity: 0.85;
            transition: opacity 0.12s, background 0.12s, transform 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .dash-cell-icon-btn:active { opacity: 1; background: var(--border); transform: scale(0.88); }
        .dash-cell-icon-btn.sell-ico { border-color: rgba(251,191,36,0.55); background: rgba(251,191,36,0.06); }
        .dash-cell-icon-btn.pos-ico  { border-color: rgba(209,213,219,0.35); background: rgba(209,213,219,0.04); }
        /* Celda de venta dedicada */
        .dash-cell-sell {
            background: rgba(251,191,36,0.07);
            border: 1px solid rgba(251,191,36,0.35);
            border-radius: 12px;
            padding: 4px 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .dash-cell-sell:active { background: rgba(251,191,36,0.18); transform: scale(0.95); }
        .dash-cell-sell-icon { color: #fbbf24; }
        .dash-cell-sell-lbl { font-family: var(--font-head); font-size: 7px; font-weight: 800; color: #fbbf24; letter-spacing: 0.8px; }
        /* Celda PNL vivo */
        .dash-cell-pnl {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 4px 6px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1px;
            overflow: hidden;
        }
        /* Cara trasera — tarjeta de posición */
        .dash-pos-face {
            position: absolute; inset: 0; border-radius: 17px;
            background: var(--surface); padding: 8px 10px;
            display: flex; flex-direction: column; gap: 5px;
            transform: translateX(102%);
            transition: transform 0.28s cubic-bezier(0.4,0,0.2,1);
            z-index: 5; overflow: hidden;
        }
        .dash-pos-face.visible { transform: translateX(0); }
        .dash-pos-header { display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; }
        .dash-pos-coin { font-family: var(--font-head); font-size: 14px; font-weight: 900; line-height: 1; }
        .dash-pos-back-btn {
            width: 22px; height: 22px; border-radius: 7px;
            border: 1px solid var(--border); background: var(--bg);
            color: var(--text-secondary); display: flex; align-items: center;
            justify-content: center; cursor: pointer; transition: all 0.15s;
        }
        .dash-pos-back-btn:active { transform: scale(0.85); }
        .dash-pos-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; flex: 1; }
        .dash-pos-cell {
            background: var(--card-bg); border: 1px solid var(--border);
            border-radius: 10px; padding: 4px 6px;
            display: flex; flex-direction: column; justify-content: center; gap: 1px;
        }
        .dash-pos-lbl {
            font-family: var(--font-head); font-size: 7px; font-weight: 700;
            color: var(--text-tertiary); letter-spacing: 0.8px; line-height: 1;
        }
        .dash-pos-val {
            font-family: var(--font-num); font-size: 10px; font-weight: 800;
            color: var(--text-primary); line-height: 1.1;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .dash-controls-unified { display: grid; grid-template-columns: 1fr; gap: 4px; align-items: stretch; margin-top: 0; }

        /* ── BOTONES 3D TIPEABLES ── */
        /* Cualquier botón con anim-click tiene efecto 3D presionable */
        .anim-click {
            position: relative;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 rgba(0,0,0,0.35), 0 6px 12px rgba(0,0,0,0.2);
            transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s;
        }
        .anim-click:active, .anim-click.pressing {
            transform: translateY(1px) !important;
            box-shadow: 0 1px 0 rgba(0,0,0,0.35), 0 2px 4px rgba(0,0,0,0.15) !important;
            filter: brightness(0.92);
        }
        /* Botones de acción principales — más pronunciados */
        .btn-save-mini.anim-click, .action-btn.anim-click {
            transform: translateY(-2px);
            box-shadow: 0 3px 0 rgba(0,0,0,0.4), 0 5px 10px rgba(0,0,0,0.18);
        }
        .btn-save-mini.anim-click:active, .action-btn.anim-click:active {
            transform: translateY(1px) !important;
            box-shadow: 0 1px 0 rgba(0,0,0,0.4) !important;
        }
        /* Nav items — efecto más sutil */
        .nav-item.anim-click {
            transform: none;
            box-shadow: none;
        }
        .nav-item.anim-click:active {
            transform: scale(0.94) !important;
            box-shadow: none !important;
        }
        
        #etfMonitorToggleBtn { display: none; background: rgba(59, 130, 246, 0.1); border: 1px solid var(--brand); border-radius: var(--radius-m); padding: 12px 16px; cursor: pointer; transition: all 0.3s ease; align-items: center; justify-content: space-between; margin-bottom: 10px; font-family: var(--font-head); font-weight: 800; font-size: 12px; letter-spacing: 1px; color: var(--brand); user-select: none; }
        #etfMonitorToggleBtn:hover { background: rgba(59, 130, 246, 0.15); transform: translateY(-2px); }
        #etfMonitorToggleBtn:active { transform: translateY(0); }
        #etfMonitorToggleBtn.collapsed { background: rgba(255, 255, 255, 0.02); border-color: var(--border); color: var(--text-secondary); }
        .toggle-icon { font-size: 10px; transition: transform 0.3s ease; margin-left: auto; }
        .toggle-icon.rotated { transform: rotate(180deg); }
        .dash-toggles-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 8px; }
        .mode-toggle-pill, .strat-toggle-pill { text-align: center; font-family: var(--font-head); font-weight: 800; font-size: 11px; padding: 10px 4px; border-radius: 12px; cursor: pointer; transition: all 0.2s; border: 1px solid var(--border); background: rgba(255,255,255,0.02); text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; justify-content: center; height: 40px; user-select: none; }
        .mode-toggle-pill.real { background: rgba(16, 185, 129, 0.15); color: var(--long); border-color: var(--long); animation: breathe-real 4s infinite; }
        .mode-toggle-pill.real.disconnected { background: #2a2d35; color: #6b7280; border-color: #3a3d45; animation: none; opacity: 0.7; }
        .mode-toggle-pill.sim { background: rgba(245, 158, 11, 0.15); color: var(--warning); border-color: var(--warning); }
        .mode-toggle-pill:active, .strat-toggle-pill:active { transform: scale(0.95); opacity: 0.8; }
        
        .strategy-option { 
            text-align: center; 
            font-family: var(--font-head); 
            font-weight: 800; 
            font-size: 10px; 
            padding: 10px 4px; 
            border-radius: 12px; 
            cursor: pointer; 
            transition: all 0.3s ease; 
            border: 1.5px solid var(--border); 
            background: rgba(255,255,255,0.02); 
            text-transform: uppercase; 
            letter-spacing: 0.5px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            height: 40px; 
            user-select: none; 
            opacity: 0.4; 
            color: var(--text-secondary); 
        }
        .strategy-option:active { transform: scale(0.95); }
        .strategy-option.active { opacity: 1; border-width: 2px; }
        #stratNormal.active { background: rgba(59, 130, 246, 0.15); color: var(--brand); border-color: var(--brand); box-shadow: 0 0 12px rgba(59, 130, 246, 0.3); }
        .strat-toggle-pill.aggressive { color: var(--short); border-color: var(--short); background: rgba(239, 68, 68, 0.1); }
        .strat-toggle-pill.gold-mode { color: var(--warning); border-color: var(--warning); background: rgba(245, 158, 11, 0.1); animation: breathe-gold 2s infinite !important; }
        
        .target-and-strategies-row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 3px;
            align-items: stretch;
            margin-bottom: 4px;
        }
        .strategy-option-compact {
            background: rgba(255,255,255,0.02);
            border: 1.5px solid var(--border);
            border-radius: 10px;
            padding: 0px 4px !important;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-head);
            font-weight: 900;
            font-size: 9px !important;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            color: var(--text-secondary);
            user-select: none;
            opacity: 0.4;
            line-height: 1 !important;
        }
        .strategy-option-compact:active { transform: scale(0.95); }
        .strategy-option-compact.active { opacity: 1; border-width: 2px; }
        .strategy-option-compact.mode-normal { 
            background: rgba(59, 130, 246, 0.15); 
            color: var(--brand); 
            border-color: var(--brand); 
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
            opacity: 1;
        }
        .strategy-option-compact.mode-dorada { 
            background: rgba(251, 191, 36, 0.20); 
            color: #fbbf24; 
            border-color: #fbbf24; 
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
            opacity: 1;
        }
        .strategy-option-compact#stratNormal.active { 
            background: rgba(59, 130, 246, 0.15); 
            color: var(--brand); 
            border-color: var(--brand); 
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3); 
        }
        .strategy-option-compact.pressing,
        .dash-target-bar-compact.pressing {
            transform: scale(0.95) !important;
            background: rgba(59, 130, 246, 0.2) !important;
            border-color: var(--brand) !important;
            transition: all 0.1s ease;
            position: relative;
        }
        .strategy-option-compact.pressing::before,
        .dash-target-bar-compact.pressing::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 3px;
            background: var(--brand);
            animation: press-progress 1.2s linear;
            z-index: 10;
        }
        
        /* Inputs de Precio Base y Capital en Dashboard */
        .dash-input-box {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 4px 6px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .dash-input-box:active { transform: scale(0.98); }
        .dash-input-box .stat-lbl {
            font-size: 8px !important;
            margin-bottom: 2px !important;
        }
        .dash-input-box input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: var(--font-num);
            font-size: 13px !important;
            font-weight: 800;
            text-align: center;
            width: 100%;
            outline: none;
            padding: 0;
        }
        .dash-input-box input:focus {
            color: var(--brand);
        }
        .dash-input-box.editable {
            border-color: var(--brand);
            background: rgba(59, 130, 246, 0.05);
        }
        
        .dash-target-bar-compact {
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.1), rgba(251, 146, 60, 0.05));
            border: 1px solid var(--warning);
            border-radius: 10px;
            padding: 0px 6px !important; /* Padding mínimo */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .dash-target-bar-compact:active { transform: scale(0.98); }
        .dash-target-bar-compact .target-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0 !important;
            justify-content: center;
        }
        .dash-target-bar-compact .stat-lbl {
            font-size: 8px !important;
            margin-bottom: 0px !important;
            line-height: 1 !important;
        }
        .dash-target-bar-compact .stat-val {
            font-size: 14px !important;
            line-height: 1.1 !important;
        }
        
        .dash-footer-hint { display: none !important; }
        .target-right-icon { display: none !important; }
        
        .dash-stats-matrix { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 3px; margin-bottom: 4px; }
        
        /* REGLA CRÍTICA: Todas las casillas del dashboard deben tener exactamente 48px de altura */
        .stat-box-unified,
        .strategy-option-compact,
        .dash-target-bar-compact {
            box-sizing: border-box !important;
            height: 48px !important;
            min-height: 48px !important;
            max-height: 48px !important;
            overflow: hidden !important;
        }
        
        .stat-box-unified { 
            background: rgba(255,255,255,0.02); 
            border: 1px solid var(--border); 
            border-radius: 10px; 
            padding: 2px 2px; 
            text-align: center; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            position: relative; 
        }
        .stat-lbl { font-size: 9px !important; color: var(--text-tertiary); font-weight: 700; margin-bottom: 0px !important; text-transform: uppercase; line-height: 1 !important; }
        .stat-val { font-family: var(--font-num); font-size: 14px !important; font-weight: 800; color: var(--text-primary); line-height: 1.1 !important; }
        .stat-val.green { color: var(--long); }
        .expand-icon { font-size: 10px; color: var(--brand); transition: transform 0.3s; }
        .expand-icon.expanded { transform: rotate(180deg); }
        .dash-controls-unified { display: grid; grid-template-columns: 1fr 44px; gap: 4px; align-items: stretch; margin-top: 4px; }
        .btn-mini-control { width: 44px; height: 44px; background: rgba(255,255,255,0.02); border: 1px solid var(--border); border-radius: 12px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s; color: var(--text-secondary); }
        .btn-mini-control:active { transform: scale(0.95); }
        .btn-clean-unified:active { background: rgba(220, 38, 38, 0.1); color: var(--danger); border-color: var(--danger); }
        .btn-toggle-levels.active { background: rgba(59, 130, 246, 0.1); color: var(--brand); border-color: var(--brand); }
        .trading-manual-btn { background: rgba(59, 130, 246, 0.1); border: 2px solid var(--brand); border-radius: 12px; padding: 0 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1px; font-family: var(--font-head); font-weight: 900; font-size: 12px; letter-spacing: 0.8px; color: var(--brand); cursor: pointer; transition: all 0.2s; position: relative; overflow: hidden; height: 44px; }
        .trading-manual-btn:active { transform: scale(0.98); background: rgba(59, 130, 246, 0.15); }
        .trading-manual-btn.auto-mode { background: rgba(16, 185, 129, 0.1); border-color: var(--long); color: var(--long); }
        .trading-manual-btn.auto-mode::before { content: ''; position: absolute; left: 0; top: 0; height: 100%; width: 4px; background: var(--long); animation: pulse-ring 2s infinite; }
        .trading-manual-btn.locked { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        .levels-container { 
            padding: 8px 10px 8px 10px; 
            display: flex; 
            flex-direction: column; 
            gap: 7px; 
            padding-bottom: 8px;
            max-height: 100% !important;
            min-height: 0;
            height: auto;
            overflow-y: auto !important;
            overflow-x: hidden; 
            -webkit-overflow-scrolling: touch;
            transition: opacity 0.3s ease; 
            opacity: 1;
            position: relative;
            scroll-behavior: smooth;
            touch-action: pan-y !important;
            overscroll-behavior: contain;
            /* Permitir scroll desde toda el área */
            user-select: none;
            -webkit-user-select: none;
        }
        /* Scrollbar visible en todo el contenedor */
        .levels-container::-webkit-scrollbar { 
            width: 6px;
        }
        .levels-container::-webkit-scrollbar-track { 
            background: rgba(255,255,255,0.03); 
            border-radius: 3px;
        }
        .levels-container::-webkit-scrollbar-thumb { 
            background: var(--brand); 
            border-radius: 3px; 
        }
        .levels-container::-webkit-scrollbar-thumb:hover { 
            background: rgba(59, 130, 246, 1); 
        }
        .levels-container.collapsed { 
            max-height: 0 !important; 
            opacity: 0 !important; 
            padding-top: 0 !important; 
            padding-bottom: 0 !important; 
            overflow: hidden !important; 
        }
        
        /* Monitor ETF: Lista lineal sin scroll y sin espacios muertos */
        #etfGrid.levels-container {
            max-height: none; /* Eliminar límite de altura */
            overflow-y: visible; /* Sin scroll */
            padding: 0 10px; /* Sin padding arriba/abajo */
            padding-bottom: 8px; /* Reducido al mínimo */
            padding-top: 0; /* Sin espacio arriba */
        }
        
        .unified-card { 
            background: var(--card-bg); 
            border: 1px solid var(--border); 
            border-radius: var(--radius-m); 
            padding: 10px; 
            display: grid; 
            grid-template-columns: 44px 1fr auto; 
            gap: 10px; 
            align-items: center; 
            cursor: pointer; 
            transition: transform 0.1s ease, background 0.2s ease, border-color 0.3s, opacity 0.3s ease; 
            position: relative; 
            overflow: hidden; 
            height: 82px !important;
            min-height: 82px !important;
            max-height: 82px !important;
            opacity: 0.75; 
            flex-shrink: 0 !important;
            box-sizing: border-box !important;
            contain: layout style paint;
            will-change: auto;
            /* Permitir scroll sin interferencias */
            touch-action: pan-y !important;
            user-select: none;
            -webkit-user-select: none;
        }
        .unified-card:active { transform: scale(0.98); }
        .unified-card.is-pending { opacity: 1 !important; border: 1px dashed var(--warning) !important; background: rgba(245, 158, 11, 0.05) !important; transform: scale(1.0); }
        .unified-card.is-sent { opacity: 1 !important; border: 1px solid var(--warning) !important; background: rgba(245, 158, 11, 0.08) !important; transform: scale(1.0); }
        .unified-card.is-filled { opacity: 1 !important; background: rgba(16, 185, 129, 0.12) !important; border: 1px solid var(--long) !important; box-shadow: 0 4px 15px rgba(16, 185, 129, 0.15); transform: scale(1.01); z-index: 5; }
        .unified-card.is-filled-extra { opacity: 1 !important; background: rgba(245, 158, 11, 0.13) !important; border: 1px solid var(--warning) !important; box-shadow: 0 4px 15px rgba(245, 158, 11, 0.2); transform: scale(1.01); z-index: 5; }
        .unified-card.is-reached { opacity: 1 !important; border: 1px solid rgba(59, 130, 246, 0.6) !important; background: rgba(59, 130, 246, 0.08) !important; transform: scale(1.0); }
        .unified-card.is-triggered { opacity: 1 !important; border: 1px solid rgba(251,191,36,0.7) !important; background: rgba(251,191,36,0.08) !important; transform: scale(1.0); animation: trigger-pulse 2s ease-in-out infinite; }
        @keyframes trigger-pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(251,191,36,0); } 50% { box-shadow: 0 0 12px 3px rgba(251,191,36,0.25); } }
        .unified-card.is-triggered .u-index { background: rgba(251,191,36,0.18) !important; border-color: rgba(251,191,36,0.6) !important; color: var(--warning) !important; }
        .unified-card.flash-gold-card { animation: gold-flash-anim 1.5s infinite ease-in-out; border-color: var(--warning); background: rgba(245, 158, 11, 0.1); opacity: 1 !important; } 
        .order-status-badge { position: absolute; top: 4px; left: 48px; padding: 2px 6px; border-radius: 8px; font-size: 7px; font-weight: 800; font-family: var(--font-head); letter-spacing: 0.3px; text-transform: uppercase; z-index: 10; }
        .order-status-badge.selected { background: rgba(59, 130, 246, 0.2); color: var(--brand); border: 1px solid var(--brand); }
        .order-status-badge.pending { background: rgba(245, 158, 11, 0.2); color: var(--warning); border: 1px solid var(--warning); animation: pulse-ring 1.5s infinite; }
        .order-status-badge.sent { background: rgba(245, 158, 11, 0.25); color: var(--warning); border: 1px solid var(--warning); }
        .order-status-badge.filled { background: rgba(16, 185, 129, 0.2); color: var(--long); border: 1px solid var(--long); }
        .order-status-badge.error { background: rgba(239, 68, 68, 0.2); color: var(--short); border: 1px solid var(--short); }
        .order-status-badge.available { background: rgba(59, 130, 246, 0.2); color: var(--brand); border: 1px solid var(--brand); }
        .unified-card.pressing { 
            transform: scale(0.97) !important; 
            background: rgba(59, 130, 246, 0.15) !important; 
            border-color: var(--brand) !important;
            transition: all 0.1s ease;
        }
        .unified-card.pressing::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--brand);
            animation: press-progress 1.2s linear;
        }
        @keyframes press-progress {
            from { width: 0%; }
            to { width: 100%; }
        }
        .u-index { width: 42px; height: 42px; border-radius: 50%; background: rgba(59, 130, 246, 0.1); border: 2px solid var(--border); display: flex; align-items: center; justify-content: center; font-family: var(--font-head); font-weight: 900; color: var(--text-tertiary); font-size: 15px; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin: 0 auto; transition: all 0.3s; }
        .unified-card.is-filled .u-index { background: var(--long); color: #fff; border-color: var(--long); box-shadow: 0 0 10px rgba(16, 185, 129, 0.4); }
        .unified-card.is-filled-extra .u-index { background: var(--warning); color: #fff; border-color: var(--warning); box-shadow: 0 0 10px rgba(245, 158, 11, 0.4); }
        .unified-card.is-pending .u-index { background: rgba(245, 158, 11, 0.2); color: var(--warning); border-color: var(--warning); box-shadow: 0 0 10px rgba(245, 158, 11, 0.2); animation: pulse-ring 2s infinite; }
        .unified-card.is-sent .u-index { background: rgba(245, 158, 11, 0.15); color: var(--warning); border-color: var(--warning); }
        .u-center { display: flex; flex-direction: column; justify-content: center; overflow: hidden; gap: 6px; }
        .u-title { font-family: var(--font-num); font-size: 22px; font-weight: 800; color: var(--text-primary); line-height: 1; margin-bottom: 2px; }
        .u-sub { font-size: 11px; font-weight: 600; color: var(--text-tertiary); margin-top: 2px; text-transform: uppercase; }
        .u-right { text-align: right; display: flex; flex-direction: column; justify-content: center; gap: 4px; flex-shrink: 0; position: relative; }
        .multi-buy-indicator { position: absolute; top: -8px; right: -8px; background: var(--brand); color: #fff; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 900; font-family: var(--font-head); box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5); z-index: 10; }
        .u-val-accumulated { font-family: var(--font-num); font-size: 11px; font-weight: 700; color: var(--long); margin-top: 2px; }
        .mb-live-strip { position:absolute; bottom:0; left:0; right:0; height:24px; border-radius:0 0 14px 14px; background:rgba(0,0,0,0.16); display:flex; align-items:center; justify-content:center; overflow:hidden; pointer-events:none; }
        .mb-live-reel { display:flex; flex-direction:column; height:24px; overflow:hidden; align-items:center; }
        .mb-live-item { height:24px; display:flex; align-items:center; gap:4px; white-space:nowrap; flex-shrink:0; }
        .mb-live-dot { width:5px; height:5px; border-radius:50%; flex-shrink:0; }
        .mb-live-label { font-family:var(--font-head); font-size:8px; font-weight:700; letter-spacing:0.5px; color:var(--text-secondary); }
        .mb-live-val { font-family:var(--font-num); font-size:9px; font-weight:800; }
        .mb-live-val.positive { color:var(--long); } .mb-live-val.neutral { color:var(--brand); } .mb-live-val.saving { color:var(--warning); }
        @keyframes mb-reel-scroll { 0%,28%{transform:translateY(0)} 33%,61%{transform:translateY(-24px)} 66%,94%{transform:translateY(-48px)} 99%,100%{transform:translateY(0)} }
        .mb-live-reel.animating { animation:mb-reel-scroll 6s ease-in-out infinite; }
        [data-multi-live] { position:relative; padding-bottom:26px !important; }
        .u-val-primary { font-family: var(--font-num); font-size: 15px; font-weight: 800; }
        .etf-score-display { font-family: var(--font-num); font-weight: 900; font-size: 20px; color: var(--warning); display:flex; align-items:center; justify-content:flex-end; gap:4px; }
        .etf-search-box { position: relative; margin: 0px 10px 2px 10px; } 
        .etf-search-input { width: 100%; background: var(--card-bg); border: 1px solid var(--border); padding: 14px 14px 14px 45px; border-radius: var(--radius-m); color: var(--text-primary); font-family: var(--font-head); font-weight: 700; font-size: 14px; transition: border 0.3s; }
        .etf-search-input:focus { border-color: var(--brand); }
        .etf-search-icon { position: absolute; left: 16px; top: 50%; transform: translateY(-50%); color: var(--text-tertiary); }
        .etf-change-badge { padding: 4px 8px; border-radius: 6px; font-size: 13px; font-weight: 800; font-family: var(--font-num); }
        .etf-up { background: rgba(14, 203, 129, 0.18); color: var(--long); }
        .etf-down { background: rgba(246, 70, 93, 0.18); color: var(--short); }
        /* ══ ETF MEJORADO — TABS DETALLE RECOVERY ══ */
        .etf-tabs{display:flex;gap:4px;margin:6px 10px 4px;background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:4px}
        .etf-tab{flex:1;padding:7px 4px;border-radius:10px;border:none;background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;font-weight:800;letter-spacing:.8px;cursor:pointer;transition:all .2s;text-align:center}
        .etf-tab.active{background:var(--brand);color:#fff;box-shadow:0 2px 8px rgba(59,130,246,.35)}
        .etf-tab-content{display:none}.etf-tab-content.active{display:block}
        .etf-market-bar{display:flex;gap:6px;padding:4px 10px 6px;overflow-x:auto;scrollbar-width:none}
        .etf-market-bar::-webkit-scrollbar{display:none}
        .etf-mkt-pill{flex-shrink:0;display:flex;align-items:center;gap:5px;background:var(--surface);border:1px solid var(--border);border-radius:20px;padding:4px 10px;font-family:var(--font-head);font-size:9px;font-weight:700;color:var(--text-secondary);letter-spacing:.5px;white-space:nowrap}
        .etf-mkt-pill.up{border-color:rgba(16,185,129,.4);color:var(--long);background:rgba(16,185,129,.06)}
        .etf-mkt-pill.down{border-color:rgba(239,68,68,.4);color:var(--short);background:rgba(239,68,68,.06)}
        .etf-mkt-pill.warn{border-color:rgba(245,158,11,.4);color:var(--warning);background:rgba(245,158,11,.06)}
        .etf-heatmap-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;padding:10px}
        .etf-hm-cell{border-radius:14px;padding:14px 6px 12px;text-align:center;display:flex;flex-direction:column;gap:5px;cursor:pointer;transition:transform .15s;position:relative;overflow:hidden;border:1px solid transparent;min-height:88px;justify-content:center}
        .etf-hm-cell:active{transform:scale(.94)}
        .etf-hm-cell.zone-gold{background:rgba(245,158,11,.18);border-color:rgba(245,158,11,.5);animation:gold-flash-anim 2s infinite}
        .etf-hm-cell.zone-hot{background:rgba(251,146,60,.15);border-color:rgba(251,146,60,.4)}
        .etf-hm-cell.zone-warm{background:rgba(148,163,184,.1);border-color:var(--border)}
        .etf-hm-cell.zone-cool{background:var(--surface);border-color:var(--border);opacity:.7}
        .etf-hm-cell.zone-up{background:rgba(16,185,129,.12);border-color:rgba(16,185,129,.35)}
        .etf-hm-sym{font-family:var(--font-head);font-size:14px;font-weight:900;letter-spacing:.3px;line-height:1}
        .etf-hm-chg{font-family:var(--font-num);font-size:15px;font-weight:800}
        .etf-hm-lev{position:absolute;top:5px;right:7px;font-size:10px;font-family:var(--font-head);font-weight:900;color:var(--text-tertiary)}
        .etf-pos-card{background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:12px 14px;margin:4px 10px;transition:border-color .3s}
        .etf-pos-card.recovering{border-color:rgba(245,158,11,.5);background:rgba(245,158,11,.04)}
        .etf-pos-card.profit{border-color:rgba(16,185,129,.5);background:rgba(16,185,129,.04)}
        .etf-pos-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
        .etf-pos-name{font-family:var(--font-head);font-size:20px;font-weight:900;line-height:1}
        .etf-pos-slot{font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);letter-spacing:1px}
        .etf-pos-pnl{font-family:var(--font-num);font-size:18px;font-weight:900}
        .etf-pos-pnl.pos{color:var(--long)}.etf-pos-pnl.neg{color:var(--short)}
        .etf-pos-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-top:8px}
        .etf-pos-stat-label{font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);letter-spacing:.8px;display:block;margin-bottom:2px}
        .etf-pos-stat-val{font-family:var(--font-num);font-size:13px;font-weight:800;color:var(--text-primary)}
        .etf-recovery-bar{margin-top:10px}
        .etf-recovery-label{display:flex;justify-content:space-between;font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);margin-bottom:4px}
        .etf-recovery-track{height:5px;background:var(--border);border-radius:3px;overflow:hidden}
        .etf-recovery-fill{height:100%;border-radius:3px;transition:width .5s ease}
        .etf-recovery-fill.profit{background:var(--long)}.etf-recovery-fill.partial{background:var(--warning)}.etf-recovery-fill.loss{background:var(--short)}
        .etf-decay-badge{display:inline-flex;align-items:center;gap:4px;padding:3px 8px;border-radius:8px;font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;margin-top:6px}
        .etf-decay-badge.high{background:rgba(239,68,68,.12);color:var(--short);border:1px solid rgba(239,68,68,.25)}
        .etf-decay-badge.medium{background:rgba(245,158,11,.12);color:var(--warning);border:1px solid rgba(245,158,11,.25)}
        .etf-decay-badge.low{background:rgba(16,185,129,.12);color:var(--long);border:1px solid rgba(16,185,129,.25)}
        #etfDetailModal{position:fixed;inset:0;z-index:9990;background:rgba(0,0,0,0);pointer-events:none;transition:background .3s}
        #etfDetailModal.open{background:rgba(0,0,0,.6);pointer-events:all;backdrop-filter:blur(4px)}
        .etf-detail-sheet{position:absolute;bottom:0;left:0;right:0;max-height:90vh;background:var(--surface);border-radius:24px 24px 0 0;padding:0 0 calc(20px + var(--safe-bottom));transform:translateY(100%);transition:transform .4s cubic-bezier(.4,0,.2,1);overflow-y:auto;border-top:1px solid var(--border)}
        #etfDetailModal.open .etf-detail-sheet{transform:translateY(0)}
        .etf-detail-handle{width:40px;height:4px;background:var(--border-strong);border-radius:2px;margin:12px auto 4px}
        .etf-detail-header{padding:12px 18px 10px;display:flex;align-items:center;justify-content:space-between}
        .etf-detail-sym{font-family:var(--font-head);font-size:28px;font-weight:900}
        .etf-detail-price-val{font-family:var(--font-num);font-size:20px;font-weight:800;color:var(--text-primary);display:block}
        .etf-detail-change{font-family:var(--font-num);font-size:13px;font-weight:700;padding:2px 8px;border-radius:6px;display:inline-block;margin-top:2px}
        .etf-detail-sections{padding:0 14px 10px;display:flex;flex-direction:column;gap:10px}
        .etf-detail-section{background:var(--bg);border:1px solid var(--border);border-radius:16px;padding:12px 14px}
        .etf-detail-section-title{font-family:var(--font-head);font-size:9px;font-weight:800;color:var(--text-tertiary);letter-spacing:1.5px;text-transform:uppercase;margin-bottom:10px}
        .etf-detail-kv-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
        .etf-detail-key{font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);letter-spacing:.8px;display:block;margin-bottom:2px}
        .etf-detail-val{font-family:var(--font-num);font-size:14px;font-weight:800;color:var(--text-primary)}
        .etf-detail-val.up{color:var(--long)}.etf-detail-val.down{color:var(--short)}.etf-detail-val.warn{color:var(--warning)}
        .etf-opp-track{height:8px;background:var(--border);border-radius:4px;overflow:hidden;margin:8px 0 4px}
        .etf-opp-fill{height:100%;border-radius:4px;transition:width .6s cubic-bezier(.4,0,.2,1)}
        .etf-opp-labels{display:flex;justify-content:space-between;font-family:var(--font-head);font-size:8px;color:var(--text-tertiary)}
        .etf-entry-zones{display:flex;flex-direction:column;gap:6px}
        .etf-entry-zone{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-radius:10px}
        .etf-entry-zone.z1{background:rgba(16,185,129,.1);border:1px solid rgba(16,185,129,.3)}
        .etf-entry-zone.z2{background:rgba(245,158,11,.08);border:1px solid rgba(245,158,11,.25)}
        .etf-entry-zone.z3{background:rgba(239,68,68,.08);border:1px solid rgba(239,68,68,.2)}
        .etf-zone-label{font-family:var(--font-head);font-size:9px;font-weight:800;letter-spacing:.5px}
        .etf-zone-price{font-family:var(--font-num);font-size:14px;font-weight:800}
        .etf-zone-pct{font-family:var(--font-num);font-size:10px;color:var(--text-tertiary)}
        .etf-detail-actions{display:grid;grid-template-columns:1fr 1fr;gap:8px;padding:4px 14px 10px}
        .etf-action-btn{padding:14px;border-radius:14px;border:1px solid var(--border);background:var(--bg);color:var(--text-primary);font-family:var(--font-head);font-size:11px;font-weight:800;letter-spacing:.5px;cursor:pointer;transition:all .2s;text-align:center}
        .etf-action-btn:active{transform:scale(.96)}
        .etf-action-btn.primary{background:var(--brand);border-color:var(--brand);color:#fff;box-shadow:0 4px 15px rgba(59,130,246,.3)}
        .etf-action-btn.success{background:var(--long);border-color:var(--long);color:#fff;box-shadow:0 4px 15px rgba(16,185,129,.3)}
        .dash-recovery-row{display:flex;align-items:center;gap:6px;padding:4px 8px;background:var(--bg);border-radius:8px;margin-top:4px;border:1px solid var(--border)}
        .dash-rec-label{font-family:var(--font-head);font-size:7px;font-weight:800;color:var(--text-tertiary);letter-spacing:.8px;flex-shrink:0}
        .dash-rec-track{flex:1;height:4px;background:var(--border);border-radius:2px;overflow:hidden}
        .dash-rec-fill{height:100%;border-radius:2px;transition:width .4s ease;background:var(--brand)}
        .dash-rec-pct{font-family:var(--font-num);font-size:10px;font-weight:800;color:var(--text-primary);flex-shrink:0;min-width:38px;text-align:right}
        .sb-status-row{display:flex;align-items:center;gap:8px;padding:8px 12px;background:var(--bg);border:1px solid var(--border);border-radius:12px;margin-bottom:8px}
        .sb-dot{width:8px;height:8px;border-radius:50%;background:var(--text-tertiary);flex-shrink:0;transition:background .3s}
        .sb-dot.connected{background:var(--long);box-shadow:0 0 8px var(--long);animation:pulse-ring 2s infinite}
        .sb-dot.error{background:var(--short)}
        .sb-status-text{font-family:var(--font-head);font-size:10px;font-weight:700;color:var(--text-secondary);flex:1;letter-spacing:.5px}
        .sb-status-tag{font-family:var(--font-head);font-size:8px;font-weight:900;padding:2px 7px;border-radius:6px;background:rgba(16,185,129,.15);color:var(--long)}
        .sb-status-tag.offline{background:rgba(107,114,128,.15);color:var(--text-tertiary)}
        .etf-compare-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;padding:6px 10px}
        .etf-cmp-card{background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:10px 12px;cursor:pointer;transition:all .2s}
        .etf-cmp-card:active{transform:scale(.97)}
        .etf-cmp-lev{font-family:var(--font-head);font-size:9px;font-weight:900;letter-spacing:1px;color:var(--brand);margin-bottom:4px}
        .etf-cmp-sym{font-family:var(--font-head);font-size:16px;font-weight:900;line-height:1.1}
        .etf-cmp-price{font-family:var(--font-num);font-size:12px;font-weight:700;color:var(--text-secondary);margin-top:3px}
        .etf-cmp-chg{font-family:var(--font-num);font-size:14px;font-weight:900;margin-top:4px}
        .etf-cmp-chg.up{color:var(--long)}.etf-cmp-chg.down{color:var(--short)}
        .etf-cmp-badge{display:inline-block;padding:2px 6px;border-radius:5px;font-size:8px;font-weight:900;font-family:var(--font-head);margin-top:5px}
        .etf-cmp-badge.best{background:rgba(16,185,129,.2);color:var(--long)}
        .etf-quick-buy{padding:5px 10px;border-radius:8px;background:rgba(16,185,129,.12);border:1px solid rgba(16,185,129,.35);color:var(--long);font-family:var(--font-head);font-size:8px;font-weight:900;letter-spacing:.5px;cursor:pointer;transition:all .2s;white-space:nowrap;margin-top:4px}
        .etf-quick-buy:active{background:rgba(16,185,129,.25);transform:scale(.95)}
        .etf-divergence{font-family:var(--font-head);font-size:8px;font-weight:700;padding:2px 6px;border-radius:5px;white-space:nowrap}
        .etf-divergence.high{color:var(--warning);background:rgba(245,158,11,.12)}
        .etf-divergence.extreme{color:var(--short);background:rgba(239,68,68,.12);animation:pulse-ring 2s infinite}
        /* ── ETF Monitor Card ── */
        .etf-mc{background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius-m);padding:12px 14px;display:flex!important;flex-direction:column!important;gap:0!important;height:auto!important;min-height:unset!important;max-height:none!important;cursor:pointer;transition:transform .1s ease,background .2s,border-color .3s,opacity .3s;position:relative;overflow:hidden;opacity:.9;touch-action:pan-y!important;user-select:none;-webkit-user-select:none;}
        .etf-mc:active{transform:scale(.98);}
        .etf-mc.flash-gold-card{animation:gold-flash-anim 1.5s infinite ease-in-out;border-color:var(--warning);background:rgba(245,158,11,.1);opacity:1!important;}
        .etf-mc-row1{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;}
        .etf-mc-row2{display:flex;align-items:flex-end;justify-content:space-between;margin-bottom:6px;}
        .etf-mc-row3{display:none;}
        .etf-mc-inforow{display:flex;align-items:center;justify-content:space-between;gap:5px;min-width:0;}
        .etf-mc-inforow-left{display:flex;align-items:center;gap:5px;flex:1;min-width:0;flex-wrap:nowrap;overflow:hidden;}
        .etf-mc-inforow-right{display:flex;align-items:center;gap:4px;flex-shrink:0;}
        .etf-mc-name{font-family:var(--font-num);font-size:19px;font-weight:900;line-height:1;letter-spacing:-.5px;}
        .etf-mc-lev{padding:2px 7px;border-radius:6px;font-family:var(--font-head);font-size:8px;font-weight:900;letter-spacing:.5px;}
        .etf-mc-slot-tag{padding:2px 6px;border-radius:5px;background:rgba(59,130,246,.12);border:1px solid rgba(59,130,246,.3);color:var(--brand);font-family:var(--font-head);font-size:7px;font-weight:900;letter-spacing:.5px;}
        .etf-mc-chg{padding:5px 10px;border-radius:8px;font-family:var(--font-num);font-size:15px;font-weight:800;flex-shrink:0;min-width:76px;text-align:center;}
        .etf-mc-price{font-family:'JetBrains Mono',monospace;font-size:14px;font-weight:700;color:var(--text-primary);}
        .etf-mc-meta{font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);font-weight:600;}
        .etf-mc-score-wrap{text-align:right;flex-shrink:0;}
        .etf-mc-score-lbl{font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;line-height:1;}
        .etf-mc-score-val{font-family:var(--font-num);font-size:17px;font-weight:900;line-height:1;}
        .etf-empty-pos{text-align:center;padding:40px 20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:10px;font-weight:700;letter-spacing:.5px;line-height:2}
        .etf-hm-cell.hm-in-slot{border:1.5px solid var(--brand);box-shadow:0 0 8px rgba(59,130,246,.3)}
        /* DCA Zone press effect */
        .dca-selectable:active { transform: scale(0.97) !important; opacity: 0.85 !important; }
        .dca-selectable { transition: transform .15s, opacity .15s, box-shadow .15s; }
        .dca-selectable:hover { box-shadow: 0 4px 20px rgba(59,130,246,.15); }


        /* ══ FAQ ══ */
        .faq-item{background:var(--surface);border:1px solid var(--border);border-radius:12px;overflow:hidden;cursor:pointer;transition:border-color .2s}
        .faq-item:active{opacity:.85}
        .faq-q{padding:12px 14px;font-family:var(--font-head);font-size:10px;font-weight:800;color:var(--text-primary);display:flex;justify-content:space-between;align-items:center;gap:8px;line-height:1.5}
        .faq-arrow{font-size:14px;color:var(--text-tertiary);flex-shrink:0;transition:transform .2s}
        .faq-item.open .faq-arrow{transform:rotate(180deg)}
        .faq-a{display:none;padding:0 14px 12px;font-family:var(--font-head);font-size:9px;color:var(--text-secondary);line-height:1.9;border-top:1px solid var(--border)}
        .faq-item.open .faq-a{display:block}
        /* ══ SUPPORT CHAT ══ */
        .support-msg{padding:8px 12px;border-radius:12px;font-family:var(--font-head);font-size:10px;line-height:1.6;max-width:85%}
        .support-msg.mine{background:rgba(59,130,246,.15);border:1px solid rgba(59,130,246,.3);align-self:flex-end;color:var(--text-primary)}
        .support-msg.admin{background:var(--surface);border:1px solid var(--border);align-self:flex-start;color:var(--text-primary)}
        .support-msg-time{font-size:7px;color:var(--text-tertiary);margin-top:3px;font-family:var(--font-num)}
        /* ── Promedio acumulado por nivel (modo AUTO) ── */
        .level-avg-badge{margin:5px 6px 0;padding:5px 9px;background:rgba(59,130,246,0.09);border:1px solid rgba(59,130,246,0.25);border-radius:8px;font-family:var(--font-head);font-size:8px;font-weight:800;color:var(--brand);letter-spacing:0.4px;line-height:1.6;display:flex;justify-content:space-between;align-items:center;gap:8px;}
        .level-avg-badge .lab-prom{color:var(--brand);}
        .level-avg-badge .lab-target{color:var(--long);}
        /* Indicador TP1 Recalc en pill del bot */
        .tp1-recalc-badge{display:inline-block;padding:2px 6px;background:rgba(245,158,11,0.15);border:1px solid rgba(245,158,11,0.4);border-radius:6px;font-family:var(--font-head);font-size:7px;font-weight:800;color:var(--warning);letter-spacing:0.5px;margin-left:4px;}
        /* Botón adjuntar archivo en soporte */
        .chat-attach-btn{width:40px;height:40px;border-radius:50%;background:var(--surface);border:1px solid var(--border);color:var(--text-secondary);display:flex;align-items:center;justify-content:center;cursor:pointer;flex-shrink:0;transition:all 0.2s;font-size:16px;}
        .chat-attach-btn:hover{border-color:var(--brand);color:var(--brand);}
        .chat-attach-btn:active{transform:scale(0.9);}
        /* Mensaje tipo archivo en soporte */
        .support-msg-file{display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;max-width:85%;background:rgba(59,130,246,0.08);border:1px solid rgba(59,130,246,0.2);}
        .support-msg-file-icon{font-size:20px;flex-shrink:0;}
        .support-msg-file-info{flex:1;min-width:0;}
        .support-msg-file-name{font-family:var(--font-head);font-size:9px;font-weight:800;color:var(--text-primary);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .support-msg-file-size{font-family:var(--font-num);font-size:8px;color:var(--text-tertiary);}
        .support-msg-file-link{font-family:var(--font-head);font-size:8px;color:var(--brand);text-decoration:none;font-weight:800;}
        /* Preview imagen en soporte */
        .support-msg-img{max-width:200px;border-radius:10px;border:1px solid var(--border);margin-top:4px;cursor:pointer;}


        /* ══ MODAL VENTA MEJORADO ══ */
        .sell-tab{flex:1;padding:7px 4px;border-radius:8px;border:none;background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;font-weight:800;letter-spacing:.8px;cursor:pointer;transition:all .2s;text-align:center}
        .sell-tab.active{background:var(--brand);color:#fff}
        .sell-panel{display:none}.sell-panel.active{display:block}
        .sell-opt-btn{width:100%;padding:12px 14px;border-radius:12px;border:1px solid var(--border);background:var(--surface);color:var(--text-primary);font-family:var(--font-head);font-size:12px;font-weight:800;cursor:pointer;transition:all .2s;text-align:left}
        .sell-opt-btn:active{transform:scale(.97)}
        .sell-now{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.4);color:var(--short)}
        .sell-tp{background:rgba(16,185,129,.1);border-color:rgba(16,185,129,.35);color:var(--long);text-align:center}
        .multi-tp-row{display:grid;grid-template-columns:auto 1fr 1fr auto;gap:8px;align-items:center;padding:8px 10px;background:var(--bg);border-radius:10px;border:1px solid var(--border)}
        .multi-tp-label{font-family:var(--font-head);font-size:9px;font-weight:900;padding:4px 8px;border-radius:6px;white-space:nowrap}
        .multi-tp-label.tp1{background:rgba(16,185,129,.2);color:var(--long)}
        .multi-tp-label.tp2{background:rgba(245,158,11,.2);color:var(--warning)}
        .multi-tp-label.tp3{background:rgba(239,68,68,.2);color:var(--short)}
        .multi-tp-input{background:var(--surface);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-family:var(--font-num);font-size:15px;font-weight:800;text-align:center;padding:5px;width:100%}
        /* ══ SHORT ETF PANEL ══ */
        .short-focus-bar{display:flex;align-items:center;gap:8px;padding:6px 10px;background:rgba(239,68,68,.06);border-bottom:1px solid rgba(239,68,68,.2);overflow-x:auto;scrollbar-width:none}
        .short-focus-bar::-webkit-scrollbar{display:none}
        .short-pill{flex-shrink:0;display:flex;flex-direction:column;align-items:center;gap:1px;padding:5px 10px;border-radius:12px;background:var(--surface);border:1px solid var(--border);cursor:pointer;transition:all .2s;min-width:70px}
        .short-pill:active{transform:scale(.95)}
        .short-pill.active{border-color:var(--short);background:rgba(239,68,68,.08)}
        .short-pill-sym{font-family:var(--font-head);font-size:10px;font-weight:900}
        .short-pill-chg{font-family:var(--font-num);font-size:12px;font-weight:800}
        .short-pill-spot{font-family:var(--font-num);font-size:8px;color:var(--text-tertiary)}
        /* ══ DIVERGENCIA ALERT ══ */
        .div-alert-card{display:flex;align-items:center;gap:10px;padding:10px 14px;background:rgba(239,68,68,.08);border:1px solid rgba(239,68,68,.3);border-radius:14px;margin:4px 10px;animation:gold-flash-anim 2s infinite}
        .div-alert-icon{font-size:18px;flex-shrink:0}
        .div-alert-body{flex:1}
        .div-alert-title{font-family:var(--font-head);font-size:10px;font-weight:900;color:var(--short)}
        .div-alert-sub{font-family:var(--font-num);font-size:11px;color:var(--text-secondary);margin-top:2px}
        .div-alert-btn{font-family:var(--font-head);font-size:8px;font-weight:900;padding:5px 10px;border-radius:8px;background:rgba(239,68,68,.15);border:1px solid rgba(239,68,68,.35);color:var(--short);cursor:pointer;white-space:nowrap;flex-shrink:0}
        /* ══ REBALANCE HISTORY ══ */
        .rebal-card{background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:10px 12px;margin:4px 10px}
        .rebal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
        .rebal-coin{font-family:var(--font-head);font-size:14px;font-weight:900}
        .rebal-date{font-family:var(--font-head);font-size:9px;color:var(--text-tertiary)}
        .rebal-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px}
        .rebal-stat-label{font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.8px;display:block;margin-bottom:2px}
        .rebal-stat-val{font-family:var(--font-num);font-size:12px;font-weight:800}
        .rebal-cost-badge{display:inline-flex;padding:2px 7px;border-radius:6px;font-family:var(--font-head);font-size:8px;font-weight:800;margin-top:6px}
        .rebal-cost-badge.low{background:rgba(16,185,129,.12);color:var(--long)}
        .rebal-cost-badge.medium{background:rgba(245,158,11,.12);color:var(--warning)}
        .rebal-cost-badge.high{background:rgba(239,68,68,.12);color:var(--short)}
        /* ══ MOMENTUM SCANNER ══ */
        .momentum-cell{display:flex;align-items:center;gap:8px;padding:8px 10px;background:var(--surface);border:1px solid var(--border);border-radius:12px;margin:3px 10px;cursor:pointer;transition:all .2s}
        .momentum-cell:active{transform:scale(.98)}
        .momentum-rank{font-family:var(--font-num);font-size:20px;font-weight:900;color:var(--text-tertiary);width:24px;flex-shrink:0}
        .momentum-info{flex:1}
        .momentum-sym{font-family:var(--font-head);font-size:14px;font-weight:900}
        .momentum-sub{font-family:var(--font-num);font-size:10px;color:var(--text-tertiary);margin-top:2px}
        .momentum-bar-wrap{width:80px;flex-shrink:0}
        .momentum-bar-track{height:6px;background:var(--border);border-radius:3px;overflow:hidden;margin-bottom:3px}
        .momentum-bar-fill{height:100%;border-radius:3px;transition:width .4s ease}
        .momentum-pct{font-family:var(--font-num);font-size:11px;font-weight:800;text-align:right}
        /* ══ TRAILING ACTIVE BADGE ══ */
        .trailing-active-badge{display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:8px;background:rgba(59,130,246,.12);border:1px solid rgba(59,130,246,.3);color:var(--brand);font-family:var(--font-head);font-size:9px;font-weight:800;animation:pulse-ring 2s infinite}


        .setting-section-title { padding: 5px 5px; font-family: var(--font-head); color: var(--text-secondary); font-weight: 900; letter-spacing: 1.5px; display:flex; align-items:center; gap:8px; margin-top: 0px; font-size: var(--fs-set-title); }
        .settings-grid { display: flex; flex-direction: column; gap: 8px; width: 100%; box-sizing: border-box; }
        .setting-card-item { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius-m); padding: 16px; display: flex; flex-direction: column; gap: 5px; transition: background 0.3s, border-color 0.3s; width: 100%; box-sizing: border-box; overflow: hidden; }
        .setting-label { font-size: var(--fs-set-label); color: var(--text-secondary); font-weight: 700; text-transform: uppercase; min-width: 0; flex-shrink: 1; overflow: hidden; text-overflow: ellipsis; }
        .setting-input { width: 100%; background: transparent; border: none; color: var(--text-primary); font-family: var(--font-num); font-size: var(--fs-set-input); font-weight: 700; }
        .input-row-save { display: flex; align-items: center; gap: 10px; width: 100%; overflow: hidden; }
        /* Etiquetas en filas flex deben ceder espacio a los botones */
        .input-row-save .setting-label,
        .input-row-save span { min-width: 0; flex-shrink: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .btn-save-mini { background: var(--brand); color: #fff; border: none; width: 44px; height: 44px; border-radius: 12px; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; }
        .data-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .btn-data { background: var(--surface); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 10px; font-size: 12px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .btn-reset { background: rgba(207, 48, 74, 0.1); color: var(--danger); border: 1px solid var(--danger); padding: 12px 20px; border-radius: 10px; font-weight: 900; width: 100%; margin-top: 10px; font-family: var(--font-head); cursor: pointer; display:flex; align-items:center; justify-content:center; gap:8px; }
        .chip-container { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
        .chip { background: rgba(59, 130, 246, 0.1); border: 1px solid var(--border); border-radius: 20px; padding: 6px 12px; font-size: 12px; font-weight: 700; display: flex; align-items: center; gap: 8px; color: var(--text-primary); }
        .chip-del { cursor: pointer; width: 16px; height: 16px; border-radius: 50%; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--text-secondary); }
        .multi-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 5px; }
        .multi-item { background: rgba(0,0,0,0.2); border: 1px solid var(--border); border-radius: 8px; padding: 5px; text-align: center; }
        .multi-item.filled { border-color: var(--brand); background: rgba(59, 130, 246, 0.1); }
        .multi-lbl { font-size: var(--fs-set-label); color: var(--text-tertiary); display: block; font-weight: 700; }
        .multi-inp { width: 100%; background: transparent; border: none; color: var(--brand); font-family: var(--font-num); font-weight: 800; font-size: var(--fs-set-input); text-align: center; }
        #navModal { position: fixed; inset: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 2000; display: none; justify-content: center; align-items: center; padding-top: var(--safe-top); }
        .nav-content { background: var(--surface); width: 85%; max-width: 320px; border-radius: 30px; padding: 35px 25px; border: 1px solid var(--border); box-shadow: 0 30px 60px rgba(0,0,0,0.6); display: flex; flex-direction: column; gap: 15px; }
        .nav-title { font-family: var(--font-head); font-size: 18px; margin-bottom: 10px; color: var(--brand); text-align: center; font-weight: 900; letter-spacing: 2px; }
        .nav-item { display: flex; align-items: center; padding: 20px; border-radius: 18px; background: rgba(255,255,255,0.02); border: 1px solid var(--border); cursor: pointer; transition: 0.3s; }
        .nav-item.selected { background: rgba(59, 130, 246, 0.1); border-color: var(--brand); box-shadow: 0 5px 20px rgba(59, 130, 246, 0.15); }
        .nav-icon { width: 40px; height: 40px; margin-right: 20px; display: flex; align-items: center; justify-content: center; color: var(--text-secondary); }
        .nav-item.selected .nav-icon { color: var(--brand); }
        .nav-text { font-family: var(--font-head); font-weight: 700; font-size: 14px; letter-spacing: 1px; color: var(--text-primary); }
        .btn-close-menu { margin-top: 10px; width: 100%; padding: 16px; border-radius: 16px; border: 1px solid var(--border); background: var(--surface); color: var(--danger); font-family: var(--font-head); font-weight: 900; font-size: 13px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .generic-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 3000; display: none; justify-content: center; align-items: center; }
        .modal-box { background: var(--surface); width: 85%; max-width: 300px; padding: 25px; border-radius: 20px; border: 1px solid var(--border); text-align: center; }
        .btn-modal { width: 100%; padding: 12px; border-radius: 10px; border: none; font-weight: 700; margin-bottom: 8px; cursor: pointer; }
        .btn-confirm { background: var(--brand); color: #fff; }
        .btn-cancel { background: transparent; color: var(--text-secondary); }
        .modal-inp { width: 100%; background: var(--bg); border: 1px solid var(--border); padding: 12px; border-radius: 10px; color: var(--text-primary); font-size: 24px; letter-spacing: 5px; text-align: center; margin: 20px 0; font-family: var(--font-num); monospace; }
        .action-btn { background: var(--surface); border: 1px solid var(--brand); color: var(--brand); padding: 6px 12px; border-radius: 8px; font-size: 11px; font-weight: 800; cursor: pointer; font-family: var(--font-head); display: flex; align-items: center; gap: 5px; }
        .log-header-bar { display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 4px 16px 8px 16px; }
        .log-title { margin-bottom: 0px; font-family: var(--font-head); font-weight: 900; letter-spacing: 1px; color:var(--brand); }
        .log-actions { display: flex; gap: 15px; width: 100%; justify-content: center; }
        .stats-card { background: var(--surface); border: 1px solid var(--border); border-radius: 16px; margin: 0 10px 15px; padding: 15px; }
        .stats-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .stats-title { font-family: var(--font-head); font-size: 12px; font-weight: 900; color: var(--brand); letter-spacing: 1px; }
        .stats-toggles { display: flex; gap: 5px; background: rgba(0,0,0,0.2); padding: 3px; border-radius: 8px; border: 1px solid var(--border); }
        .stat-btn { background: transparent; border: none; color: var(--text-tertiary); font-size: 10px; font-weight: 800; padding: 4px 10px; border-radius: 6px; cursor: pointer; transition: all 0.2s; }
        .stat-btn.active { background: var(--brand); color: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .chart-box { height: 160px; display: flex; align-items: flex-end; justify-content: space-between; gap: 4px; padding-bottom: 5px; border-bottom: 1px solid var(--border); margin-bottom: 10px; position: relative; }
        .chart-bar { flex: 1; min-width: 4px; border-radius: 2px 2px 0 0; position: relative; transition: height 0.5s ease; animation: grow-up 0.5s ease-out; }
        .chart-bar.win { background: linear-gradient(to top, rgba(16,203,129,0.3), var(--long)); }
        .chart-bar.loss { background: linear-gradient(to top, rgba(246,70,93,0.3), var(--short)); }
        .chart-bar:hover { opacity: 0.8; }
        .chart-bar::after { content: attr(data-val); position: absolute; top: -15px; left: 50%; transform: translateX(-50%); font-size: 9px; font-family: var(--font-num); color: var(--text-primary); opacity: 0; transition: 0.2s; pointer-events: none; white-space: nowrap; }
        .chart-bar:hover::after { opacity: 1; top: -20px; }
        .stats-summary { display: flex; justify-content: space-between; align-items: center; font-size: 12px; }
        .sum-label { color: var(--text-tertiary); font-weight: 700; margin-right: 5px; }
        .sum-val { font-family: var(--font-num); font-weight: 800; color: var(--text-primary); }
        #logGrid { max-height: 395px; overflow-y: auto; overscroll-behavior: contain; border-bottom: 1px solid var(--border); margin-bottom: 20px; padding-right: 2px; }
        #logGrid::-webkit-scrollbar { width: 4px; }
        #logGrid::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
        .modal-info-text { font-size: 12px; color: var(--text-secondary); margin-bottom: 15px; }
        .trade-details { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 15px; font-family: var(--font-num); font-size: 13px; text-align: left; }
        .gate-connection-indicator { display: inline-flex; align-items: center; gap: 5px; padding: 3px 8px; border-radius: 10px; font-size: 9px; font-weight: 700; letter-spacing: 0.3px; border: 1px solid; transition: all 0.3s ease; }
        .gate-connection-indicator.connected { background: rgba(16, 185, 129, 0.12); border-color: rgba(16, 185, 129, 0.4); color: var(--long); }
        .gate-connection-indicator.disconnected { background: rgba(245, 158, 11, 0.12); border-color: rgba(245, 158, 11, 0.4); color: var(--warning); }
        .gate-status-dot { width: 5px; height: 5px; border-radius: 50%; background: currentColor; }
        .gate-connection-indicator.connected .gate-status-dot { animation: pulse-dot 2s ease-in-out infinite; }
        @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        
        /* SISTEMA DE RADAR MEJORADO - LIMPIO */
        .radar-zone-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 800;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: inline-block;
        }
        
        .radar-zone-badge.gold {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #000;
            animation: pulse-gold 2s infinite;
        }
        
        .radar-zone-badge.hot {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: #fff;
        }
        
        .radar-zone-badge.warm {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: #fff;
        }
        
        @keyframes pulse-gold {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 4px 16px rgba(255, 215, 0, 0.8);
            }
        }
        
        
        .radar-ticker-large {
            position: relative;
            overflow: visible;
        }
        
        /* ═══════════════════════════════════════════════
           PANEL NAV INDICATORS — Mobile visible
        ═══════════════════════════════════════════════ */
        .panel-nav-dots {
            display: none !important;
        }
        .pnd { width: 6px; height: 6px; border-radius: 50%; background: var(--border-strong); transition: all 0.25s cubic-bezier(0.32,0.72,0,1); }
        .pnd.active { background: var(--brand); width: 16px; border-radius: 3px; }
        
        /* ═══════════════════════════════════════════════
           PANEL ARROW BUTTONS — Tablet+ visible
        ═══════════════════════════════════════════════ */
        .panel-arrow {
            display: none;
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 36px; height: 36px;
            border-radius: 50%;
            background: var(--surface);
            border: 1px solid var(--border-strong);
            color: var(--text-secondary);
            align-items: center; justify-content: center;
            cursor: pointer;
            z-index: 500;
            transition: all 0.18s ease;
            box-shadow: 0 2px 12px rgba(0,0,0,0.3);
        }
        .panel-arrow:hover { background: var(--border); color: var(--text-primary); transform: translateY(-50%) scale(1.08); }
        .panel-arrow:active { transform: translateY(-50%) scale(0.94); }
        .panel-arrow.left  { left: 8px; }
        .panel-arrow.right { right: 8px; }
        .panel-arrow.hidden { opacity: 0; pointer-events: none; }

        #desktop-etf-list { display: none; }
        #layout-container { display: flex; flex-direction: column; width: 100%; gap: 2px; }
        .cols-container { display: contents; }
        .left-col, .right-col { display: contents; }
        
        #tv_chart { order: 1; margin-bottom: 2px !important; }
        #controlsGrid { order: 2; margin-bottom: 2px !important; }
        #radarTickerContainer { order: 3; margin-bottom: 2px !important; }
        #etfMonitorToggleBtn { order: 4; margin-bottom: 2px !important; }
        #dashMain { order: 5; margin-bottom: 2px !important; }
        #levelsGrid { order: 6; }
        /* Panel 3 — asegurar que el nivel 12 sea completamente visible al hacer scroll */
        #panel5 .panel-content { padding-bottom: 0 !important; }
        #panel5 #levelsGrid { padding-bottom: calc(80px + var(--safe-bottom, 20px)) !important; max-height: none !important; overflow-y: auto !important; }

        /* ── BOTÓN ATRÁS PANEL 3 (niveles) ── */
        /* ── BOTÓN BACK LEGADO — oculto, reemplazado por p3-header-bar ── */
        .levels-back-btn { display: none !important; }

        /* ══ PANEL 3 — BARRA COMPACTA UNIFORME (activo | modo | PNL) ══ */
        /* fuente compartida para labels y valores */
        .p3-lbl { font-family:var(--font-head); font-size:7.5px; font-weight:800; color:var(--text-tertiary); letter-spacing:1px; text-transform:uppercase; line-height:1; }
        .p3-val { font-family:'JetBrains Mono',monospace; font-size:12px; font-weight:800; line-height:1.2; white-space:nowrap; }
        /* ══ PANEL 3 HEADER BAR — 3D TICKET STYLE ══ */
        .p3-header-bar {
            display: flex; align-items: center; justify-content: space-between;
            gap: 6px; padding: 7px 10px;
            /* 3D ticket: gradient + multi-shadow depth */
            background: linear-gradient(180deg,
                rgba(255,255,255,0.07) 0%,
                var(--surface) 18%,
                rgba(0,0,0,0.18) 100%);
            border: 1px solid var(--border-strong, rgba(255,255,255,0.14));
            border-bottom-color: rgba(0,0,0,0.45);
            border-radius: 13px; margin: 4px 4px 5px;
            width: calc(100% - 8px); min-height: 46px; box-sizing: border-box;
            box-shadow:
                inset 0 1px 0 rgba(255,255,255,0.10),
                inset 0 -1px 0 rgba(0,0,0,0.30),
                0 2px 0 rgba(0,0,0,0.4),
                0 4px 10px rgba(0,0,0,0.35),
                0 8px 22px rgba(0,0,0,0.22);
            position: relative;
        }
        /* ticket perforation circles on sides */
        .p3-header-bar::before,
        .p3-header-bar::after {
            content: '';
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--bg); border: 1px solid var(--border);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
            z-index: 1;
        }
        .p3-header-bar::before { left: -5px; }
        .p3-header-bar::after  { right: -5px; }
        /* zona izquierda: activo */
        .p3-coin-zone { display:flex; flex-direction:column; align-items:flex-start; gap:2px; flex:1; min-width:0; }
        .p3-coin-name { color:var(--brand); overflow:hidden; text-overflow:ellipsis; }
        /* zona centro: modo — más ancho y horizontal */
        .p3-mode-btn {
            display:flex; flex-direction:column; align-items:center; justify-content:center; gap:2px;
            padding:6px 16px; border-radius:10px; border:1.5px solid var(--brand);
            background: linear-gradient(180deg, rgba(59,130,246,0.18) 0%, rgba(59,130,246,0.06) 100%);
            cursor:pointer; flex:0 0 auto;
            touch-action:none; transition:background .2s, border-color .2s;
            min-width: 120px;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), 0 2px 6px rgba(0,0,0,0.25);
        }
        .p3-mode-btn.auto-mode {
            background: linear-gradient(180deg, rgba(16,185,129,0.18) 0%, rgba(16,185,129,0.06) 100%);
            border-color:var(--long);
        }
        .p3-mode-row  { display:flex; align-items:center; gap:5px; }
        .p3-mode-text { font-family:'JetBrains Mono',monospace; font-size:11px; font-weight:800; color:var(--brand); line-height:1; letter-spacing:1px; }
        .p3-mode-btn.auto-mode .p3-mode-text { color:var(--long); }
        .p3-mode-sub  { font-family:var(--font-head); font-size:7px; color:var(--text-tertiary); letter-spacing:.8px; line-height:1; }
        .p3-mode-btn.auto-mode .p3-mode-sub { color:var(--long); }
        /* zona derecha: PNL — solo dólares */
        .p3-pnl-zone  { display:flex; flex-direction:column; align-items:flex-end; gap:2px; flex:1; min-width:0; }
        .p3-pnl-pct   { display:none !important; }
        .p3-pnl-dol   { font-family:'JetBrains Mono',monospace; font-size:13px; font-weight:800; color:var(--text-primary); line-height:1.2; white-space:nowrap; }
        @media (min-width:1024px) { .p3-header-bar { display:flex !important; } }

        /* ── HINT DOBLE TAP en dashboard cards ── */
        .dash-doubletap-hint {
            position: absolute;
            top: 4px;
            right: 6px;
            font-family: var(--font-head);
            font-size: 7px;
            font-weight: 700;
            color: var(--text-tertiary);
            letter-spacing: 0.5px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .dashboard-card.slot-active .dash-doubletap-hint {
            color: var(--brand);
            opacity: 0.8;
        }

        /* En PC: barra del panel 3 innecesaria — paneles siempre visibles */
        @media (min-width: 1024px) {
            .levels-back-btn { display: none !important; }
            .p3-header-bar   { display: flex !important; }
            .dash-doubletap-hint { display: none; }
        }
        #desktop-etf-list { display: none; order: 7; }

        @media (max-width: 767px) {
            .content-spacer { padding: 4px; margin-top: calc(var(--safe-top, 20px) + 50px) !important; }
            #tv_chart, #controlsGrid, #radarTickerContainer, #dashMain { margin: 0 !important; margin-bottom: 2px !important; }
            .dashboard-card, .radar-ticker-large, .input-group, .unified-card { margin-left: 0 !important; margin-right: 0 !important; }
            .panel-nav-dots { display: flex; }
        }

        /* ═══════════════════════════════════════════════
           TABLET (768–1023px)
           Paneles visibles: swipe conservado, arrows añadidos,
           fuentes y targets más cómodos
        ═══════════════════════════════════════════════ */
        @media (min-width: 768px) and (max-width: 1023px) {
            .content-spacer { padding: 4px; margin-top: calc(var(--safe-top, 0px) + 54px) !important; max-width: 100%; }
            
            /* Panel arrows visibles en tablet */
            .panel-arrow { display: flex; }

            /* Panels levemente más cómodos */
            .panels-wrapper {
                top: calc(var(--safe-top, 0px) + 54px);
                height: calc(100vh - var(--safe-top, 0px) - 54px - var(--safe-bottom, 0px));
            }

            /* Targets táctiles más grandes */
            .tf-btn { font-size: 13px; padding: 6px 0; }
            .unified-card { min-height: 90px !important; }
            .u-title { font-size: 21px !important; }
            .u-val-primary { font-size: 15px !important; }
            .dashboard-card { min-height: 140px !important; }
            .dash-cell-coin-name { font-size: 18px !important; }
            .dash-cell-value { font-size: 14px !important; }
            .gd-metric-value { font-size: 17px !important; }
            .radar-balance-compact { font-size: 18px !important; }
            .chat-input { font-size: 14px !important; }
            .anim-click { min-height: 40px; }

            /* Scroll indicators */
            .panel-nav-dots { display: flex; }
        }

        /* ═══════════════════════════════════════════════
           PC / ESCRITORIO (1024px+)
           Tres paneles visibles simultáneamente en columnas
        ═══════════════════════════════════════════════ */
        @media (min-width: 1024px) {
            /* Reubicamos content-spacer */
            .content-spacer { padding: 0; margin-top: calc(var(--safe-top, 0px) + 56px) !important; max-width: 100%; }

            /* El wrapper ya no es fixed con overflow hidden — se convierte en contenedor flex */
            .panels-wrapper {
                position: relative !important;
                top: auto !important;
                left: auto !important;
                width: 100% !important;
                height: calc(100vh - var(--safe-top, 0px) - 56px) !important;
                overflow: visible !important;
            }

            /* El container pasa a flex row normal — NO hay transform de slide */
            .panels-container {
                width: 100% !important;
                transform: none !important;
                transition: none !important;
                display: flex !important;
                flex-direction: row !important;
                height: 100% !important;
                gap: 0 !important;
            }
            /* Deshabilitar drag en desktop */
            .panels-container.is-dragging { transition: none !important; }

            /* Cada panel visible en su columna */
            .panel {
                width: 33.3333% !important;
                min-width: 0;
                flex-shrink: 0 !important;
                overflow-y: auto !important;
                border-right: 1px solid var(--border);
            }
            .panel:last-child { border-right: none; }

            /* Panel activo con indicador sutil */
            .panel.pc-active { background: rgba(255,255,255,0.01); }
            .panel.pc-active > .panel-number {
                color: var(--brand) !important;
                border-color: var(--brand) !important;
            }

            /* Mejoras de densidad para PC */
            .panel-number { display: none; }  /* ocultar números de panel en PC — todos visibles */

            .tf-btn { font-size: 12px; }
            .unified-card { min-height: 80px !important; }
            .u-title { font-size: 20px !important; }
            .dashboard-card { min-height: 130px !important; }
            .gd-metric-value { font-size: 15px !important; }
            .gd-metric-label { font-size: 9px !important; }
            .chart-wrapper { height: 280px !important; }

            /* Panel 1 (Gate.io + Radar): scroll interno */
            #panel1 .panel-content { padding-bottom: 20px !important; }

            /* Panel 0 (Dashboards): scroll interno */
            #panel0 .panel-content { padding-bottom: 20px !important; }

            /* Panel 5 (Levels): scroll interno */
            #panel5 .panel-content { padding-bottom: 20px !important; }
            #panel5 #levelsGrid { padding-bottom: 20px !important; max-height: none !important; }

            /* Ocultar flechas de navegación — no se necesitan en PC */
            .panel-arrow { display: none !important; }
            .panel-nav-dots { display: none !important; }

            /* Scroll más cómodo en PC */
            .panel::-webkit-scrollbar { width: 5px; }
            .panel::-webkit-scrollbar-thumb { background: var(--border-strong); border-radius: 3px; }

            /* Header más alto */
            .app-header { height: 56px; }
            .fixed-header { height: calc(var(--safe-top, 0px) + 56px); }
        }
        
        /* Modal de Confirmación Personalizado */
        #customConfirmModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: 10000;
            backdrop-filter: blur(4px);
            align-items: center;
            justify-content: center;
        }
        #customConfirmModal.show {
            display: flex;
        }
        .confirm-dialog {
            background: var(--surface);
            border: 2px solid var(--brand);
            border-radius: 20px;
            padding: 20px 16px 16px;
            max-width: 290px;
            width: 88%;
            box-shadow: 0 12px 40px rgba(0,0,0,0.6), 0 0 0 1px var(--border);
            animation: modal-pop 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes modal-pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .confirm-title {
            font-family: var(--font-head);
            font-size: 13px;
            font-weight: 900;
            color: var(--brand);
            margin-bottom: 10px;
            text-align: center;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        .confirm-amount {
            font-family: var(--font-num);
            font-size: 26px;
            font-weight: 900;
            color: var(--text-primary);
            text-align: center;
            line-height: 1.1;
            margin-bottom: 4px;
        }
        .confirm-price {
            font-family: var(--font-num);
            font-size: 14px;
            font-weight: 700;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 6px;
        }
        .confirm-badge {
            display: inline-block;
            background: rgba(var(--long-rgb, 52,211,153), 0.15);
            color: var(--long);
            font-family: var(--font-head);
            font-size: 10px;
            font-weight: 800;
            padding: 3px 10px;
            border-radius: 20px;
            margin: 0 auto 14px;
            letter-spacing: 0.5px;
            text-align: center;
            width: 100%;
        }
        .confirm-message { display: none; }
        .confirm-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 4px;
        }
        .confirm-btn {
            padding: 12px;
            border-radius: 12px;
            font-family: var(--font-head);
            font-size: 13px;
            font-weight: 800;
            border: 2px solid;
            cursor: pointer;
            transition: transform 0.15s;
            letter-spacing: 0.5px;
        }
        .confirm-btn:active { transform: scale(0.95); }
        .confirm-btn-cancel {
            background: transparent;
            border-color: var(--border-strong);
            color: var(--text-secondary);
        }
        .confirm-btn-accept {
            background: var(--brand);
            border-color: var(--brand);
            color: #fff;
        }
        
        /* NUEVOS PANELES LATERALES TIPO WHATSAPP */
        
        /* Numeración de Panel — oculta en móvil, subtítulo en tablet */
        .panel-number { display: none; }
        @media (min-width: 768px) and (max-width: 1023px) {
            .panel-number {
                display: none; /* se quita en tablet — todo en una vista */
            }
        }
        
        /* Panel vacío placeholder */
        .empty-panel-placeholder {
            min-height: 60vh;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 12px;
            opacity: 0.5;
        }
        
        .empty-panel-text {
            font-family: var(--font-head);
            font-size: 14px;
            color: var(--text-tertiary);
            text-align: center;
        }
        
        .empty-panel-icon {
            width: 48px;
            height: 48px;
            border: 2px dashed var(--border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-tertiary);
        }

        /* ═══════════════════════════════════════════════════════════
           SECCIÓN CUENTA & SINCRONIZACIÓN LOCAL — C5X
        ═══════════════════════════════════════════════════════════ */
        .cloud-hero { display:flex; flex-direction:column; align-items:center; gap:14px; padding:24px 16px 16px; }
        .cloud-icon-wrap { width:68px; height:68px; border-radius:50%; background:linear-gradient(135deg,var(--brand),#8b5cf6); display:flex; align-items:center; justify-content:center; font-size:30px; box-shadow:0 4px 24px rgba(59,130,246,0.35); }
        .cloud-hero-title { font-family:var(--font-head); font-size:15px; font-weight:900; color:var(--text-primary); letter-spacing:1px; text-align:center; }
        .cloud-hero-sub { font-family:var(--font-head); font-size:10px; color:var(--text-tertiary); text-align:center; line-height:1.8; letter-spacing:0.3px; }
        .cloud-card { background:var(--surface); border:1px solid var(--border); border-radius:16px; padding:14px; }
        .cloud-user-row { display:flex; align-items:center; gap:12px; padding-bottom:12px; border-bottom:1px solid var(--border); margin-bottom:12px; }
        .cloud-avatar { width:48px; height:48px; border-radius:50%; background:linear-gradient(135deg,var(--brand),#8b5cf6); display:flex; align-items:center; justify-content:center; font-size:22px; flex-shrink:0; overflow:hidden; border:2px solid var(--border); }
        .cloud-avatar img { width:100%; height:100%; object-fit:cover; border-radius:50%; }
        .cloud-user-info { flex:1; min-width:0; }
        .cloud-user-name { font-family:var(--font-head); font-size:13px; font-weight:800; color:var(--text-primary); display:flex; align-items:center; gap:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .cloud-user-email { font-family:var(--font-num); font-size:10px; color:var(--text-tertiary); margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        /* ── MURO DE AUTENTICACIÓN ───────────────────────────────── */
        #authWall {
            position: fixed; inset: 0; z-index: 99999;
            background: var(--bg);
            display: flex;
            align-items: center; justify-content: center;
            flex-direction: column;
            padding: 32px 24px; text-align: center;
            transition: opacity 0.4s ease;
        }
        #authWall.hidden { display: none !important; }
        #authWall.hiding { opacity: 0; pointer-events: none; }
        .auth-wall-logo {
            font-family: var(--font-head); font-size: 48px; font-weight: 900;
            color: var(--brand); letter-spacing: 4px; margin-bottom: 8px;
        }
        .auth-wall-sub {
            font-family: var(--font-head); font-size: 10px; font-weight: 700;
            color: var(--text-tertiary); letter-spacing: 2px; margin-bottom: 48px;
        }
        .auth-wall-card {
            width: 100%; max-width: 320px;
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 20px; padding: 28px 20px;
        }
        .auth-wall-title {
            font-family: var(--font-head); font-size: 13px; font-weight: 900;
            color: var(--text-primary); letter-spacing: 1px; margin-bottom: 6px;
        }
        .auth-wall-desc {
            font-family: var(--font-head); font-size: 10px;
            color: var(--text-tertiary); line-height: 1.7; margin-bottom: 24px;
        }
        .btn-5x-access {
            width: 100%; padding: 14px 16px;
            background: var(--brand); color: #fff;
            border: none; border-radius: 14px;
            font-family: var(--font-head); font-size: 12px; font-weight: 900;
            letter-spacing: 1px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 10px;
            transition: opacity 0.2s;
        }
        .btn-5x-access:active { opacity: 0.8; }
        .auth-wall-checking {
            font-family: var(--font-head); font-size: 10px;
            color: var(--text-tertiary); margin-top: 16px;
            letter-spacing: 1px; animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }
        .auth-wall-version {
            position: absolute; bottom: 20px;
            font-family: var(--font-head); font-size: 9px;
            color: var(--text-tertiary); letter-spacing: 1px;
        }

        /* Secciones avanzadas — ocultas por defecto, solo con PIN admin */
        .admin-only { display: none; }
        .admin-only-grid { display: none; }
        .admin-section-wrapper { display: none; }

        .cloud-admin-badge { background:linear-gradient(135deg,rgba(245,158,11,0.2),rgba(245,158,11,0.05)); border:1px solid rgba(245,158,11,0.4); border-radius:10px; padding:2px 7px; font-family:var(--font-head); font-size:8px; font-weight:900; color:var(--warning); letter-spacing:0.5px; flex-shrink:0; }
        .cloud-sync-pill { display:inline-flex; align-items:center; gap:5px; padding:4px 10px; border-radius:20px; font-family:var(--font-head); font-size:9px; font-weight:700; letter-spacing:0.5px; border:1px solid; transition:all 0.3s; }
        .cloud-sync-pill.synced { background:rgba(16,185,129,0.1); color:var(--long); border-color:rgba(16,185,129,0.3); }
        .cloud-sync-pill.syncing { background:rgba(59,130,246,0.1); color:var(--brand); border-color:rgba(59,130,246,0.3); }
        .cloud-sync-pill.offline { background:rgba(107,114,128,0.1); color:var(--text-tertiary); border-color:var(--border); }
        .cloud-sync-pill.error { background:rgba(239,68,68,0.1); color:var(--short); border-color:rgba(239,68,68,0.3); }
        .cloud-sync-dot { width:6px; height:6px; border-radius:50%; flex-shrink:0; }
        .synced .cloud-sync-dot { background:var(--long); animation:cloud-blink 2.5s infinite; }
        .syncing .cloud-sync-dot { background:var(--brand); animation:cloud-blink 0.8s infinite; }
        .offline .cloud-sync-dot { background:var(--text-tertiary); }
        .error .cloud-sync-dot { background:var(--short); }
        @keyframes cloud-blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
        .cloud-stats { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px; }
        .cloud-stat { background:rgba(0,0,0,0.12); border-radius:10px; padding:8px 10px; text-align:center; }
        .cloud-stat-lbl { font-family:var(--font-head); font-size:8px; font-weight:700; color:var(--text-tertiary); letter-spacing:0.8px; display:block; margin-bottom:3px; }
        .cloud-stat-val { font-family:var(--font-num); font-size:13px; font-weight:800; color:var(--text-primary); }
        .cloud-actions { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
        .cloud-btn { padding:10px 8px; border-radius:12px; border:1px solid var(--border); background:var(--bg); color:var(--text-primary); font-family:var(--font-head); font-size:10px; font-weight:700; cursor:pointer; text-align:center; transition:all 0.2s; letter-spacing:0.3px; display:flex; align-items:center; justify-content:center; gap:5px; }
        .cloud-btn:active { transform:scale(0.96); }
        .cloud-btn:disabled { opacity:0.38; cursor:not-allowed; }
        .cloud-btn.primary { color:var(--brand); border-color:rgba(59,130,246,0.35); background:rgba(59,130,246,0.06); }
        .cloud-btn.success { color:var(--long); border-color:rgba(16,185,129,0.35); background:rgba(16,185,129,0.06); }
        .cloud-btn.warn { color:var(--warning); border-color:rgba(245,158,11,0.35); background:rgba(245,158,11,0.06); }
        .cloud-btn.danger { color:var(--short); border-color:rgba(239,68,68,0.3); }
        .cloud-last-sync { font-family:var(--font-num); font-size:9px; color:var(--text-tertiary); text-align:center; margin-top:8px; }
        .cfg-card { background:var(--surface); border:1px solid rgba(245,158,11,0.3); border-radius:16px; padding:14px; margin-top:8px; }
        .cfg-row { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
        .fb-cfg-inp { width:100%; background:rgba(0,0,0,0.15); border:1px solid var(--border); border-radius:8px; padding:8px 10px; color:var(--text-primary); font-family:var(--font-num); font-size:11px; outline:none; transition:border-color 0.2s; margin-bottom:7px; box-sizing:border-box; }
        .fb-cfg-inp:focus { border-color:var(--brand); }
        .fb-cfg-lbl { font-family:var(--font-head); font-size:8px; font-weight:700; color:var(--text-tertiary); letter-spacing:0.8px; display:block; margin-bottom:4px; }
        .cloud-info-tip { background:rgba(59,130,246,0.06); border:1px solid rgba(59,130,246,0.2); border-radius:10px; padding:10px 12px; font-family:var(--font-head); font-size:10px; color:var(--text-secondary); line-height:1.7; margin-top:8px; }
        .cloud-info-tip strong { color:var(--brand); }
        .cloud-not-configured { display:flex; flex-direction:column; align-items:center; gap:10px; padding:18px 12px; text-align:center; }
        .cloud-not-configured p { font-family:var(--font-head); font-size:10px; color:var(--text-tertiary); line-height:1.7; }

        /* ── EDICIÓN INLINE DE PRECIO BASE EN DASHBOARD ── */
        .dash-base-edit-input {
            background: transparent;
            border: none;
            border-bottom: 2px solid var(--brand);
            color: var(--brand);
            font-family: var(--font-num);
            font-size: 13px;
            font-weight: 800;
            text-align: center;
            width: 100%;
            outline: none;
            padding: 2px 0;
            -webkit-text-fill-color: var(--brand);
            letter-spacing: 0.3px;
        }
        .dash-cell.editing-base {
            border-color: var(--brand) !important;
            background: rgba(59,130,246,0.1) !important;
            animation: breathe-real 2s ease-in-out infinite;
        }
        .dash-cell.editing-base .dash-cell-label { color: var(--brand); }
        /* Badge de rango en el slot label */
        .slot-rank-badge {
            display: inline-block;
            background: linear-gradient(90deg, rgba(245,158,11,0.2), rgba(245,158,11,0.05));
            border: 1px solid rgba(245,158,11,0.5);
            border-radius: 6px;
            padding: 0px 5px;
            font-size: 8px;
            font-weight: 900;
            color: var(--warning);
            margin-left: 5px;
            letter-spacing: 0.5px;
        }
        .slot-rank-badge.rank-1 { background: linear-gradient(90deg, rgba(245,158,11,0.3),rgba(245,158,11,0.08)); border-color: var(--warning); color: var(--warning); }
        .slot-rank-badge.rank-2 { background: rgba(107,114,128,0.15); border-color: var(--border-strong); color: var(--text-secondary); }
        .slot-rank-badge.rank-3 { background: rgba(180,100,40,0.15); border-color: rgba(180,100,40,0.4); color: #b46428; }

        /* ══════════════════════════════════════════════════════════
           BANNER DE PERMISOS DE NOTIFICACIONES
        ══════════════════════════════════════════════════════════ */
        #notifPermBanner {
            position: fixed;
            bottom: calc(70px + var(--safe-bottom));
            left: 12px; right: 12px;
            background: linear-gradient(135deg, #1a2235, #141922);
            border: 1px solid rgba(59,130,246,0.5);
            border-radius: 18px;
            padding: 14px 16px;
            z-index: 9990;
            display: none;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 0 1px rgba(59,130,246,0.2);
            animation: slide-in 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        #notifPermBanner.visible { display: flex; }
        .notif-banner-top {
            display: flex; align-items: center; gap: 12px;
        }
        .notif-banner-icon {
            width: 42px; height: 42px; flex-shrink: 0;
            background: linear-gradient(135deg, rgba(59,130,246,0.3), rgba(139,92,246,0.2));
            border: 1px solid rgba(59,130,246,0.4);
            border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
        }
        .notif-banner-text { flex: 1; }
        .notif-banner-title {
            font-family: var(--font-head); font-size: 11px; font-weight: 900;
            color: var(--text-primary); letter-spacing: 0.5px; margin-bottom: 2px;
        }
        .notif-banner-sub {
            font-family: var(--font-head); font-size: 9px; font-weight: 600;
            color: var(--text-tertiary); letter-spacing: 0.3px; line-height: 1.5;
        }
        .notif-banner-close {
            width: 28px; height: 28px; border-radius: 50%;
            background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            color: var(--text-tertiary); display: flex; align-items: center;
            justify-content: center; cursor: pointer; flex-shrink: 0; font-size: 12px;
        }
        .notif-banner-btns { display: flex; gap: 8px; }
        .notif-btn-allow {
            flex: 1; padding: 10px; border-radius: 12px;
            background: var(--brand); border: none; color: #fff;
            font-family: var(--font-head); font-size: 11px; font-weight: 900;
            letter-spacing: 0.5px; cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 6px;
        }
        .notif-btn-allow:active { transform: scale(0.96); opacity: 0.85; }
        .notif-btn-later {
            padding: 10px 16px; border-radius: 12px;
            background: transparent; border: 1px solid var(--border);
            color: var(--text-tertiary); font-family: var(--font-head);
            font-size: 10px; font-weight: 700; cursor: pointer; transition: all 0.2s;
        }
        .notif-btn-later:active { background: rgba(255,255,255,0.05); }

        /* Indicador de estado de notificaciones en settings */
        .notif-status-row {
            display: flex; align-items: center; justify-content: space-between;
            background: var(--card-bg); border: 1px solid var(--border);
            border-radius: 14px; padding: 12px 16px; margin-bottom: 8px;
        }
        .notif-status-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--text-tertiary); flex-shrink: 0;
        }
        .notif-status-dot.granted { background: var(--long); box-shadow: 0 0 8px var(--long); animation: pulse-ring 2s infinite; }
        .notif-status-dot.denied  { background: var(--short); }

        /* ══════════════════════════════════════════════════════════════════
           ✦ WARM GOLD — Acento dorado en toda la interfaz
           Sobrescribe --brand con el tono dorado de cada tema.
           Todos los rgba(59,130,246) hardcodeados son reemplazados.
        ══════════════════════════════════════════════════════════════════ */

        /* ── 1. Variables: --brand = gold para cada tema ── */
        :root,
        body:not(.light-mode):not(.volcanic-light) {
            --brand: #fbbf24;
            --brand-rgb: 251, 191, 36;
        }
        body.light-mode {
            --brand: #b45309;
            --brand-rgb: 180, 83, 9;
        }
        body.volcanic-light {
            --brand: #92400e;
            --brand-rgb: 146, 64, 14;
        }

        /* ── 2. Animación breathe-active-slot → gold ── */
        @keyframes breathe-active-slot {
            0%, 100% {
                box-shadow: 0 0 0 2px rgba(251,191,36,0.25), 0 0 0 rgba(251,191,36,0), 0 8px 25px rgba(0,0,0,0.3);
                border-color: rgba(251,191,36,0.45);
            }
            50% {
                box-shadow: 0 0 0 3px rgba(251,191,36,0.55), 0 0 28px rgba(251,191,36,0.25), 0 8px 35px rgba(0,0,0,0.4);
                border-color: var(--brand);
            }
        }

        /* ── 3. Dashboard card activa ── */
        .dashboard-card.slot-active {
            background: linear-gradient(145deg, rgba(251,191,36,0.08) 0%, var(--surface) 60%);
            border-color: var(--brand);
            box-shadow:
                0 0 0 3px rgba(251,191,36,0.18),
                0 8px 32px rgba(251,191,36,0.12),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .dashboard-card.slot-active::before {
            background: linear-gradient(90deg, transparent, var(--brand), var(--long));
            height: 2px;
        }

        /* ── 4. Celda de moneda activa → gold ── */
        .dashboard-card.slot-active .dash-cell-coin-name {
            color: var(--brand);
        }

        /* ── 5. Botón MANUAL → gold ── */
        .trading-manual-btn {
            background: rgba(251,191,36,0.08) !important;
            border-color: var(--brand) !important;
            color: var(--brand) !important;
        }
        .trading-manual-btn:active {
            background: rgba(251,191,36,0.14) !important;
        }
        .trading-manual-btn.auto-mode {
            background: rgba(16,185,129,0.1) !important;
            border-color: var(--long) !important;
            color: var(--long) !important;
        }

        /* ── 6. Temporalidades activas → gold ── */
        .tf-btn.active {
            color: var(--brand) !important;
            background: rgba(251,191,36,0.1) !important;
        }

        /* ── 7. Inputs con foco/locked → gold ── */
        .input-field.locked-input {
            color: var(--brand) !important;
            -webkit-text-fill-color: var(--brand) !important;
        }
        .input-field.manual-edit {
            background: rgba(251,191,36,0.12) !important;
            border-bottom-color: var(--brand) !important;
        }
        .input-field.editing-mode {
            border-bottom-color: var(--brand) !important;
            background: rgba(251,191,36,0.08) !important;
        }
        .input-group:focus-within {
            border-color: var(--brand) !important;
        }

        /* ── 8. Ticker / header pill → gold ── */
        .ticker-pill.pinned-mode {
            border-color: var(--brand) !important;
            background: rgba(251,191,36,0.07) !important;
            box-shadow: 0 0 10px rgba(251,191,36,0.12) !important;
        }
        .ticker-pill.scrolled-mode {
            background: rgba(251,191,36,0.1) !important;
            border-color: var(--brand) !important;
            box-shadow: 0 4px 15px rgba(251,191,36,0.18) !important;
        }

        /* ── 9. Estrategias / modos → gold ── */
        #stratNormal.active,
        .strategy-option-compact.mode-normal,
        .strategy-option-compact#stratNormal.active {
            background: rgba(251,191,36,0.12) !important;
            color: var(--brand) !important;
            border-color: var(--brand) !important;
            box-shadow: 0 0 8px rgba(251,191,36,0.25) !important;
        }
        .strategy-option-compact.pressing,
        .dash-target-bar-compact.pressing {
            background: rgba(251,191,36,0.15) !important;
            border-color: var(--brand) !important;
        }
        .strategy-option-compact.pressing::before,
        .dash-target-bar-compact.pressing::before {
            background: var(--brand) !important;
        }

        /* ── 10. Unified card estado "reached" → gold ── */
        .unified-card.is-reached {
            border: 1px solid rgba(251,191,36,0.55) !important;
            background: rgba(251,191,36,0.07) !important;
        }

        /* ── 11. Barra de recuperación → gold ── */
        .dash-rec-fill { background: var(--brand) !important; }
        .dash-recovery-row { border-color: rgba(251,191,36,0.2) !important; }

        /* ── 12. Scrollbar principal → gold ── */
        ::-webkit-scrollbar-thumb:hover { background: var(--brand) !important; }
        .levels-container::-webkit-scrollbar-thumb { background: rgba(251,191,36,0.5) !important; }
        .levels-container::-webkit-scrollbar-thumb:hover { background: var(--brand) !important; }

        /* ── 13. Precio label overlay (avg line) → gold ── */
        .price-label.avg { color: var(--brand) !important; border-left-color: var(--brand) !important; }

        /* ── 14. Chat send btn → gold ── */
        .chat-send-btn {
            background: var(--brand) !important;
            box-shadow: 0 2px 8px rgba(251,191,36,0.35) !important;
        }
        .chat-input:focus { border-color: var(--brand) !important; }
        .chat-sender-name { color: var(--brand) !important; }

        /* ── 15. Botón acceso / principal → gold ── */
        .btn-5x-access { background: var(--brand) !important; color: #000 !important; }
        .etf-action-btn.primary {
            background: var(--brand) !important;
            border-color: var(--brand) !important;
            color: #000 !important;
            box-shadow: 0 4px 15px rgba(251,191,36,0.25) !important;
        }
        .action-btn { border-color: var(--brand) !important; color: var(--brand) !important; }

        /* ── 16. Edición inline de precio base → gold ── */
        .dash-cell.editing-base {
            border-color: var(--brand) !important;
            background: rgba(251,191,36,0.08) !important;
        }
        .dash-cell.editing-base .dash-cell-label { color: var(--brand) !important; }
        .dash-base-edit-input {
            border-bottom-color: var(--brand) !important;
            color: var(--brand) !important;
            -webkit-text-fill-color: var(--brand) !important;
        }

        /* ── 17. Dot activo nav ── */
        .panel-dot.active { background: var(--brand) !important; }
        .nav-item.selected {
            background: rgba(251,191,36,0.08) !important;
            border-color: var(--brand) !important;
            box-shadow: 0 5px 20px rgba(251,191,36,0.12) !important;
        }
        .nav-item.selected .nav-icon { color: var(--brand) !important; }

        /* ── 18. Gate.io brand → gold ── */
        .gd-brand { color: var(--brand) !important; }
        .gd-conn-dot.connected { background: var(--long); box-shadow: 0 0 8px var(--long); }
        .gd-refresh-btn { border-color: rgba(251,191,36,0.3) !important; color: var(--brand) !important; }
        .gd-refresh-btn:active { background: rgba(251,191,36,0.1) !important; }

        /* ── 19. Dash target bar → gold ── */
        .dash-target-bar-compact {
            background: linear-gradient(90deg, rgba(251,191,36,0.1), rgba(251,146,60,0.06)) !important;
            border-color: var(--brand) !important;
        }

        /* ── 20. Strategy mode-normal → gold ── */
        .strategy-option-compact.mode-dorada {
            background: rgba(251,191,36,0.18) !important;
            color: var(--brand) !important;
            border-color: var(--brand) !important;
            box-shadow: 0 0 8px rgba(251,191,36,0.35) !important;
        }

        /* ── 21. Pulse ring animación → gold ── */
        @keyframes pulse-ring {
            0%   { box-shadow: 0 0 0 0 rgba(251,191,36,0.45); }
            70%  { box-shadow: 0 0 0 6px rgba(251,191,36,0); }
            100% { box-shadow: 0 0 0 0 rgba(251,191,36,0); }
        }

        /* ── 22. Breathe radar → gold ── */
        @keyframes breathe-radar {
            0%,100% { box-shadow: 0 4px 12px rgba(0,0,0,0.2), 0 0 0 0 rgba(251,191,36,0); border-color: var(--border); transform: scale(1); }
            40%,60% { box-shadow: 0 6px 28px rgba(251,191,36,0.25), 0 0 22px rgba(251,191,36,0.15); border-color: rgba(251,191,36,0.6); transform: scale(1.012); }
        }

        /* ── 23. Dash input box editable ── */
        .dash-input-box.editable {
            border-color: var(--brand) !important;
            background: rgba(251,191,36,0.05) !important;
        }

        /* ── 24. Unified card triggered → gold tones ── */
        .unified-card.is-triggered {
            border-color: rgba(251,191,36,0.7) !important;
            background: rgba(251,191,36,0.07) !important;
        }
        .unified-card.is-triggered .u-index {
            background: rgba(251,191,36,0.18) !important;
            border-color: rgba(251,191,36,0.6) !important;
            color: var(--brand) !important;
        }

        /* ── 25. Slot rank badge #1 → gold (ya usaba warning, refuerzo) ── */
        .slot-rank-badge.rank-1 { border-color: var(--brand) !important; color: var(--brand) !important; }

        /* ── 26. Notif banner → gold ── */
        #notifPermBanner { border-color: rgba(251,191,36,0.4) !important; }
        .notif-btn-allow { background: var(--brand) !important; color: #000 !important; }
    </style>
</head>
<body onload="init()">
    <!-- Modal de Confirmación Personalizado -->
    <div id="customConfirmModal">
        <div class="confirm-dialog">
            <div class="confirm-title" id="confirmTitle">COMPRAR NIVEL</div>
            <div class="confirm-amount" id="confirmAmount">$0.00 USDT</div>
            <div class="confirm-price" id="confirmPrice">@ $0.00</div>
            <div class="confirm-badge" id="confirmBadge">LÍMITE</div>
            <div class="confirm-message" id="confirmMessage" style="display:none;"></div>
            <div class="confirm-buttons">
                <button class="confirm-btn confirm-btn-cancel" onclick="closeConfirmModal(false)">Cancelar</button>
                <button class="confirm-btn confirm-btn-accept" onclick="closeConfirmModal(true)">Aceptar</button>
            </div>
        </div>
    </div>

    <!-- ══ BANNER DE PERMISO DE NOTIFICACIONES ══ -->
    <div id="notifPermBanner">
        <div class="notif-banner-top">
            <div class="notif-banner-icon">🔔</div>
            <div class="notif-banner-text">
                <div class="notif-banner-title">ACTIVAR ALERTAS</div>
                <div class="notif-banner-sub">Recibe notificaciones de objetivos alcanzados, compras ejecutadas y alertas de precio aunque cierres la app.</div>
            </div>
            <div class="notif-banner-close" onclick="dismissNotifBanner()">✕</div>
        </div>
        <div class="notif-banner-btns">
            <button class="notif-btn-allow" onclick="requestNotifPermission()">
                <svg width="14" height="14" viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>
                ACTIVAR NOTIFICACIONES
            </button>
            <button class="notif-btn-later" onclick="dismissNotifBanner()">Ahora no</button>
        </div>
    </div>

    <audio id="alertSound" preload="auto" src="data:audio/wav;base64,UklGRl9vT1BXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU"></audio>
    <div id="toast">Notificación</div>
    
    <!-- FAB movido al final del body -->
    <div id="navModal" onclick="if(event.target===this) closeMenuViaButton()">
        <div class="nav-content section-enter">
            <div class="nav-title">MENÚ 5X</div>
            <div class="nav-item anim-click" id="nav-botdash" onclick="switchView('botdash')"><div class="nav-icon" style="position:relative;"><svg width="24" height="24" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8M12 17v4"/><circle cx="12" cy="10" r="3" fill="currentColor" opacity=".3"/><path d="M12 7v3l2 2" stroke="currentColor" stroke-width="1.5"/></svg><span id="botDashNavDot" style="display:none;position:absolute;top:-2px;right:-2px;width:8px;height:8px;border-radius:50%;background:var(--long);box-shadow:0 0 6px var(--long);"></span></div><div class="nav-text">BOT LIVE</div></div>
            <div class="nav-item anim-click" id="nav-etf" onclick="switchView('etf')"><div class="nav-icon anim-pulse"><svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg></div><div class="nav-text">MONITOR ETF</div></div>
            <div class="nav-item anim-click" id="nav-log" onclick="switchView('log')"><div class="nav-icon"><svg width="24" height="24" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></div><div class="nav-text">BITÁCORA</div></div>
            <div class="nav-item anim-click" id="nav-settings" onclick="switchView('settings')"><div class="nav-icon anim-spin"><svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></div><div class="nav-text">AJUSTES</div></div>
            <div class="nav-item anim-click" id="nav-support" onclick="switchView('support')"><div class="nav-icon"><svg width="24" height="24" viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg></div><div class="nav-text">SOPORTE</div></div>
            <div class="nav-item anim-click" id="nav-strategy" onclick="switchView('strategy')"><div class="nav-icon"><svg width="24" height="24" viewBox="0 0 24 24"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg></div><div class="nav-text">ESTRATEGIA</div></div>
            <button class="btn-close-menu anim-click" onclick="closeMenuViaButton()"><svg width="18" height="18" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> CERRAR MENÚ</button>
        </div>
    </div>
    <div class="fixed-header">
        <header class="app-header">
            <div class="brand-btn"><span class="brand-text">5X</span></div>
            
            <!-- TICKER: entre C5X y el botón tema, siempre visible -->
            <div class="ticker-container" id="tickerContainer">
                <div class="ticker-pill anim-click" id="mainTickerPill" onclick="viewTickerChart(event)" ontouchstart="handleTickerTouchStart(event)" ontouchend="handleTickerTouchEnd(event)" onmousedown="handleTickerMouseDown(event)" onmouseup="handleTickerMouseUp(event)" onmouseleave="cancelTickerPress()">
                    <div class="ticker-group-left"><div class="ticker-dot" id="t-dot"></div><span class="ticker-sym" id="t-sym">BTC</span></div>
                    <div class="ticker-group-right"><span class="ticker-price" id="t-price"><span class="skeleton-text skeleton-box"></span></span><span class="ticker-pct" id="t-pct">--%</span></div>
                </div>
            </div>
            
            <!-- USDT removido del header — se ve en el dashboard general -->
            <div id="usdtContainer" style="display:none;"></div>
            
            <div class="user-menu-wrapper" id="userMenuWrapper">
                <div class="user-btn anim-click" onclick="toggleUserMenu()" title="Menú usuario" id="userAvatarBtn">
                    <span id="userAvatarEmoji">👤</span>
                </div>
                <div class="user-dropdown" id="userDropdown">

                    <!-- 1. C5X + Tema -->
                    <div class="user-drop-row1">
                        <span class="user-drop-c5x">5X</span>
                        <div class="user-drop-theme-toggle anim-click" onclick="toggleTheme(); updateThemeIcon();" id="themeToggleBtn">
                            <span id="themeHint">🌙</span>
                            <span class="user-drop-theme-label" id="themeLabel">OSCURO</span>
                        </div>
                    </div>

                    <!-- 2. Usuario local -->
                    <div class="user-drop-item" onclick="closeUserMenu(); switchView('settings');" style="gap:10px;">
                        <svg width="15" height="15" viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                        <div style="flex:1;">
                            <div style="font-family:var(--font-head);font-size:11px;font-weight:800;color:var(--text-primary);">LOCAL</div>
                            <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);">Datos en este dispositivo</div>
                        </div>
                    </div>

                    <!-- 3. Monitor ETF -->
                    <div class="user-drop-item" onclick="closeUserMenu(); switchView('etf');">
                        <svg width="15" height="15" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>
                        MONITOR ETF
                    </div>

                    <!-- 4. Bitácora -->
                    <div class="user-drop-item" onclick="closeUserMenu(); switchView('log');">
                        <svg width="15" height="15" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line></svg>
                        BITÁCORA
                    </div>



                    <!-- 6. Ajustes -->
                    <div class="user-drop-item" onclick="closeUserMenu(); switchView('strategy');">
                        <svg width="14" height="14" viewBox="0 0 24 24"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                        ESTRATEGIA
                    </div>
                    <div class="user-drop-item" onclick="closeUserMenu(); switchView('support');">
                        <svg width="14" height="14" viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                        SOPORTE
                    </div>
                    <div class="user-drop-item" onclick="closeUserMenu(); switchView('settings');">
                        <svg width="15" height="15" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                        AJUSTES
                    </div>
                    <div class="user-drop-item" onclick="closeUserMenu(); logoutApp();" style="color:#ef4444;border-top:1px solid rgba(0,0,0,0.1);margin-top:4px;">
                        <svg width="15" height="15" viewBox="0 0 24 24" stroke="#ef4444" fill="none"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                        CERRAR SESIÓN
                    </div>

                </div>
            </div>
        </header>
    </div>
    <!-- ═══ MURO DE AUTENTICACIÓN — bloquea toda la app ═══ -->
    <div id="authWall">
        <div class="auth-wall-logo">5X</div>
        <div class="auth-wall-sub">TRADING PRIVADO</div>
        <div class="auth-wall-card">
            <div class="auth-wall-title">🔒 INICIAR SESIÓN</div>
            <div class="auth-wall-desc" id="authWallDesc">
                Ingresa tu usuario y contraseña para acceder.
            </div>
            <div style="width:100%;margin-bottom:12px;">
                <input type="text" id="loginUser" placeholder="Usuario" autocomplete="off"
                    style="width:100%;padding:12px 16px;background:rgba(0,0,0,0.08);border:1px solid rgba(0,0,0,0.2);border-radius:14px;color:#111;font-size:14px;font-family:inherit;outline:none;box-sizing:border-box;margin-bottom:10px;">
                <input type="password" id="loginPass" placeholder="Contraseña" autocomplete="off"
                    onkeydown="if(event.key==='Enter')loginApp()"
                    style="width:100%;padding:12px 16px;background:rgba(0,0,0,0.08);border:1px solid rgba(0,0,0,0.2);border-radius:14px;color:#111;font-size:14px;font-family:inherit;outline:none;box-sizing:border-box;">
            </div>
            <div id="loginError" style="color:#ef4444;font-size:12px;margin-bottom:10px;display:none;">Usuario o contraseña incorrectos</div>
            <button class="btn-5x-access anim-click" id="authWallBtn" onclick="loginApp()">
                ENTRAR
            </button>
            <div class="auth-wall-checking" id="authWallStatus" style="display:none;">
                Verificando acceso...
            </div>
        </div>
        <div class="auth-wall-version">5X V25.32</div>
    </div>
    <!-- ════════════════════════════════════════════════ -->

    <div class="content-spacer">
        <div id="section-operate" class="app-section active">
            <!-- Sistema de 3 Paneles Deslizables -->
            <div class="panels-wrapper">
                <div class="panels-container" id="panelsContainer" data-active="0">
                    
                    <!-- PANEL 0 (DEFAULT): CHART + RADAR + GATE.IO -->
                    <div class="panel" id="panel1">
                        <div class="panel-number">1</div>
                        <div class="panel-content" style="padding: 4px; overflow-y: auto;">
                            <!-- Temporalidades -->
                            <div class="tf-bar" id="tfBarContainer">
                                <button class="tf-btn anim-click" data-tf="15" onclick="updateTF('15', this)">15M</button><button class="tf-btn anim-click" data-tf="30" onclick="updateTF('30', this)">30M</button><button class="tf-btn anim-click" data-tf="60" onclick="updateTF('60', this)">1H</button><button class="tf-btn anim-click" data-tf="240" onclick="updateTF('240', this)">4H</button><button class="tf-btn anim-click" data-tf="D" onclick="updateTF('D', this)">1D</button>
                            </div>
                            <!-- Chart de Velas -->
                            <div id="tv_chart" class="chart-wrapper" style="margin: 6px 4px;">
                                <div id="priceLinesOverlay" class="price-lines-overlay"></div>
                                <div class="chart-fs-btn anim-click" onclick="toggleFullscreenChart(event)">
                                    <svg width="18" height="18" viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
                                </div>
                            </div>
                            <!-- Radar -->
                            <div style="padding: 0 4px 8px 4px;">
                                <div id="radarTickerContainer" class="radar-ticker-large anim-pulse">
                                    <div id="radarStatus" class="radar-status-dot offline"></div>
                                    <div class="radar-header-line">
                                        <div class="radar-title-compact" onclick="switchView('etf'); event.stopPropagation();" style="cursor: pointer;">
                                            <svg width="16" height="16" viewBox="0 0 24 24"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>
                                            RADAR
                                        </div>
                                        <div id="radarValue" class="radar-token-centered"><span class="skeleton-text skeleton-box" style="width:80px; height:18px;"></span></div>
                                        <div class="radar-balance-compact" id="totalBalanceDisplay" style="display:none;"></div>
                                    </div>
                                </div>
                                <div id="desktop-etf-list"></div>
                            </div>

                            <!-- ── GATE.IO COMMAND DASHBOARD ── -->
                            <div style="padding: 0 4px 80px 4px;">

                                <!-- HEADER DE CONEXIÓN -->
                                <div class="gd-header">
                                    <div style="display:flex; align-items:center; gap:8px;">
                                        <div class="gd-conn-dot" id="gdConnDot"></div>
                                        <span class="gd-brand">GATE.IO</span>
                                        <span class="gd-conn-label" id="gdConnLabel">DESCONECTADO</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px;">
                                        <span class="gd-update-time" id="gdUpdateTime">--:--:--</span>
                                        <button class="gd-refresh-btn anim-click" onclick="refreshGateDashboard()">
                                            <svg width="14" height="14" viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                                        </button>
                                    </div>
                                </div>

                                <!-- MÉTRICAS PRINCIPALES -->
                                <div class="gd-metrics-grid">
                                    <div class="gd-metric-card">
                                        <span class="gd-metric-label">TOTAL WALLET</span>
                                        <span class="gd-metric-value" id="gdTotal">$0.00</span>
                                        <span class="gd-metric-sub" id="gdTotalBTC">todos los activos</span>
                                    </div>
                                    <div class="gd-metric-card">
                                        <span class="gd-metric-label">USDT LIBRE</span>
                                        <span class="gd-metric-value" style="color:var(--long)" id="gdLibre">$0.00</span>
                                        <span class="gd-metric-sub" id="gdLibrePct">0% disponible</span>
                                    </div>
                                    <div class="gd-metric-card">
                                        <span class="gd-metric-label">EN OPERACIÓN</span>
                                        <span class="gd-metric-value" style="color:var(--warning)" id="gdEnUso">$0.00</span>
                                        <span class="gd-metric-sub" id="gdSlotCount">0 slots activos</span>
                                    </div>
                                </div>
                                <!-- PNL HOY · PNL TOTAL · MERCADO LIVE -->
                                <div class="gd-metrics-grid">
                                    <div class="gd-metric-card">
                                        <span class="gd-metric-label">PNL HOY</span>
                                        <span class="gd-metric-value" id="gdPnlHoy">$0.00</span>
                                        <span class="gd-metric-sub">sesión actual</span>
                                    </div>
                                    <div class="gd-metric-card">
                                        <span class="gd-metric-label">PNL TOTAL</span>
                                        <span class="gd-metric-value" id="gdPnlTotal">$0.00</span>
                                        <span class="gd-metric-sub">acumulado</span>
                                    </div>
                                    <div class="gd-metric-card" id="gdMarketCard">
                                        <span class="gd-metric-label">PNL ABIERTO</span>
                                        <span class="gd-metric-value" id="gdPnlOpen" style="color:var(--long)">$0.00</span>
                                        <span class="gd-metric-sub" id="gdPnlOpenSub">posiciones abiertas</span>
                                    </div>
                                </div>

                                <!-- PORTAFOLIO 5X — barra rotatoria -->
                                <div class="gd-portfolio-bar">
                                    <span class="gd-dual-label">PORTAFOLIO 5X</span>
                                    <div class="gd-dual-scroll-wrap">
                                        <div class="gd-dual-track" id="gdPortfolioTrack"></div>
                                    </div>
                                    <div class="gd-dual-dots" id="gdPortfolioDots"></div>
                                </div>

                            </div>
                        </div>
                    </div>
                    
                    <!-- PANEL 1: 5 DASHBOARDS DE TRADING -->
                    <div class="panel" id="panel0">
                        <div class="panel-number">2</div>
                        <!-- Inputs ocultos requeridos por JS -->
                        <input type="text" id="coinInput" style="display: none;" readonly>
                        <input type="number" id="capitalInput" style="display: none;">
                        <input type="number" id="baseInput" style="display: none;">
                        <!-- Indicador de ajuste automático de precio -->
                        <div id="priceAdjustIndicator" style="display:none; position:fixed; bottom:calc(72px + var(--safe-bottom)); right:10px; background:rgba(245,158,11,0.15); border:1px solid var(--warning); border-radius:8px; padding:4px 8px; font-size:9px; font-family:var(--font-head); color:var(--warning); z-index:100;">📉 PRECIO AJUSTADO</div>
                        <div class="panel-content" style="padding: 4px; overflow-y: auto;">
                            <div id="dashboardsContainer"></div>
                        </div>
                    </div>
                    
                    <!-- PANEL 2: CHART SECUNDARIO + 12 NIVELES -->
                    <div class="panel" id="panel5">
                        <div class="panel-number">3</div>
                        <div class="panel-content" style="padding: 4px; overflow-y: auto; -webkit-overflow-scrolling: touch; padding-bottom: 16px;">
                            <!-- ══ BARRA PANEL 3: ACTIVO | MODO | PNL ══ -->
                            <div class="p3-header-bar">
                                <div class="p3-coin-zone">
                                    <span class="p3-lbl">ACTIVO</span>
                                    <span class="p3-val p3-coin-name" id="levelsPanelCoinLabel">---</span>
                                </div>
                                <div class="p3-mode-btn" id="levelsPanelModeBtn"
                                    ontouchstart="startTradingPress(event)" ontouchend="cancelTradingPress(event)"
                                    onmousedown="startTradingPress(event)"  onmouseup="cancelTradingPress(event)"
                                    onmouseleave="cancelTradingPress(event)">
                                    <div class="p3-mode-row">
                                        <svg width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                                        <span class="p3-mode-text" id="levelsPanelModeText">MANUAL</span>
                                    </div>
                                    <span class="p3-mode-sub" id="levelsPanelModeIndicator">MANTÉN 2s</span>
                                </div>
                                <div class="p3-pnl-zone">
                                    <span class="p3-lbl" style="text-align:right;">PNL $</span>
                                    <span class="p3-pnl-dol" id="levelsPanelPnlDol">—</span>
                                </div>
                            </div>
                            <!-- Temporalidades del Chart Secundario -->
                            <div class="tf-bar" id="tfBarContainer2">
                                <button class="tf-btn anim-click" data-tf="15" onclick="updateTF('15', this)">15M</button><button class="tf-btn anim-click" data-tf="30" onclick="updateTF('30', this)">30M</button><button class="tf-btn anim-click" data-tf="60" onclick="updateTF('60', this)">1H</button><button class="tf-btn anim-click" data-tf="240" onclick="updateTF('240', this)">4H</button><button class="tf-btn anim-click" data-tf="D" onclick="updateTF('D', this)">1D</button>
                            </div>
                            <div id="tv_chart2" class="chart-wrapper">
                                <div id="priceLinesOverlay2" class="price-lines-overlay"></div>
                                <div class="chart-fs-btn anim-click" onclick="toggleFullscreenChart2(event)">
                                    <svg width="18" height="18" viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
                                </div>
                            </div>
                            <!-- 12 NIVELES DE TRADING - siempre visibles debajo del chart -->
                            <main id="levelsGrid" class="levels-container"></main>
                        </div>
                    </div>
                    
                </div>
            </div>
            
            <!-- panel-indicators eliminados -->
            <!-- Panel Navigation Dots (mobile/tablet) -->
            <div class="panel-nav-dots" id="panelNavDots" aria-hidden="true">
                <div class="pnd active" id="pnd0"></div>
                <div class="pnd" id="pnd1"></div>
                <div class="pnd" id="pnd2"></div>
            </div>
            <!-- Panel Arrow Buttons (tablet) -->
            <button class="panel-arrow left hidden" id="panelArrowLeft" onclick="switchPanel(currentPanel-1)" aria-label="Panel anterior">
                <svg width="16" height="16" viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </button>
            <button class="panel-arrow right" id="panelArrowRight" onclick="switchPanel(currentPanel+1)" aria-label="Siguiente panel">
                <svg width="16" height="16" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </button>
        </div>
        <div id="section-etf" class="app-section">
            <!-- Barra de contexto de mercado -->
            <div class="etf-market-bar" id="etfMarketBar" style="margin-top:0;">
                <div class="etf-mkt-pill" id="mktBtcPill">⏳ Cargando...</div>
            </div>
            <!-- Tabs -->
            <div class="etf-tabs">
                <button class="etf-tab active" onclick="switchETFTab('scanner')">🔥 SCANNER</button>
                <button class="etf-tab" onclick="switchETFTab('positions')">📍 POSICIONES</button>
                <button class="etf-tab" onclick="switchETFTab('heatmap')">📊 MAPA</button>
                <button class="etf-tab" onclick="switchETFTab('compare')">⚡ 3L vs 5L</button>
            </div>
            <!-- TAB: SCANNER -->
            <div class="etf-tab-content active" id="etfTab-scanner">
                <div class="etf-search-box"><span class="etf-search-icon"><svg width="16" height="16" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></span><input type="text" class="etf-search-input" id="etfSearchInput" placeholder="BUSCAR TOKEN (Ej: BTC, SUI)" oninput="filterETFs(this.value)" onfocus="this.select()"></div>
                <!-- ── FILTROS Y ORDENACIÓN RADAR ── -->
                <div id="radarFilterBar" style="display:flex;gap:6px;padding:6px 0 4px;overflow-x:auto;scrollbar-width:none;-webkit-overflow-scrolling:touch;">
                    <button class="radar-filter-btn" onclick="setRadarSort('score',this)" style="flex-shrink:0;padding:5px 10px;border-radius:20px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;cursor:pointer;">★ SCORE</button>
                    <button class="radar-filter-btn active" onclick="setRadarSort('drop',this)" style="flex-shrink:0;padding:5px 10px;border-radius:20px;border:1px solid var(--brand);background:rgba(59,130,246,.15);color:var(--brand);font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;cursor:pointer;">📉 CAÍDA</button>
                    <button class="radar-filter-btn" onclick="setRadarSort('volume',this)" style="flex-shrink:0;padding:5px 10px;border-radius:20px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;cursor:pointer;">💧 VOLUMEN</button>
                    <button class="radar-filter-btn" onclick="setRadarSort('gain',this)" style="flex-shrink:0;padding:5px 10px;border-radius:20px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;cursor:pointer;">🚀 SUBE</button>
                    <button class="radar-filter-btn" onclick="setRadarSort('lev5',this)" style="flex-shrink:0;padding:5px 10px;border-radius:20px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;cursor:pointer;">⚡ SOLO 5X</button>
                    <button class="radar-filter-btn" onclick="setRadarSort('lev3',this)" style="flex-shrink:0;padding:5px 10px;border-radius:20px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;cursor:pointer;">🔵 SOLO 3X</button>
                    <button class="radar-filter-btn" onclick="setRadarSort('gold',this)" style="flex-shrink:0;padding:5px 10px;border-radius:20px;border:1px solid rgba(245,158,11,.4);background:rgba(245,158,11,.08);color:var(--warning);font-family:var(--font-head);font-size:8px;font-weight:800;letter-spacing:.5px;cursor:pointer;">🏆 GOLD</button>
                </div>
                <div id="etfGrid" class="levels-container"></div>
            </div>
            <!-- TAB: HEATMAP -->
            <div class="etf-tab-content" id="etfTab-heatmap">
                <div class="etf-heatmap-grid" id="etfHeatmapGrid"></div>
            </div>
            <!-- TAB: COMPARAR 3L vs 5L -->
            <div class="etf-tab-content" id="etfTab-compare">
                <div id="etfCompareGrid"></div>
            </div>
            <!-- TAB: POSICIONES ACTIVAS -->
            <div class="etf-tab-content" id="etfTab-positions">
                <div id="etfPositionsGrid" style="padding-bottom:16px;"></div>
            </div>
        </div>

        <!-- MODAL DETALLE ETF -->
        <div id="etfDetailModal" onclick="if(event.target===this)closeETFDetail()">
            <div class="etf-detail-sheet">
                <div class="etf-detail-handle"></div>
                <div class="etf-detail-header">
                    <div>
                        <div class="etf-detail-sym" id="etfDetailSym">BTC5L</div>
                        <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);letter-spacing:1px;margin-top:2px;" id="etfDetailType">ETF APALANCADO 5X</div>
                    </div>
                    <div style="text-align:right;">
                        <span class="etf-detail-price-val" id="etfDetailPrice">$0.000000</span>
                        <span class="etf-detail-change" id="etfDetailChange">+0.00%</span>
                    </div>
                </div>
                <div class="etf-detail-sections" id="etfDetailBody">
                    <!-- Contenido dinámico -->
                </div>
                <div class="etf-detail-actions" id="etfDetailActions">
                    <button class="etf-action-btn" onclick="closeETFDetail()">✕ CERRAR</button>
                    <button class="etf-action-btn primary" id="etfDetailAddBtn" onclick="addCurrentDetailToSlot()" style="background:var(--long);border-color:var(--long);font-size:13px;padding:14px;">⚡ AGREGAR AL DASHBOARD Y OPERAR</button>
                </div>
            </div>

        </div>
        <!-- ══ SECCIÓN SOPORTE ══ -->
        <div id="section-support" class="app-section">
            <div class="setting-section-title">
                <svg width="14" height="14" viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                SOPORTE DIRECTO
            </div>
            <!-- Status conexión -->
            <div style="display:flex;align-items:center;gap:10px;padding:10px 14px;background:rgba(59,130,246,.06);border:1px solid rgba(59,130,246,.2);border-radius:14px;margin:4px 10px 10px;">
                <div style="width:8px;height:8px;border-radius:50%;background:var(--long);animation:pulse-ring 2s infinite;flex-shrink:0;"></div>
                <div>
                    <div style="font-family:var(--font-head);font-size:11px;font-weight:800;color:var(--text-primary);">CHAT CON ADMIN</div>
                    <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);">Sincronizado vía Supabase · Respuesta en horario EC</div>
                </div>
            </div>
            <!-- Chat messages area -->
            <div id="supportMsgs" style="min-height:200px;max-height:55vh;overflow-y:auto;padding:4px 10px;display:flex;flex-direction:column;gap:8px;">
                <div style="text-align:center;padding:30px 20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;line-height:2;">
                    💬 Aquí aparecerán tus mensajes al admin<br>
                    Configura Supabase en AJUSTES para activar el chat
                </div>
            </div>
            <!-- Input area -->
            <div style="position:sticky;bottom:0;background:var(--bg);padding:10px;border-top:1px solid var(--border);">
                <!-- Archivo adjunto seleccionado (preview antes de enviar) -->
                <div id="supportFilePreview" style="display:none;align-items:center;gap:8px;padding:8px 10px;background:rgba(59,130,246,0.08);border:1px solid rgba(59,130,246,0.2);border-radius:10px;margin-bottom:6px;">
                    <span id="supportFilePreviewIcon" style="font-size:18px;">📎</span>
                    <div style="flex:1;min-width:0;">
                        <div id="supportFilePreviewName" style="font-family:var(--font-head);font-size:9px;font-weight:800;color:var(--text-primary);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></div>
                        <div id="supportFilePreviewSize" style="font-family:var(--font-num);font-size:8px;color:var(--text-tertiary);"></div>
                    </div>
                    <button onclick="clearSupportFile()" style="background:none;border:none;color:var(--text-tertiary);cursor:pointer;font-size:16px;padding:2px 4px;">✕</button>
                </div>
                <div style="display:flex;gap:8px;align-items:flex-end;">
                    <input type="file" id="supportFileInput" accept="image/*,.pdf,.doc,.docx" style="display:none" onchange="handleSupportFileSelect(this)">
                    <button class="chat-attach-btn" onclick="document.getElementById('supportFileInput').click()" title="Adjuntar imagen o documento">📎</button>
                    <textarea id="supportMsgInput" placeholder="Escribe tu consulta al admin..." rows="2"
                        style="flex:1;background:var(--surface);border:1px solid var(--border);border-radius:12px;color:var(--text-primary);font-family:var(--font-head);font-size:11px;padding:10px;resize:none;outline:none;line-height:1.5;"></textarea>
                    <button onclick="sendSupportMsg()" style="width:44px;height:44px;border-radius:12px;background:var(--brand);border:none;color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </div>
                <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);margin-top:6px;letter-spacing:.5px;">
                    Los mensajes se guardan en Supabase · El admin te responde desde el panel de administración · 📎 imágenes y PDF admitidos
                </div>
            </div>
            <!-- FAQ rápido -->
            <div class="setting-section-title">
                <svg width="14" height="14" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
                PREGUNTAS FRECUENTES
            </div>
            <div style="padding:0 10px 16px;display:flex;flex-direction:column;gap:6px;">
                <div class="faq-item" onclick="toggleFAQ(this)">
                    <div class="faq-q">¿Cómo funciona la salida en 2 etapas? <span class="faq-arrow">▾</span></div>
                    <div class="faq-a">La estrategia tiene 2 salidas: <strong>TP1 (promedio +50%)</strong> vende el 50% y recuperas capital. El 50% restante activa un <strong>Trailing Stop</strong> cuando llega a promedio +100%: el activo sigue corriendo en ganancias hasta que retrocede un 15% desde su máximo, en ese momento se vende el resto.</div>
                </div>
                <div class="faq-item" onclick="toggleFAQ(this)">
                    <div class="faq-q">¿Qué es el Rebuy y cuándo se activa? <span class="faq-arrow">▾</span></div>
                    <div class="faq-a">El Rebuy abre automáticamente 12 nuevos niveles de compra cuando el precio cae un 16% desde el precio de TP1. Solo ocurre una vez por ciclo, con capital reducido. Es la forma en que la estrategia aprovecha una segunda caída después de ya haber tomado ganancias en TP1.</div>
                </div>
                <div class="faq-item" onclick="toggleFAQ(this)">
                    <div class="faq-q">¿Cuándo activa el Trailing Stop? <span class="faq-arrow">▾</span></div>
                    <div class="faq-a">El trailing se activa únicamente cuando el precio supera TP2. Una vez activo, sigue el máximo y ejecuta la venta si el precio retrocede más del 15% desde ese máximo. Sirve para capturar movimientos fuertes sin salir demasiado pronto.</div>
                </div>
                <div class="faq-item" onclick="toggleFAQ(this)">
                    <div class="faq-q">¿Por qué el bot no compra aunque el precio bajó? <span class="faq-arrow">▾</span></div>
                    <div class="faq-a">El bot compra de forma secuencial — el nivel 2 solo se ejecuta después de que el nivel 1 esté marcado como comprado. Si el trailing stop está activo (precio superó TP2), el bot no abre nuevos niveles para proteger las ganancias. Verifica también que el slot esté en modo AUTO y no pausado.</div>
                </div>
                <div class="faq-item" onclick="toggleFAQ(this)">
                    <div class="faq-q">¿Qué es el Circuit Breaker? <span class="faq-arrow">▾</span></div>
                    <div class="faq-a">Es una protección que pausa el bot 20 minutos si el ETF cae más del 70% desde el precio base sin que se haya ejecutado ningún nivel. Protege contra entrar en un ETF que esté en colapso total por riesgo de delisting o rebalanceo forzado.</div>
                </div>
                <div class="faq-item" onclick="toggleFAQ(this)">
                    <div class="faq-q">¿Por qué el ETF 3S/5S cae cuando el spot sube? <span class="faq-arrow">▾</span></div>
                    <div class="faq-a">Los ETF short (3S, 5S) tienen relación inversa con el spot: cuando el spot SUBE, el ETF short BAJA. La estrategia los usa cuando el mercado ha subido mucho (BTC pump), lo que los deja muy baratos — si luego el spot corrige, el ETF short se recupera con fuerza x apalancamiento. No son para hold largo por el decay diario.</div>
                </div>
                <div class="faq-item" onclick="toggleFAQ(this)">
                    <div class="faq-q">¿Cómo influye el contexto de BTC en el bot? <span class="faq-arrow">▾</span></div>
                    <div class="faq-a">Si BTC/ETH confirman la dirección del ETF, el bot aumenta el capital en niveles profundos hasta un +30%. Si el mercado va en contra, reduce el capital un 20%. Esto hace que el bot sea más agresivo cuando el contexto apoya la operación y más conservador cuando hay señales contradictorias.</div>
                </div>
            </div>
        </div>

        <!-- ══ SECCIÓN ESTRATEGIA ══ -->
        <div id="section-strategy" class="app-section">
            <div style="padding:10px 10px 16px;">
                <div class="setting-section-title">
                    <svg width="14" height="14" viewBox="0 0 24 24"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                    ESTRATEGIA 5X — ETF LEVERAGE
                </div>
                <!-- BASE -->
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:16px;margin:4px 0 10px;">
                    <div style="font-family:var(--font-head);font-size:11px;font-weight:900;color:var(--brand);letter-spacing:1px;margin-bottom:10px;">¿EN QUÉ SE BASA?</div>
                    <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:2;">
                        Los ETF apalancados de Gate.io (3L, 5L, 3S, 5S) tienen <strong style="color:var(--text-primary)">volatilidad extrema</strong> — pueden moverse 40–60% en un solo día.
                        Esta estrategia convierte esa volatilidad en oportunidad usando <strong style="color:var(--text-primary)">DCA secuencial</strong>:
                        compramos en caídas escalonadas y vendemos cuando recupera en dos etapas automáticas.
                    </div>
                </div>

                <!-- PASO A PASO -->
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:10px;">
                    <div style="font-family:var(--font-head);font-size:11px;font-weight:900;color:var(--warning);letter-spacing:1px;margin-bottom:10px;">CÓMO FUNCIONA — PASO A PASO</div>
                    <div style="display:flex;flex-direction:column;gap:10px;">
                        <div style="display:flex;gap:12px;align-items:flex-start;">
                            <div style="width:26px;height:26px;border-radius:50%;background:var(--brand);color:#fff;font-family:var(--font-head);font-size:11px;font-weight:900;display:flex;align-items:center;justify-content:center;flex-shrink:0;">1</div>
                            <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:1.8;"><strong style="color:var(--text-primary);">IDENTIFICAR</strong> un ETF que haya caído significativamente. El Scanner ordena por score de oportunidad y muestra cuánto cayó en 24h.</div>
                        </div>
                        <div style="display:flex;gap:12px;align-items:flex-start;">
                            <div style="width:26px;height:26px;border-radius:50%;background:var(--brand);color:#fff;font-family:var(--font-head);font-size:11px;font-weight:900;display:flex;align-items:center;justify-content:center;flex-shrink:0;">2</div>
                            <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:1.8;"><strong style="color:var(--text-primary);">ENTRAR en N1</strong> al precio actual. El sistema calcula 12 niveles de compra adicional. Cada nivel es más barato: N2 = N1 −16%, N3 = N2 −22%, N4 = N3 −28%... (paso inicial + 6% por nivel).</div>
                        </div>
                        <div style="display:flex;gap:12px;align-items:flex-start;">
                            <div style="width:26px;height:26px;border-radius:50%;background:var(--brand);color:#fff;font-family:var(--font-head);font-size:11px;font-weight:900;display:flex;align-items:center;justify-content:center;flex-shrink:0;">3</div>
                            <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:1.8;"><strong style="color:var(--text-primary);">DCA PROGRESIVO</strong>: el capital aumenta por nivel. N1–N4 conservador · N5–N8 moderado · N9–N12 agresivo. En N5–N10 puedes hacer compras adicionales de promedio tocando el nivel en cualquier momento.</div>
                        </div>
                        <div style="display:flex;gap:12px;align-items:flex-start;">
                            <div style="width:26px;height:26px;border-radius:50%;background:var(--long);color:#fff;font-family:var(--font-head);font-size:11px;font-weight:900;display:flex;align-items:center;justify-content:center;flex-shrink:0;">4</div>
                            <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:1.8;">
                                <strong style="color:var(--long);">SALIDA EN 2 ETAPAS (automática):</strong><br>
                                🟢 <strong style="color:var(--long);">TP1 — avg +50%</strong>: vende el 50% de la posición automáticamente.<br>
                                📈 <strong style="color:var(--brand);">TRAILING — activa desde precio TP1 +100%</strong>: el 50% restante se deja correr sin tope al alza. Cuando el precio retrocede −15% desde su máximo histórico, vende el resto automáticamente.<br>
                                🔄 <strong style="color:var(--warning);">REBUY — si el precio cae −16% desde el precio de venta TP1</strong>: reabre 12 niveles desde ese precio y acumula el 50% restante al nuevo promedio. Se repite hasta <strong style="color:var(--warning);">3 veces por operación</strong>. El 4° ciclo = venta final del trailing stop.
                            </div>
                        </div>
                        <div style="display:flex;gap:12px;align-items:flex-start;">
                            <div style="width:26px;height:26px;border-radius:50%;background:var(--text-tertiary);color:#fff;font-family:var(--font-head);font-size:11px;font-weight:900;display:flex;align-items:center;justify-content:center;flex-shrink:0;">5</div>
                            <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:1.8;"><strong style="color:var(--text-primary);">VENTA A MERCADO</strong>: si quieres salir inmediatamente, el botón de venta cierra el 100% de la posición al precio actual, saltándose TP1 y trailing.</div>
                        </div>
                    </div>
                </div>

                <!-- DIAGRAMA DE FLUJO REBUY -->
                <div style="background:rgba(245,158,11,.06);border:1px solid rgba(245,158,11,.28);border-radius:14px;padding:14px;margin-bottom:10px;">
                    <div style="font-family:var(--font-head);font-size:10px;font-weight:900;color:var(--warning);margin-bottom:10px;letter-spacing:.5px;">🔄 CICLO COMPLETO — FLUJO REBUY (hasta 3×)</div>
                    <div style="font-family:var(--font-num);font-size:9px;color:var(--text-secondary);line-height:2.2;background:rgba(0,0,0,.25);border-radius:10px;padding:10px;">
                        PRECIO SUBE desde promedio<br>
                        &nbsp;&nbsp;│<br>
                        &nbsp;&nbsp;▼ avg × 1.50 <span style="color:var(--long)">(TP1 +50%)</span><br>
                        &nbsp;&nbsp;┌─────────────────────────────┐<br>
                        &nbsp;&nbsp;│ TP1 AUTO → vende 50% · Ciclo 1/3│<br>
                        &nbsp;&nbsp;└─────────────────────────────┘<br>
                        &nbsp;&nbsp;│ 50% restante sigue corriendo<br>
                        &nbsp;&nbsp;▼ precio TP1 × 2.00 <span style="color:var(--brand)">(TRAILING activa)</span><br>
                        &nbsp;&nbsp;│ Trailing sigue el máximo sin tope<br>
                        &nbsp;&nbsp;▼ máximo × 0.85 <span style="color:var(--short)">(−15% stop)</span><br>
                        &nbsp;&nbsp;→ Si AÚN NO llegó al stop → <span style="color:var(--warning)">REBUY</span> si cae −16% desde TP1<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;→ Abre 12 niveles · acumula 50% al nuevo promedio<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;→ TP1 se puede volver a ejecutar (Ciclo 2/3 · 3/3)<br>
                        &nbsp;&nbsp;▼ Ciclo 3 completo → trailing final → <span style="color:var(--long)">VENTA TOTAL</span>
                    </div>
                </div>

                <!-- MODOS: MANUAL vs AUTO -->
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:10px;">
                    <div style="font-family:var(--font-head);font-size:11px;font-weight:900;color:var(--brand);letter-spacing:1px;margin-bottom:10px;">📱 MANUAL vs 🤖 AUTO</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <div style="background:rgba(59,130,246,.06);border:1px solid rgba(59,130,246,.2);border-radius:10px;padding:10px;">
                            <div style="font-family:var(--font-head);font-size:9px;font-weight:900;color:var(--brand);margin-bottom:6px;">📱 MODO MANUAL</div>
                            <div style="font-family:var(--font-head);font-size:8.5px;color:var(--text-secondary);line-height:1.9;">
                                • Tú decides cuándo entrar en cada nivel<br>
                                • TP1, Trailing y Rebuy se ejecutan solos<br>
                                • Puedes promediar manualmente en cualquier nivel<br>
                                • Botón de venta = salida inmediata a mercado
                            </div>
                        </div>
                        <div style="background:rgba(16,185,129,.06);border:1px solid rgba(16,185,129,.2);border-radius:10px;padding:10px;">
                            <div style="font-family:var(--font-head);font-size:9px;font-weight:900;color:var(--long);margin-bottom:6px;">🤖 MODO AUTO</div>
                            <div style="font-family:var(--font-head);font-size:8.5px;color:var(--text-secondary);line-height:1.9;">
                                • El bot entra en cada nivel automáticamente<br>
                                • Aceleración a 2s/ciclo en crash (&gt;8%/2min)<br>
                                • Compras múltiples niveles si precio cae de golpe<br>
                                • Tú PUEDES tocar cualquier nivel para promediar<br>
                                • TP1, Trailing y Rebuy ×3 se ejecutan solos
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ETF SHORT -->
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:10px;">
                    <div style="font-family:var(--font-head);font-size:11px;font-weight:900;color:var(--short);letter-spacing:1px;margin-bottom:10px;">ETF SHORT 3S / 5S</div>
                    <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:2;">
                        Los ETF cortos (3S=3× short, 5S=5× short) <strong style="color:var(--short);">suben cuando el spot baja</strong> y caen cuando el spot sube.<br>
                        Estrategia: cuando el mercado ha subido fuertemente (BTC pump), los 3S/5S han caído mucho — <strong style="color:var(--long);">ese es el momento de entrada</strong>.<br><br>
                        <strong style="color:var(--warning);">⚠️ DECAY DIARIO:</strong> Los ETF apalancados pierden valor por rebalanceo diario (00:00 UTC ± 35 min el bot pausa compras). No son para hold largo plazo — la estrategia busca salida rápida en días.
                    </div>
                </div>

                <!-- GESTIÓN DE RIESGO -->
                <div style="background:rgba(239,68,68,.05);border:1px solid rgba(239,68,68,.2);border-radius:14px;padding:14px;margin-bottom:10px;">
                    <div style="font-family:var(--font-head);font-size:10px;font-weight:900;color:var(--short);margin-bottom:8px;">⚠️ GESTIÓN DE RIESGO</div>
                    <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);line-height:2;">
                        • Hasta 10 slots activos simultáneos<br>
                        • Capital pequeño en N1–N4, grande en N9–N12 (cuando el ETF está muy bajo)<br>
                        • Nunca entres con todo en N1 — el ETF puede seguir cayendo 30% más<br>
                        • El decay diario es real: prefiere entradas en alta volatilidad<br>
                        • TP1 primero → recuperas el capital base; el trailing corre con la ganancia<br>
                        • Rebuy ×3 baja el promedio agresivamente — cada ciclo acumula el 50% anterior
                    </div>
                </div>

                <!-- PARÁMETROS ACTUALES -->
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:14px;margin-bottom:16px;">
                    <div style="font-family:var(--font-head);font-size:10px;font-weight:900;color:var(--text-primary);margin-bottom:8px;">⚙️ PARÁMETROS ACTIVOS AHORA</div>
                    <div id="strategyCurrentParams" style="font-family:var(--font-num);font-size:10.5px;color:var(--text-secondary);line-height:2.2;">Cargando...</div>
                </div>
            </div>
        </div>

        <!-- ════════════════════ BOT LIVE DASHBOARD ════════════════════ -->
        <div id="section-botdash" class="app-section">
            <!-- Header -->
            <div style="display:flex;align-items:center;justify-content:space-between;padding:4px 0 10px;">
                <div style="font-family:var(--font-head);font-size:16px;font-weight:900;letter-spacing:2px;color:var(--text-primary);">BOT <span style="color:var(--brand);">LIVE</span></div>
                <div style="display:flex;gap:6px;">
                    <button onclick="pauseAllSlots()" style="padding:6px 12px;border-radius:10px;border:1px solid var(--warning);background:rgba(245,158,11,.1);color:var(--warning);font-family:var(--font-head);font-size:9px;font-weight:800;cursor:pointer;">⏸ PAUSAR TODO</button>
                    <button onclick="refreshBotDash()" style="padding:6px 12px;border-radius:10px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;font-weight:800;cursor:pointer;">↺</button>
                </div>
            </div>
            <!-- Stats globales -->
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:5px;margin-bottom:8px;" id="botDashGlobalStats">
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px;text-align:center;">
                    <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">SLOTS ACTIVOS</div>
                    <div id="bdStatSlots" style="font-family:var(--font-num);font-size:20px;font-weight:800;color:var(--brand);">0/5</div>
                </div>
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px;text-align:center;">
                    <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">PnL TOTAL VIVO</div>
                    <div id="bdStatPnl" style="font-family:var(--font-num);font-size:18px;font-weight:800;color:var(--long);">$0.00</div>
                </div>
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px;text-align:center;">
                    <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">CAPITAL DESPLEG.</div>
                    <div id="bdStatCap" style="font-family:var(--font-num);font-size:18px;font-weight:800;color:var(--text-primary);">$0</div>
                </div>
            </div>
            <!-- Cards por slot -->
            <div id="botDashSlots" style="display:flex;flex-direction:column;gap:6px;margin-bottom:12px;"></div>
            <!-- Log del bot mejorado -->
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                <div style="font-family:var(--font-head);font-size:10px;font-weight:800;color:var(--text-primary);letter-spacing:.5px;">📋 LOG DE DECISIONES</div>
                <button onclick="clearBotLog()" style="padding:4px 8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:8px;cursor:pointer;">LIMPIAR</button>
            </div>
            <div id="botDashLog" style="background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:10px;max-height:260px;overflow-y:auto;scrollbar-width:none;font-family:monospace;font-size:9px;line-height:1.8;color:var(--text-secondary);"></div>
            <!-- Backtester -->
            <div style="margin-top:14px;background:var(--surface);border:1px solid var(--border);border-radius:16px;padding:14px;">
                <div style="font-family:var(--font-head);font-size:11px;font-weight:900;color:var(--text-primary);letter-spacing:1px;margin-bottom:10px;">🔬 SIMULADOR BACKTESTING</div>
                <div style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;">
                    <select id="btCoin" style="flex:1;min-width:100px;background:var(--bg);border:1px solid var(--border);border-radius:10px;color:var(--text-primary);font-family:var(--font-head);font-size:10px;padding:8px;outline:none;">
                        <option>BTC5L</option><option>BTC3L</option><option>ETH5L</option><option>ETH3L</option>
                        <option>SOL5L</option><option>SOL3L</option><option>SUI5L</option><option>SUI3L</option>
                        <option>BNB5L</option><option>AVAX5L</option>
                    </select>
                    <select id="btPeriod" style="flex:1;min-width:80px;background:var(--bg);border:1px solid var(--border);border-radius:10px;color:var(--text-primary);font-family:var(--font-head);font-size:10px;padding:8px;outline:none;">
                        <option value="1440">24h</option><option value="4320">3 días</option><option value="10080">7 días</option>
                    </select>
                    <button onclick="runBacktest()" style="padding:8px 14px;border-radius:10px;border:none;background:var(--brand);color:#fff;font-family:var(--font-head);font-size:10px;font-weight:800;cursor:pointer;">▶ SIMULAR</button>
                </div>
                <div id="btResult" style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);text-align:center;padding:10px;">Selecciona ETF y período, luego presiona SIMULAR</div>
            </div>
        </div>

        <div id="section-log" class="app-section">
            <div class="log-header-bar">
                <div class="log-title">BITÁCORA</div>
                <div class="log-actions">
                    <button class="action-btn anim-click" onclick="exportPDF()"><svg width="14" height="14" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg> REPORTE</button>
                    <button class="action-btn anim-click" onclick="triggerDriveBackup()"><svg width="14" height="14" viewBox="0 0 24 24"><path d="M19 18a3.5 3.5 0 0 0 0-7h-1A5 4.5 0 0 0 8 9a4.5 4.5 0 0 0-4.5 4.5c0 .4.04.79.12 1.16"></path></svg> RESPALDO</button>
                    <button class="action-btn anim-click" style="color:var(--danger); border-color:var(--danger)" onclick="clearLogs()"><svg width="14" height="14" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg> BORRAR</button>
                </div>
            </div>
            <!-- Stats rápidas en cards horizontales -->
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:5px;padding:0 0 8px;">
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px 6px;text-align:center;">
                    <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">OPERACIONES</div>
                    <div id="statTotalOps" style="font-family:var(--font-num);font-size:18px;font-weight:800;color:var(--text-primary);">0</div>
                </div>
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px 6px;text-align:center;">
                    <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">WIN RATE</div>
                    <div id="statWinRate" style="font-family:var(--font-num);font-size:18px;font-weight:800;color:var(--long);">0%</div>
                </div>
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px 6px;text-align:center;">
                    <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">MEJOR OP</div>
                    <div id="statBestOp" style="font-family:var(--font-num);font-size:15px;font-weight:800;color:var(--long);">+$0</div>
                </div>
                <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px 6px;text-align:center;">
                    <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">NET TOTAL</div>
                    <div id="statNetTotal" style="font-family:var(--font-num);font-size:15px;font-weight:800;color:var(--text-primary);">$0</div>
                </div>
            </div>
            <div class="stats-card anim-click">
                <div class="stats-header"><div class="stats-title">RENDIMIENTO</div><div class="stats-toggles"><button class="stat-btn active" onclick="updateStats('D')">1D</button><button class="stat-btn" onclick="updateStats('W')">1S</button><button class="stat-btn" onclick="updateStats('M')">1M</button><button class="stat-btn" onclick="updateStats('A')">TODO</button></div></div>
                <div class="chart-box" id="pnlChart"></div>
                <div class="stats-summary"><div><span class="sum-label">NETO (FEES INC.)</span><span class="sum-val" id="chartNeto">$0.00</span></div><div><span class="sum-label">WIN RATE</span><span class="sum-val" id="chartWr">0%</span></div></div>
            </div>
            <!-- Coin más operado -->
            <div id="topCoinBar" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:10px 14px;margin-bottom:8px;align-items:center;justify-content:space-between;">
                <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);">🏆 COIN MÁS OPERADO</div>
                <div id="topCoinName" style="font-family:var(--font-head);font-size:13px;font-weight:900;color:var(--brand);">—</div>
                <div id="topCoinPnl" style="font-family:var(--font-num);font-size:12px;font-weight:800;color:var(--long);">$0.00</div>
            </div>
            <div id="logGrid" class="levels-container"></div>
        </div>
        <div id="section-settings" class="app-section">
            <!-- ── NOTIFICACIONES ── -->
            <div class="setting-section-title">
                <svg width="14" height="14" viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>
                NOTIFICACIONES
            </div>
            <div class="settings-grid" style="margin-bottom:10px;">
                <div class="setting-card-item" style="padding:12px 16px;">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; overflow:hidden;">
                        <div style="display:flex; align-items:center; gap:10px; min-width:0; flex:1;">
                            <div class="notif-status-dot" id="notifStatusDot" style="flex-shrink:0;"></div>
                            <div id="notifStatusLabel" style="font-family:var(--font-head); font-size:10px; font-weight:800; color:var(--text-tertiary); letter-spacing:1px; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">VERIFICANDO...</div>
                        </div>
                        <div style="display:flex; gap:6px; align-items:center; flex-shrink:0;">
                            <button id="notifSettingsBtn" class="btn-save-mini anim-click" onclick="handleNotifSettingsBtn()" style="font-size:9px; padding:6px 12px; display:none;">PROBAR</button>
                            <button id="notifOpenSettingsBtn" class="btn-save-mini anim-click" onclick="showToast('⚙️ Ajustes del móvil → Aplicaciones → 5X → Notificaciones', 5000)" style="font-size:9px; padding:6px 12px; display:none; background:transparent; border:1px solid var(--short); color:var(--short);">IR A AJUSTES</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- ── SUPABASE SYNC ── -->
            <!-- FIX: sección siempre visible y claramente marcada como OPCIONAL.
                 La app funciona 100% sin Supabase usando localStorage.
                 Supabase es configurado por el administrador — los usuarios se sincronizan automáticamente. -->

            <!-- ══ SYNC EN LA NUBE — VISIBLE PARA TODOS (solo estado) ══ -->
            <div class="setting-section-title">
                <svg width="14" height="14" viewBox="0 0 24 24"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>
                SYNC EN LA NUBE
                <span style="font-size:8px;color:var(--brand);margin-left:4px;">SUPABASE</span>
            </div>

            <!-- Pill de estado: lo ven TODOS los usuarios (solo lectura) -->
            <div class="settings-grid" style="margin-bottom:4px;">
                <div class="setting-card-item" style="padding:12px 16px;">
                    <div class="sb-status-row" style="margin-bottom:0;">
                        <div class="sb-dot" id="sbStatusDot"></div>
                        <span class="sb-status-text" id="sbStatusText">Sin conexión a la nube</span>
                        <span class="sb-status-tag offline" id="sbStatusTag">LOCAL</span>
                    </div>
                </div>
            </div>

            <!-- ══ CONFIGURACIÓN SUPABASE — solo admin ══
                 El usuario normal jamás ve URL ni ANON KEY.
                 El admin configura una vez y todos se sincronizan. -->
            <div class="setting-section-title admin-only" style="border-left:3px solid var(--brand);padding-left:8px;margin-top:2px;">
                <svg width="14" height="14" viewBox="0 0 24 24"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>
                CONFIGURAR SUPABASE <span style="font-size:8px;color:var(--brand);margin-left:4px;">★ ADMIN</span>
            </div>
            <div class="settings-grid admin-only-grid" style="margin-bottom:10px;">
                <div class="setting-card-item">
                    <div style="margin-bottom:10px;padding:8px 12px;background:rgba(59,130,246,0.06);border:1px solid rgba(59,130,246,0.18);border-radius:10px;font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);line-height:1.75;">
                        ☁️ Tú conectas Supabase una sola vez. Los usuarios autorizados se sincronizan automáticamente sin configurar nada.
                    </div>
                    <div style="display:flex;flex-direction:column;gap:8px;">
                        <div><label class="setting-label" style="display:block;margin-bottom:4px;">PROJECT URL</label>
                        <input type="text" class="setting-input" id="sbUrlInput" placeholder="https://xxxx.supabase.co" style="font-size:11px;"></div>
                        <div><label class="setting-label" style="display:block;margin-bottom:4px;">ANON KEY</label>
                        <input type="password" class="setting-input" id="sbKeyInput" placeholder="eyJhbGci..."></div>
                    </div>
                    <div style="display:flex;gap:8px;margin-top:10px;">
                        <button class="btn-save-mini anim-click" onclick="saveSupabaseConfig()" style="flex:1;background:var(--brand);color:#fff;">💾 GUARDAR</button>
                        <button class="btn-save-mini anim-click" onclick="testSupabaseConnection()" style="flex:1;">🔌 PROBAR</button>
                    </div>
                    <div id="sbTestResult" style="display:none;margin-top:8px;font-family:monospace;font-size:10px;padding:8px;background:rgba(0,0,0,.2);border-radius:8px;color:var(--text-secondary);"></div>
                </div>
            </div>

            <!-- ════ API GATE.IO — visible para todos los usuarios ════ -->
            <div class="setting-section-title"><svg width="14" height="14" viewBox="0 0 24 24"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg> API GATE.IO — MIS CREDENCIALES</div>
            <div class="settings-grid">
                <div class="setting-card-item">
                    <div class="input-row-save" style="margin-bottom:10px; justify-content:space-between;"><span class="setting-label">CREDENCIALES API</span><button class="btn-save-mini anim-click" onclick="saveApiKeysSecure()"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button></div>
                    <div style="display:flex; flex-direction:column; gap:10px"><input type="password" class="setting-input" id="apiKey" placeholder="API KEY (KEY)" style="border-bottom:1px solid var(--border)"><input type="password" class="setting-input" id="apiSecret" placeholder="API SECRET (SECRET)"></div>
                    <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);margin-top:8px;line-height:1.7;">
                        🔐 Tus keys se guardan encriptadas solo en este dispositivo
                    </div>
                </div>
                <div class="setting-card-item">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:10px; overflow:hidden;"><span class="setting-label" style="flex:1;min-width:0;">🔧 PRUEBA DE CONEXIÓN</span><div style="display:flex;gap:6px;flex-shrink:0;"><button class="btn-save-mini anim-click" onclick="testApiConnection()" style="background:var(--brand); color:#fff;">PROBAR</button></div></div>
                    <div id="apiTestResult" style="font-size:11px; color:var(--text-tertiary); padding:8px; background:rgba(0,0,0,0.2); border-radius:8px; font-family:monospace; max-height:120px; overflow-y:auto;">Presiona PROBAR para verificar conexión</div>
                </div>
            </div>
            <!-- ════ PROXY & DIAGNÓSTICO — solo admin ════ -->
            <div class="setting-section-title admin-only" style="border-left:3px solid var(--brand); padding-left:8px;">
                <svg width="14" height="14" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                PROXY & DIAGNÓSTICO <span style="font-size:8px; color:var(--brand); margin-left:4px;">★ ADMIN</span>
            </div>
            <div class="settings-grid admin-only-grid">
                <div class="setting-card-item">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                        <span class="setting-label">🔌 SUPABASE EDGE FUNCTION</span>
                        <button class="btn-save-mini anim-click" onclick="saveProxyUrl()" style="background:var(--brand);color:#fff;">💾</button>
                    </div>
                    <input type="text" class="setting-input" id="proxyUrlInput" placeholder="https://xxxx.supabase.co/functions/v1/gate-proxy" style="font-size:10px;margin-bottom:8px;" onchange="localStorage.setItem('c5x_proxy_url',this.value.trim());GATE_PROXY_URL=this.value.trim()||GATE_PROXY_URL;showToast('💾 Proxy URL guardada')">
                    <details style="margin-top:8px;">
                        <summary style="font-family:var(--font-head);font-size:9px;color:var(--brand);cursor:pointer;letter-spacing:.5px;">📋 CÓDIGO EDGE FUNCTION (copiar)</summary>
                        <pre style="margin-top:8px;background:rgba(0,0,0,.35);border:1px solid var(--border);border-radius:10px;padding:10px;font-size:7.5px;color:var(--text-secondary);overflow-x:auto;line-height:1.6;font-family:monospace;white-space:pre-wrap;">// supabase/functions/gate-proxy/index.ts
// ✅ FIX CRÍTICO 1: Auth obligatoria + CORS restringido a tu dominio
import { serve }         from "https://deno.land/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bccfc8d8fc8c928d8a84928c">[email&#160;protected]</a>/http/server.ts";
import { createClient }  from "https://esm.sh/@supabase/supabase-js@2";

// ⚠️ CAMBIAR a tu dominio real (ej. "https://miapp.vercel.app")
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") || "https://TU_DOMINIO_AQUI";

const CORS = {
  "Access-Control-Allow-Origin":  ALLOWED_ORIGIN,   // ✅ restringido — NO wildcard (*)
  "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type,KEY,Timestamp,SIGN,X-Client,Authorization",
};

serve(async (req) =&gt; {
  // Preflight
  if (req.method === "OPTIONS") return new Response(null, { status: 204, headers: CORS });

  // ✅ FIX CRÍTICO 2: Verificar que el usuario tiene sesión activa en Supabase
  // Cualquier request sin token válido es rechazado ANTES de llamar a Gate.io
  const authHeader = req.headers.get("Authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return new Response(JSON.stringify({ error: "No autorizado — sesión requerida" }),
      { status: 401, headers: { ...CORS, "Content-Type": "application/json" } });
  }

  const supabase = createClient(
    Deno.env.get("SUPABASE_URL")!,
    Deno.env.get("SUPABASE_ANON_KEY")!,
    { global: { headers: { Authorization: authHeader } } }
  );
  const { data: { user }, error: authErr } = await supabase.auth.getUser();
  if (authErr || !user) {
    return new Response(JSON.stringify({ error: "Token inválido o expirado" }),
      { status: 401, headers: { ...CORS, "Content-Type": "application/json" } });
  }

  // A partir de aquí: usuario autenticado ✓
  const url = new URL(req.url);
  const ep  = url.searchParams.get("endpoint");
  if (!ep) return new Response(JSON.stringify({ error: "missing endpoint" }),
    { status: 400, headers: { ...CORS, "Content-Type": "application/json" } });

  // ✅ Whitelist de endpoints permitidos — bloquear rutas no esperadas
  const ALLOWED_ENDPOINTS = [
    "/spot/accounts", "/spot/orders", "/spot/tickers",
    "/spot/currency_pairs", "/spot/time"
  ];
  const epBase = ep.split("?")[0];
  const isAllowed = ALLOWED_ENDPOINTS.some(a =&gt; epBase.startsWith(a)) ||
                    epBase.match(/^\/spot\/orders\/\w+$/);
  if (!isAllowed) {
    return new Response(JSON.stringify({ error: "Endpoint no permitido" }),
      { status: 403, headers: { ...CORS, "Content-Type": "application/json" } });
  }

  const biz = new URLSearchParams();
  url.searchParams.forEach((v, k) =&gt; { if (k !== "endpoint") biz.set(k, v); });
  const target = "https://api.gateio.ws/api/v4" + ep + (biz.toString() ? "?" + biz.toString() : "");

  const fwdHeaders: Record&lt;string, string&gt; = { "Content-Type": "application/json", "Accept": "application/json" };
  ["key","timestamp","sign"].forEach(h =&gt; { const v = req.headers.get(h); if (v) fwdHeaders[h.toUpperCase()] = v; });

  const body     = req.method === "POST" ? await req.text() : undefined;
  const upstream = await fetch(target, { method: req.method, headers: fwdHeaders, body });
  return new Response(await upstream.text(), { status: upstream.status, headers: { ...CORS, "Content-Type": "application/json" } });
});</pre>
                    </details>
                </div>
                <div class="setting-card-item">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;"><span class="setting-label">🔧 DIAGNÓSTICO COMPLETO</span><div style="display:flex;gap:6px;"><button class="btn-save-mini anim-click" onclick="fullSyncGateAccount(false)" style="background:var(--long);color:#fff;">🔄 SYNC</button><button class="btn-save-mini anim-click" onclick="runDiagnosticRadar()" style="background:var(--brand);color:#fff;">RADAR</button></div></div>
                    <div id="apiTestResultAdmin" style="font-size:10px;color:var(--text-tertiary);padding:8px;background:rgba(0,0,0,0.2);border-radius:8px;font-family:monospace;max-height:120px;overflow-y:auto;">Admin: SYNC o RADAR para diagnóstico</div>
                </div>
            </div>
            <div class="setting-section-title admin-only" style="border-left:3px solid var(--brand); padding-left:8px;"><svg width="14" height="14" viewBox="0 0 24 24"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg> CAPITAL & RENDIMIENTO <span style="font-size:8px; color:var(--brand); margin-left:4px;">★ ADMIN</span></div>
            <div class="settings-grid admin-only-grid">
                <div class="setting-card-item">
                    <div class="input-row-save" style="margin-bottom:10px;"><span class="setting-label" style="flex:1">CAPITAL TOTAL BASE ($)</span><button class="btn-save-mini anim-click" onclick="saveGlobalCapSecure()"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button></div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px"><input type="number" class="setting-input" id="setGlobalCapital" placeholder="0.00" style="border-bottom:1px solid var(--border)"><div><label class="setting-label">COMISIÓN EXCHANGE (%)</label><input type="number" class="setting-input" id="setFee" placeholder="0.1" step="0.01"></div></div>
                </div>
                <div class="setting-card-item"><label class="setting-label">GANANCIA MES ACTUAL</label><div id="monthlyProfitDisplay" style="font-family:var(--font-num); font-size:16px; font-weight:800; color:var(--text-primary);">$0.00 <span style="font-size:12px; color:var(--text-tertiary)">(0%)</span></div></div>
            </div>
            <div class="setting-section-title admin-only" style="border-left:3px solid var(--brand); padding-left:8px;"><svg width="14" height="14" viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg> ESTRATEGIA Y GESTIÓN <span style="font-size:8px; color:var(--brand); margin-left:4px;">★ ADMIN</span></div>
            <div class="settings-grid admin-only-grid">
                <div class="setting-card-item">
                    <div class="input-row-save" style="margin-bottom:10px; justify-content:space-between;"><span class="setting-label" style="color:var(--brand);">⚡ ESTRATEGIA NORMAL</span><button class="btn-save-mini anim-click" onclick="saveStrategyParams('normal')"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button></div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <div><label class="setting-label">CAPITAL ($)</label><input type="number" class="setting-input" id="setCapitalNormal" value="5"></div>
                        <div><label class="setting-label">NIVEL 2+ (%)</label><input type="number" class="setting-input" id="setIncNormal" value="6"></div>
                        <div><label class="setting-label">NIVEL 1 (%)</label><input type="number" class="setting-input" id="setDescNormal" value="16"></div>
                        <div><label class="setting-label">DD MAX (%)</label><input type="number" class="setting-input" id="setDDNormal" value="16"></div>
                    </div>
                    <!-- Info de salidas configuradas -->
                    <div style="margin-top:8px;padding:8px 10px;background:rgba(16,185,129,.06);border-radius:9px;border:1px solid rgba(16,185,129,.2);font-family:var(--font-head);font-size:9px;line-height:2;color:var(--text-secondary);" id="stratExitSummary">
                        🟢 TP1: avg+50% → vende 50% &nbsp;|&nbsp; 📈 TRAILING activa a precio TP1+100% · stop −15% desde máximo → vende 50% restante<br>
                        🔄 Rebuy: −16% desde precio TP1 → 12 niveles · acumula al promedio · hasta 3 ciclos
                    </div>
                </div>

            </div>
            <div class="bot-section admin-only">
                <!-- ── HEADER BOT ── -->
                <div class="bot-header">
                    <div class="bot-title"><span>🤖</span><span>BOT INTELIGENTE</span></div>
                    <label class="bot-toggle"><input type="checkbox" id="botEnabled" onchange="toggleBot()"><span class="bot-slider"></span></label>
                </div>
                <div class="bot-status inactive" id="botStatus"><span>⚫</span><span id="botStatusText">Bot desactivado</span></div>

                <!-- ── STATUS POR SLOT ── -->
                <div id="botSlotStatus" style="display:grid;grid-template-columns:repeat(5,1fr);gap:4px;margin:6px 0;">
                    <div class="bot-slot-pill" id="bss-0">S1<br><span id="bss-lbl-0" style="font-size:8px;">—</span></div>
                    <div class="bot-slot-pill" id="bss-1">S2<br><span id="bss-lbl-1" style="font-size:8px;">—</span></div>
                    <div class="bot-slot-pill" id="bss-2">S3<br><span id="bss-lbl-2" style="font-size:8px;">—</span></div>
                    <div class="bot-slot-pill" id="bss-3">S4<br><span id="bss-lbl-3" style="font-size:8px;">—</span></div>
                    <div class="bot-slot-pill" id="bss-4">S5<br><span id="bss-lbl-4" style="font-size:8px;">—</span></div>
                </div>

                <!-- ── TABS: BÁSICO / AVANZADO ── -->
                <div style="display:flex;gap:3px;background:var(--bg);border-radius:10px;padding:3px;margin:6px 0;">
                    <button class="etf-tab active" id="botTab-basic" onclick="switchBotTab('basic')" style="font-size:8px;">📊 BÁSICO</button>
                    <button class="etf-tab admin-bot-tab" id="botTab-smart" onclick="switchBotTab('smart')" style="font-size:8px;display:none;">🧠 SMART ★</button>
                    <button class="etf-tab" id="botTab-exit" onclick="switchBotTab('exit')" style="font-size:8px;">🎯 SALIDA</button>
                    <button class="etf-tab" id="botTab-log" onclick="switchBotTab('log')" style="font-size:8px;">📋 LOG</button>
                </div>

                <!-- TAB BÁSICO -->
                <div id="botPanel-basic" class="sell-panel active">
                    <div class="bot-param-grid">
                        <div class="bot-param">
                            <label class="bot-param-label">🎚️ Niveles máx/slot</label>
                            <input type="number" class="bot-param-input" id="botMaxLevels" value="12" min="1" max="12" step="1" onchange="saveBotConfig()">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Máximo 12 niveles por posición</div>
                        </div>
                        <div class="bot-param">
                            <label class="bot-param-label">♻️ Reinicio auto (min)</label>
                            <input type="number" class="bot-param-input" id="botRestartDelay" value="0" min="0" max="1440" step="15" onchange="saveBotConfig()">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">0 = desactivado</div>
                        </div>
                        <div class="bot-param">
                            <label class="bot-param-label">⚡ Umbral crash (%/2min)</label>
                            <input type="number" class="bot-param-input" id="botCrashDrop" value="8" min="3" max="30" step="1" onchange="saveBotConfig()">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Caída en 2min para modo compra acumulada</div>
                        </div>
                        <div class="bot-param">
                            <label class="bot-param-label">📉 Umbral caída rápida (%)</label>
                            <input type="number" class="bot-param-input" id="botCrashWindow" value="3" min="1" max="15" step="1" onchange="saveBotConfig()">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">% en 2min para ciclo acelerado</div>
                        </div>
                    </div>
                    <!-- Info crash acumulado -->
                    <div style="margin-top:8px;padding:8px 10px;background:rgba(245,158,11,.06);border-radius:10px;border:1px solid rgba(245,158,11,.2);font-family:var(--font-head);font-size:9px;color:var(--warning);line-height:1.8;">
                        ⚡ <b>Crash:</b> cuando el ETF cae más del umbral en 2min, el bot acumula el capital de todos los niveles saltados y ejecuta <b>una sola compra</b> al precio actual.<br>
                        El bot <b>nunca se detiene</b> — los ETFs apalancados son volátiles por diseño.
                    </div>
                </div>

                <!-- TAB SMART — configuración de compra y rebalanceo -->
                <div id="botPanel-smart" class="sell-panel">
                    <div class="bot-param-grid">
                        <div class="bot-param">
                            <label class="bot-param-label" style="color:var(--long);">⚡ Ciclo rápido (seg)</label>
                            <select class="bot-param-input" id="botVelBoost" onchange="saveBotConfig()" style="cursor:pointer;">
                                <option value="1">✅ 2s en crash · 5s normal</option>
                                <option value="0">❌ Siempre 5s</option>
                            </select>
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Acelera el ciclo del bot durante caídas rápidas</div>
                        </div>
                        <div class="bot-param">
                            <label class="bot-param-label" style="color:var(--brand);">🧠 Contexto BTC/ETH</label>
                            <select class="bot-param-input" id="botContextAware" onchange="saveBotConfig()" style="cursor:pointer;">
                                <option value="1">✅ Activo</option>
                                <option value="0">❌ Desactivado</option>
                            </select>
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Ajusta capital en niveles altos según dirección del mercado</div>
                        </div>
                        <!-- inputs ocultos para compatibilidad — no se muestran al usuario -->
                        <input type="hidden" id="botCrashEnabled" value="0">
                        <input type="hidden" id="botCircuitEnabled" value="0">
                        <input type="hidden" id="botCircuitBreaker" value="70">
                        <input type="hidden" id="botRoiManual" value="120">
                        <input type="hidden" id="botRoiAuto" value="120">
                        <div class="bot-param" style="grid-column:1/-1;">
                            <label class="bot-param-label">🕐 Pausa rebalanceo ETF (~00:00 UTC)</label>
                            <select class="bot-param-input" id="botRebalPause" onchange="saveBotConfig()" style="cursor:pointer;">
                                <option value="1" selected>✅ SÍ pausar — evitar gaps de precio</option>
                                <option value="0">⚠️ NO pausar — riesgo slippage/NAV</option>
                            </select>
                            <div style="font-size:8px;color:var(--warning);margin-top:4px;line-height:1.6;padding:5px 8px;background:rgba(245,158,11,0.08);border-radius:7px;border:1px solid rgba(245,158,11,0.25);">
                                ⚠️ Gate.io rebalancea ETFs ~00:00 UTC. Comprar en ese momento puede generar precios anómalos. Recomendado: pausar.
                            </div>
                        </div>
                    </div>
                    <div id="botRebalStatus" style="margin-top:6px;padding:6px 10px;border-radius:8px;font-family:var(--font-head);font-size:9px;font-weight:700;background:var(--bg);border:1px solid var(--border);display:flex;align-items:center;gap:6px;">
                        <span id="botRebalDot" style="width:7px;height:7px;border-radius:50%;background:var(--long);display:inline-block;"></span>
                        <span id="botRebalText">Ventana de rebalanceo: OK</span>
                    </div>
                </div>

                <!-- TAB SALIDA — estrategia TP1 / TRAILING / REBUY -->
                <div id="botPanel-exit" class="sell-panel">
                    <!-- Descripción de la estrategia -->
                    <div style="padding:10px 12px;background:rgba(16,185,129,.06);border:1px solid rgba(16,185,129,.22);border-radius:11px;margin-bottom:12px;">
                        <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);letter-spacing:.7px;margin-bottom:5px;">📌 ESTRATEGIA AUTOMÁTICA DE SALIDA</div>
                        <div style="font-family:var(--font-head);font-size:9px;color:var(--text-secondary);line-height:2;">
                            🟢 <b>TP1:</b> Precio promedio × 1.5 &nbsp;(<b style="color:var(--long)">avg +<span id="settTp1Preview">50</span>%</b>) → vende 50%<br>
                            📈 <b>TP2/TRAILING:</b> Activa en <b style="color:var(--brand)">precio TP1 +<span id="settTrailPreview">100</span>%</b> → sube sin tope · vende cuando baja <b style="color:var(--short)">−<span id="settDropPreview">15</span>%</b> del máximo
                        </div>
                    </div>

                    <!-- TP1 % -->
                    <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);letter-spacing:.8px;margin-bottom:6px;">🟢 PRIMERA SALIDA — TP1</div>
                    <div class="bot-param-grid" style="margin-bottom:10px;">
                        <div class="bot-param" style="border-color:rgba(16,185,129,.4);background:rgba(16,185,129,.05);">
                            <label class="bot-param-label" style="color:var(--long);">AVG + % → vende el 50%</label>
                            <input type="number" class="bot-param-input" id="botTp1Pct" value="50" min="10" max="300" step="5"
                                onchange="saveBotConfig();var e=document.getElementById('settTp1Preview');if(e)e.textContent=this.value">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Default 50 — vende la 1ª mitad cuando precio = promedio × 1.5</div>
                        </div>
                    </div>

                    <!-- TRAILING -->
                    <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);letter-spacing:.8px;margin-bottom:6px;">📈 SEGUNDA SALIDA — TRAILING desde precio TP1 (sin tope al alza)</div>
                    <div class="bot-param-grid" style="margin-bottom:10px;">
                        <div class="bot-param" style="border-color:rgba(59,130,246,.4);background:rgba(59,130,246,.05);">
                            <label class="bot-param-label" style="color:var(--brand);">Trailing activa a PRECIO TP1 + %</label>
                            <input type="number" class="bot-param-input" id="botTrailActivePct" value="100" min="30" max="500" step="5"
                                onchange="saveBotConfig();var e=document.getElementById('settTrailPreview');if(e)e.textContent=this.value">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Default 100 — el trailing empieza cuando precio supera precio_TP1 × 2</div>
                        </div>
                        <div class="bot-param" style="border-color:rgba(239,68,68,.35);background:rgba(239,68,68,.04);">
                            <label class="bot-param-label" style="color:var(--short);">Retroceso desde máximo (%)</label>
                            <input type="number" class="bot-param-input" id="botTrailDropPct" value="15" min="3" max="40" step="1"
                                onchange="saveBotConfig();var e=document.getElementById('settDropPreview');if(e)e.textContent=this.value">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Default 15 — vende el 50% restante si cae este % desde el máximo</div>
                        </div>
                    </div>

                    <!-- REBUY -->
                    <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);letter-spacing:.8px;margin-bottom:6px;">🔄 REBUY POST-TP1 (opcional)</div>
                    <div class="bot-param-grid" style="margin-bottom:10px;">
                        <div class="bot-param" style="border-color:rgba(245,158,11,.4);background:rgba(245,158,11,.04);">
                            <label class="bot-param-label" style="color:var(--warning);">Caída desde TP1 para rebuy (%)</label>
                            <input type="number" class="bot-param-input" id="botRebuyDropPct" value="16" min="5" max="50" step="1" onchange="saveBotConfig()">
                            <div style="font-size:8px;color:var(--text-tertiary);margin-top:2px;">Default 16 — si tras TP1 cae este %, reactiva 12 niveles (hasta 3 veces)</div>
                        </div>
                    </div>

                    <input type="hidden" id="botCrashFast" value="3">

                    <!-- Resumen visual dinámico -->
                    <div id="trailVisual" style="padding:10px 12px;background:var(--bg);border-radius:11px;border:1px solid var(--border);font-family:var(--font-head);font-size:9px;line-height:2.1;color:var(--text-secondary);">
                        <div id="trailVisualText">Cargando...</div>
                    </div>
                </div>

                <!-- TAB LOG -->
                <div id="botPanel-log" class="sell-panel">
                    <div id="botLogEntries" style="max-height:220px;overflow-y:auto;display:flex;flex-direction:column;gap:4px;">
                        <div style="text-align:center;padding:20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">Sin actividad registrada</div>
                    </div>
                    <button onclick="clearBotLog()" style="margin-top:8px;width:100%;padding:6px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;cursor:pointer;">🗑️ LIMPIAR LOG</button>
                </div>
            </div>
            <div class="setting-section-title admin-only" style="border-left:3px solid var(--brand); padding-left:8px;"><svg width="14" height="14" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg> AJUSTES AVANZADOS <span style="font-size:8px; color:var(--brand); margin-left:4px;">★ ADMIN</span></div>
            <div class="settings-grid admin-only-grid">
                <div class="setting-card-item">
                     <div class="input-row-save" style="justify-content:space-between; margin-bottom:10px; border-bottom:1px solid var(--border); padding-bottom:8px;"><span class="setting-label">RADAR & MONITOR</span><button class="btn-save-mini anim-click" onclick="saveRadarSecure()"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button></div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;"><div><label class="setting-label" style="display:block; margin-bottom:4px;">ITEMS RADAR</label><input type="number" class="setting-input" id="setRadarLimit" placeholder="12" style="background:rgba(0,0,0,0.2); border-radius:8px; padding:6px; text-align:center;"></div><div><label class="setting-label" style="display:block; margin-bottom:4px;">ITEMS MONITOR</label><input type="number" class="setting-input" id="setMonitorLimit" placeholder="10" style="background:rgba(0,0,0,0.2); border-radius:8px; padding:6px; text-align:center;"></div><div><label class="setting-label" style="display:block; margin-bottom:4px;">VEL. RADAR (s)</label><input type="number" class="setting-input" id="setRadarSpeed" placeholder="3" style="background:rgba(0,0,0,0.2); border-radius:8px; padding:6px; text-align:center;"></div><div><label class="setting-label" style="display:block; margin-bottom:4px;">VEL. TICKER (s)</label><input type="number" class="setting-input" id="setTickerSpeed" placeholder="7" style="background:rgba(0,0,0,0.2); border-radius:8px; padding:6px; text-align:center;"></div><div><label class="setting-label" style="display:block; margin-bottom:4px;">📉 AJUSTE AUTO (%)</label><input type="number" class="setting-input" id="setAutoAdjustThreshold" placeholder="3" step="0.5" style="background:rgba(0,0,0,0.2); border-radius:8px; padding:6px; text-align:center;"></div></div>
                </div>
                <div class="setting-card-item">
                    <div class="input-row-save" style="justify-content:space-between; margin-bottom:5px;"><span class="setting-label">MULTIPLICADORES</span><button class="btn-save-mini anim-click" onclick="saveMultiSecure()"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button></div>
                    <div id="multiGrid" class="multi-grid"></div>
                </div>
                <div class="setting-card-item"><label class="setting-label">MONEDAS DEL TICKER</label><div id="tickerChipsContainer" class="multi-grid"></div></div>
            </div>

            <!-- ══ ZONA ADMINISTRADOR — siempre visible en Ajustes ══ -->
            <div style="margin:16px 0 6px;">
                <div id="adminPinCard" style="background:linear-gradient(135deg,rgba(239,68,68,0.07),rgba(239,68,68,0.02));border:1px solid rgba(239,68,68,0.22);border-radius:16px;padding:14px 16px;display:flex;flex-direction:column;gap:12px;">
                    <div style="display:flex;align-items:center;gap:10px;">
                        <div style="width:38px;height:38px;border-radius:10px;background:rgba(239,68,68,0.12);border:1px solid rgba(239,68,68,0.25);display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:18px;">🔐</div>
                        <div>
                            <div style="font-family:var(--font-head);font-size:11px;font-weight:800;color:var(--text-primary);letter-spacing:.5px;">ZONA ADMINISTRADOR</div>
                            <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);margin-top:2px;">Estrategia · Bot · Capital · Usuarios</div>
                        </div>
                    </div>
                    <div style="display:flex;gap:8px;align-items:center;width:100%;box-sizing:border-box;">
                        <input type="password" id="adminPinInput" inputmode="numeric" pattern="[0-9]*" placeholder="PIN" maxlength="4"
                            style="flex:1;min-width:0;background:var(--bg);border:1px solid var(--border-strong);border-radius:10px;color:var(--text-primary);font-family:var(--font-num);font-size:24px;font-weight:800;letter-spacing:10px;text-align:center;padding:10px 12px;outline:none;transition:border-color .2s;box-sizing:border-box;"
                            onfocus="this.style.borderColor='var(--short)'" onblur="this.style.borderColor='var(--border-strong)'"
                            onkeydown="if(event.key==='Enter') verifyAdminPin()">
                        <button onclick="verifyAdminPin()" class="anim-click"
                            style="background:var(--short);border:none;color:#fff;border-radius:10px;padding:12px 18px;font-family:var(--font-head);font-size:11px;font-weight:800;cursor:pointer;flex-shrink:0;white-space:nowrap;">
                            ENTRAR
                        </button>
                    </div>
                </div>
                <div id="adminActiveCard" style="display:none;background:linear-gradient(135deg,rgba(16,185,129,0.09),rgba(16,185,129,0.02));border:1px solid rgba(16,185,129,0.28);border-radius:16px;padding:12px 16px;flex-direction:row;align-items:center;gap:10px;">
                    <div style="width:34px;height:34px;border-radius:9px;background:rgba(16,185,129,0.15);display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:18px;">👑</div>
                    <div style="flex:1;">
                        <div style="font-family:var(--font-head);font-size:11px;font-weight:800;color:var(--long);">ADMIN ACTIVO</div>
                        <div id="adminModeStatus" style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);margin-top:1px;">Opciones avanzadas visibles</div>
                    </div>
                    <button onclick="setAdminMode(false);applyRoleVisibility();showToast('👤 Modo usuario');" class="anim-click"
                        style="background:transparent;border:1px solid var(--border-strong);color:var(--text-tertiary);border-radius:8px;padding:7px 12px;font-family:var(--font-head);font-size:9px;font-weight:700;cursor:pointer;white-space:nowrap;">
                        SALIR
                    </button>
                </div>
            </div>
            <!-- ── GESTIÓN DE USUARIOS — solo admin ── -->
            <div class="setting-section-title admin-only" style="border-left:3px solid var(--warning);padding-left:8px;margin-top:8px;">
                <svg width="14" height="14" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                GESTIÓN DE USUARIOS <span style="font-size:8px;color:var(--warning);margin-left:4px;">★ ADMIN</span>
            </div>
            <div class="settings-grid admin-only-grid" style="margin-bottom:8px;">
                <div class="setting-card-item">
                    <div style="font-family:var(--font-head);font-size:10px;font-weight:800;color:var(--text-primary);margin-bottom:10px;letter-spacing:.5px;">AÑADIR USUARIO</div>
                    <div style="display:flex;flex-direction:column;gap:8px;">
                        <input type="text" id="newUserName" class="setting-input" placeholder="Nombre del usuario" style="font-size:12px;">
                        <input type="text" id="newUserUsername" class="setting-input" placeholder="Usuario (para login)" style="font-size:12px;margin-bottom:6px;">
                        <input type="password" id="newUserPin" class="setting-input" placeholder="Contraseña de acceso" style="font-size:12px;letter-spacing:2px;">
                        <input type="text" id="newUserNote" class="setting-input" placeholder="Nota / contacto (opcional)" style="font-size:11px;">
                        <button onclick="addUser()" class="btn-save-mini anim-click" style="background:var(--long);color:#fff;padding:10px;font-size:11px;">➕ AGREGAR USUARIO</button>
                    </div>
                    <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);margin-top:8px;line-height:1.8;">Usuarios desactivados solo pueden acceder al Soporte.</div>
                </div>
            </div>
            <div class="admin-only" id="userListSection" style="padding:0 0 8px;">
                <div id="userListContainer" style="display:flex;flex-direction:column;gap:6px;padding:0 0 6px;">
                    <div style="text-align:center;padding:20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">Sin usuarios registrados</div>
                </div>
            </div>
            <!-- ── PANEL ADMIN: RESUMEN TRADES GLOBALES ── -->
            <div class="admin-only" style="padding:0 0 8px;">
                <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
                    <div style="font-family:var(--font-head);font-size:10px;font-weight:800;color:var(--text-primary);letter-spacing:.5px;">📊 TRADES GLOBALES</div>
                    <button onclick="renderAdminTrades()" style="padding:5px 10px;border-radius:10px;border:1px solid var(--brand);background:rgba(59,130,246,.1);color:var(--brand);font-family:var(--font-head);font-size:8px;font-weight:800;cursor:pointer;">↺ ACTUALIZAR</button>
                </div>
                <!-- Stats rápidas admin -->
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:5px;margin-bottom:8px;">
                    <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px;text-align:center;">
                        <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">TOTAL OPS</div>
                        <div id="adminStatOps" style="font-family:var(--font-num);font-size:18px;font-weight:800;color:var(--text-primary);">—</div>
                    </div>
                    <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px;text-align:center;">
                        <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">NET GLOBAL</div>
                        <div id="adminStatNet" style="font-family:var(--font-num);font-size:15px;font-weight:800;color:var(--long);">—</div>
                    </div>
                    <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px;text-align:center;">
                        <div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);letter-spacing:.5px;">WIN RATE</div>
                        <div id="adminStatWr" style="font-family:var(--font-num);font-size:18px;font-weight:800;color:var(--long);">—</div>
                    </div>
                </div>
                <div id="adminTradesContainer" style="display:flex;flex-direction:column;gap:5px;max-height:340px;overflow-y:auto;scrollbar-width:none;">
                    <div style="text-align:center;padding:16px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">Presiona ACTUALIZAR para ver trades</div>
                </div>
            </div>

            <div class="setting-section-title"><svg width="14" height="14" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg> SEGURIDAD</div>
            <div class="settings-grid">
                <div class="setting-card-item"><div class="input-row-save"><div style="flex:1"><label class="setting-label">NUEVA CLAVE</label><input type="password" class="setting-input" id="setNewPass" placeholder="****" maxlength="4" style="letter-spacing:4px;"></div><button class="btn-save-mini anim-click" onclick="savePassSecure()"><svg width="18" height="18" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg></button></div></div>
            </div>
            <div class="setting-section-title"><svg width="14" height="14" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg> GESTIÓN DE DATOS</div>
            <div class="data-actions"><button class="btn-data anim-click" onclick="exportData()">⬇️ EXPORTAR BACKUP</button><button class="btn-data anim-click" onclick="document.getElementById('importFile').click()">⬆️ IMPORTAR BACKUP</button><input type="file" id="importFile" style="display:none" onchange="importData(this)"></div>
            <button class="btn-reset anim-click admin-only" style="margin-top:15px; border-color:var(--border); color:var(--text-secondary); background:transparent;" onclick="clearLogs()"><svg width="14" height="14" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg> BORRAR HISTORIAL</button>
            <button class="btn-reset anim-click admin-only" style="margin-top:5px; border-color:var(--border); color:var(--text-secondary); background:transparent;" onclick="clearCrashMemory()"><svg width="14" height="14" viewBox="0 0 24 24"><path d="M18 6L6 18M6 6l12 12"></path></svg> RESETEAR ALERTAS CRASH</button>
            <div class="settings-card danger admin-only" style="margin-top:20px; border:1px solid var(--danger); background:rgba(207, 48, 74, 0.05); border-radius:16px; padding:15px;">
                <div class="setting-header" style="color:var(--danger); border-bottom:1px solid rgba(207, 48, 74, 0.3); padding-bottom:10px; margin-bottom:10px; font-weight:800;">⚠️ ZONA CRÍTICA</div>
                <div class="setting-info" style="text-align:center; margin-bottom:10px; font-size:12px; color:var(--text-secondary);"><p>Restablecer la aplicación borrará TODOS los datos.</p></div>
                <button class="btn-reset anim-click" onclick="resetApp()"><svg width="14" height="14" viewBox="0 0 24 24"><path d="M2.5 2v6h6M21.5 22v-6h-6"></path><path d="M22 11.5A10 10 0 0 0 3.2 7.2M2 12.5a10 10 0 0 0 18.8 4.2"></path></svg> RESTABLECER DE FÁBRICA</button>
            </div>

            <div style="text-align:center; font-size:10px; color:var(--text-tertiary); margin-top:20px; font-weight:700; letter-spacing:1px; margin-bottom:40px;">5X V25.32 - 10 SLOTS</div>
        </div>


    <div id="tradeModal" class="generic-modal">
        <div class="modal-box section-enter">
            <div class="nav-title" style="color:var(--brand); margin-bottom:10px;">EJECUTAR ORDEN</div>
            <div class="modal-info-text">Estás a punto de enviar una orden real a Gate.io</div>
            <div class="trade-details"><div>PAR: <span id="trade-pair" style="color:var(--text-primary); font-weight:800">BTC_USDT</span></div><div>PRECIO: <span id="trade-price" style="color:var(--text-primary); font-weight:800">0.00</span></div><div>CANTIDAD: <span id="trade-amount" style="color:var(--text-primary); font-weight:800">0.00</span></div><div>TOTAL: <span id="trade-total" style="color:var(--long); font-weight:800">$0.00</span></div></div>
            <button class="btn-modal btn-confirm anim-click" onclick="executeGateOrder()">CONFIRMAR COMPRA</button><button class="btn-modal btn-cancel anim-click" onclick="closeModals()">CANCELAR</button>
        </div>
    </div>
    <div id="confirmModal" class="generic-modal"><div class="modal-box section-enter"><div style="font-family:'Orbitron'; font-size:14px; margin-bottom:15px; color:var(--danger)">¿LIQUIDAR POSICIÓN?</div><p style="font-size:12px; color:var(--text-secondary); margin-bottom:20px;">Esta acción cerrará el slot actual y guardará el registro.</p><button class="btn-modal btn-confirm anim-click" style="background:var(--danger)" onclick="executeRelease()">SÍ, LIQUIDAR</button><button class="btn-modal btn-cancel anim-click" onclick="closeModals()">CANCELAR</button></div></div>
    <div id="securityModal" class="generic-modal"><div class="modal-box section-enter"><div style="font-family:'Orbitron'; font-size:12px;">SEGURIDAD</div><input type="password" id="secInput" class="modal-inp" placeholder="••••" maxlength="4" inputmode="numeric" pattern="[0-9]*"><button class="btn-modal btn-confirm anim-click" onclick="validateSecurity()">VALIDAR</button><button class="btn-modal btn-cancel anim-click" onclick="closeModals()">CANCELAR</button></div></div>
    <!-- MODAL VENTA MEJORADO — MULTI TP + TRAILING + AUTO-EJECUTAR -->
    <div id="sellOptionsModal" class="generic-modal" onclick="if(event.target===this) closeModals()">
        <div class="modal-box section-enter" style="max-width:380px;padding:18px 18px 20px;">

            <!-- HEADER: moneda + precio actual + PnL -->
            <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:14px;">
                <div>
                    <div style="font-family:'Orbitron';font-size:13px;font-weight:700;color:var(--warning);letter-spacing:1px;">🎯 VENTA</div>
                    <div style="font-family:var(--font-head);font-size:10px;color:var(--text-secondary);margin-top:3px;" id="sellModalCoin">—</div>
                    <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);margin-top:1px;" id="sellModalAvg">—</div>
                </div>
                <div style="text-align:right;">
                    <div style="font-family:var(--font-num);font-size:18px;font-weight:900;color:var(--text-primary);" id="sellModalCurrentPrice">$—</div>
                    <div style="font-family:var(--font-num);font-size:12px;font-weight:700;" id="sellModalPnl">—</div>
                </div>
            </div>

            <!-- VALOR TOTAL EN USD -->
            <div style="background:rgba(239,68,68,.07);border:1px solid rgba(239,68,68,.3);border-radius:13px;padding:12px 14px;margin-bottom:12px;">
                <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);letter-spacing:.8px;margin-bottom:4px;">VALOR TOTAL DE LA POSICIÓN</div>
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div style="font-family:'Orbitron';font-size:20px;font-weight:900;color:var(--short);" id="sellModalTotalUsd">$—</div>
                    <div style="text-align:right;">
                        <div style="font-family:var(--font-num);font-size:9px;color:var(--text-tertiary);" id="sellModalQtyLine">—</div>
                        <div style="font-family:var(--font-num);font-size:9px;color:var(--text-tertiary);" id="sellModalInvLine">—</div>
                    </div>
                </div>
            </div>

            <!-- ESTRATEGIA AUTOMÁTICA (informativo) -->
            <div style="background:var(--bg);border:1px solid var(--border);border-radius:11px;padding:10px 13px;margin-bottom:12px;">
                <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);letter-spacing:.7px;margin-bottom:6px;">⚙️ ESTRATEGIA DE SALIDAS ACTIVA</div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                    <span style="font-family:var(--font-head);font-size:9px;color:var(--long);">🟢 TP1 — vende 50% MARKET</span>
                    <span style="font-family:var(--font-num);font-size:9px;font-weight:800;color:var(--long);">avg +<span id="smTp1Pct">50</span>% → <span id="smTp1Price">$—</span></span>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                    <span style="font-family:var(--font-head);font-size:9px;color:var(--brand);">📈 TRAILING — desde precio TP1 · sin tope</span>
                    <span style="font-family:var(--font-num);font-size:9px;font-weight:800;color:var(--brand);">TP1+<span id="smTrailPct">100</span>% → <span id="smTrailPrice">$—</span></span>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                    <span style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);">🔴 Stop: retrocede desde máximo</span>
                    <span style="font-family:var(--font-num);font-size:9px;font-weight:800;color:var(--short);">−<span id="smDropPct">15</span>%</span>
                </div>
                <div style="display:flex;justify-content:space-between;">
                    <span style="font-family:var(--font-head);font-size:9px;color:var(--warning);">🔄 Rebuy post-TP1 (hasta 3×)</span>
                    <span style="font-family:var(--font-num);font-size:9px;font-weight:800;color:var(--warning);">−<span id="smRebuyPct">16</span>% · ciclo <span id="smRebuyCount">0</span>/3</span>
                </div>
            </div>

            <!-- ESTADO ACTIVO (si hay estrategia en curso) -->
            <div id="sellActiveStatus" style="display:none;margin-bottom:12px;padding:8px 12px;background:rgba(16,185,129,.07);border:1px solid rgba(16,185,129,.28);border-radius:10px;">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-family:var(--font-head);font-size:10px;font-weight:800;color:var(--long);" id="sellActiveMode">—</span>
                    <button onclick="cancelActiveSell()" style="font-family:var(--font-head);font-size:8px;padding:3px 9px;border-radius:6px;background:rgba(239,68,68,.12);border:1px solid rgba(239,68,68,.28);color:var(--short);cursor:pointer;">✕ CANCELAR</button>
                </div>
                <div style="font-family:var(--font-num);font-size:10px;color:var(--text-secondary);margin-top:2px;" id="sellActiveDetail">—</div>
            </div>

            <!-- BOTÓN PRINCIPAL: VENDER EN MERCADO -->
            <button class="sell-opt-btn sell-now anim-click" onclick="executeSellOption('now')"
                style="width:100%;padding:15px 16px;border-radius:14px;text-align:center;margin-bottom:6px;">
                <div style="font-family:'Orbitron';font-size:13px;font-weight:700;letter-spacing:.8px;">🔴 VENDER EN MERCADO</div>
                <div style="font-family:var(--font-head);font-size:9px;opacity:.7;margin-top:3px;">Cierra el 100% de la posición al precio actual</div>
            </button>

            <div style="text-align:center;margin-bottom:8px;">
                <button onclick="closeModals();switchView('settings')"
                    style="background:none;border:none;font-family:var(--font-head);font-size:9px;color:var(--brand);cursor:pointer;">
                    ⚙️ Configurar % de venta en Ajustes
                </button>
            </div>

            <button class="btn-modal btn-cancel anim-click" style="width:100%;" onclick="closeModals()">CERRAR</button>
        </div>
    </div>
    <!-- incInput/descInput removed — valores vienen de strategyParams -->

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        const Core = { UI: { handleCoinTap: function() {} } };
        let coinPressTimer;
        let basePricePressTimer;
        
        function startCoinPress() { if(coinPressTimer) clearTimeout(coinPressTimer); coinPressTimer = setTimeout(() => { const el = document.getElementById('coinInput'); if(el.hasAttribute('readonly')) { el.removeAttribute('readonly'); el.classList.remove('locked-input'); el.classList.add('manual-edit'); el.value = ''; el.focus(); if(navigator.vibrate) navigator.vibrate(50); showToast("✏️ Escribe el ETF (ej: PEPE3L)"); } }, 1600); }
        function cancelCoinPress() { if(coinPressTimer) clearTimeout(coinPressTimer); }
        function finishEditingCoin() { const el = document.getElementById('coinInput'); if(!el.hasAttribute('readonly')) { let val = el.value.toUpperCase().trim().replace('USDT',''); if(val) { slots[activeIdx].name = val; save(); loadChart(val); calculate(); showToast("✅ Moneda Guardada: " + val); } el.setAttribute('readonly', true); el.classList.add('locked-input'); el.classList.remove('manual-edit'); el.value = slots[activeIdx].name || "---"; } }
        
        function startBasePricePress(e) {
            if (e) e.preventDefault();
            if(basePricePressTimer) clearTimeout(basePricePressTimer);
            basePricePressTimer = setTimeout(() => {
                const el = document.getElementById('baseInput');
                if(el.hasAttribute('readonly')) {
                    el.removeAttribute('readonly');
                    el.classList.remove('locked-input');
                    el.classList.add('manual-edit');
                    el.select();
                    if(navigator.vibrate) navigator.vibrate(50);
                    showToast("✏️ Modifica el precio - Se actualiza automáticamente");
                    el.oninput = function() {
                        const val = parseFloat(this.value);
                        if(!isNaN(val) && val > 0) {
                            slots[activeIdx].price = val;
                            renderLevels();
                        }
                    };
                }
            }, 1600);
        }
        function cancelBasePricePress() { if(basePricePressTimer) clearTimeout(basePricePressTimer); }
        function finishEditingBasePrice() {
            const el = document.getElementById('baseInput');
            if (!el.hasAttribute('readonly')) {
                const val = parseFloat(el.value);
                if (!isNaN(val) && val > 0) {
                    const s = slots[activeIdx];
                    s.price = val;
                    if (!s.initialPrice) s.initialPrice = val;
                    save();
                    renderLevels();
                    updateDashboardStats();
                    showToast("💾 Precio guardado: $" + val.toFixed(6));

                    // Detectar si el precio editado es SUPERIOR al precio real
                    // → ofrecer compra acumulada de todos los niveles alcanzados
                    setTimeout(() => {
                        const triggered = detectTriggeredLevels(s, activeIdx);
                        if (triggered && triggered.levels.length > 0) {
                            const lp = triggered.livePrice;
                            const deepest = triggered.deepestLevel + 1;
                            showToast(
                                `⚡ Precio real $${lp.toFixed(lp<1?6:4)} — ETF en N${deepest}. ` +
                                `Toca N${deepest} para compra acumulada`, 4000
                            );
                        }
                    }, 600);
                }
                el.oninput = null;
                el.setAttribute('readonly', true);
                el.classList.add('locked-input');
                el.classList.remove('manual-edit');
            }
        }

        // ══════════════════════════════════════════════════════════════
        //  EDICIÓN INLINE DE PRECIO BASE DESDE CUALQUIER DASHBOARD CARD
        // ══════════════════════════════════════════════════════════════
        let dashBasePressTimer = null;

        function startDashBasePricePress(slotIdx, e) {
            if (e) { e.preventDefault(); e.stopPropagation(); }
            cancelDashBasePricePress();
            // Visual feedback inmediato: resaltar celda
            const cell = document.getElementById('dashBaseCell-' + slotIdx);
            if (cell) cell.style.opacity = '0.7';
            dashBasePressTimer = setTimeout(() => {
                if (cell) cell.style.opacity = '';
                activateDashBaseEdit(slotIdx);
            }, 1100);
        }

        function cancelDashBasePricePress() {
            if (dashBasePressTimer) { clearTimeout(dashBasePressTimer); dashBasePressTimer = null; }
            // Restaurar opacidad de todas las celdas base
            document.querySelectorAll('[id^="dashBaseCell-"]').forEach(c => c.style.opacity = '');
        }

        function activateDashBaseEdit(slotIdx) {
            if (navigator.vibrate) navigator.vibrate([40, 20, 40]);
            const cell = document.getElementById('dashBaseCell-' + slotIdx);
            const displayEl = document.getElementById('dashBaseDisplay-' + slotIdx);
            if (!cell || !displayEl) return;
            // Evitar doble edición
            if (cell.querySelector('.dash-base-edit-input')) return;

            const currentVal = slots[slotIdx] && slots[slotIdx].price > 0 ? slots[slotIdx].price : '';
            cell.classList.add('editing-base');

            // Crear input inline
            const inp = document.createElement('input');
            inp.type = 'number';
            inp.step = 'any';
            inp.min = '0';
            inp.className = 'dash-base-edit-input';
            inp.value = currentVal;
            inp.placeholder = '0.000000';
            inp.id = 'dashBaseInput-' + slotIdx;
            displayEl.replaceWith(inp);

            // Focus y selección con delay para mobile
            setTimeout(() => { try { inp.focus(); inp.select(); } catch(e) {} }, 80);

            showToast('✏️ Precio base SLOT ' + (slotIdx + 1) + ' — presiona Enter para guardar');

            // Cálculo en vivo mientras el usuario escribe
            inp.oninput = function() {
                const val = parseFloat(this.value);
                if (!isNaN(val) && val > 0) {
                    slots[slotIdx].price = val;
                    // Si es el slot activo, actualizar el baseInput oculto y recalcular niveles
                    if (slotIdx === activeIdx) {
                        const bIn = document.getElementById('baseInput');
                        if (bIn) bIn.value = val;
                        renderLevels();
                    }
                    updateDashboardStatsForSlot(slotIdx);
                }
            };

            // Guardar al soltar el foco o pulsar Enter/Escape
            let saved = false;
            function finishDashBaseEdit() {
                if (saved) return;
                saved = true;
                const val = parseFloat(inp.value);
                const isValid = !isNaN(val) && val > 0;
                if (isValid) {
                    slots[slotIdx].price = val;
                    if (!slots[slotIdx].initialPrice) slots[slotIdx].initialPrice = val;
                    // Sincronizar con baseInput del slot activo
                    if (slotIdx === activeIdx) {
                        const bIn = document.getElementById('baseInput');
                        if (bIn) {
                            bIn.value = val;
                            bIn.setAttribute('readonly', true);
                            bIn.classList.add('locked-input');
                            bIn.classList.remove('manual-edit');
                        }
                        calculate();
                    }
                    save();
                    showToast('💾 SLOT ' + (slotIdx + 1) + ' → $' + val.toFixed(val < 1 ? 6 : 4));
                    // Fix #8: banner persistente si diferencia > 5%
                    setTimeout(() => {
                        const sl = slots[slotIdx];
                        const triggered = detectTriggeredLevels(sl, slotIdx);
                        if (triggered && triggered.levels.length > 0) {
                            const lp = triggered.livePrice;
                            const deepest = triggered.deepestLevel + 1;
                            const diffPct = ((sl.price - lp) / lp * 100);
                            if (slotIdx === activeIdx) {
                                showToast(`⚡ Precio real ${lp.toFixed(lp<1?6:4)} — ETF en N${deepest}. Toca N${deepest} para compra acumulada`, 4500);
                                if (diffPct >= 5) _showEntryPriceBanner(slotIdx, sl.price, lp, deepest, diffPct.toFixed(1));
                            }
                        } else {
                            _hideEntryPriceBanner(slotIdx);
                        }
                    }, 700);
                } else {
                    // Revertir al valor anterior
                    slots[slotIdx].price = parseFloat(currentVal) || 0;
                }
                // Restaurar display
                cell.classList.remove('editing-base');
                const newSpan = document.createElement('span');
                newSpan.className = 'dash-cell-value';
                newSpan.id = 'dashBaseDisplay-' + slotIdx;
                const p = slots[slotIdx].price;
                newSpan.textContent = p > 0 ? (p < 1 ? p.toFixed(6) : p.toFixed(4)) : '0.0000';
                inp.replaceWith(newSpan);
                updateDashboardStatsForSlot(slotIdx);
                // Reordenar dashboards tras guardar
                if (isValid) setTimeout(sortAndRenderDashboards, 150);
            }

            inp.onblur = finishDashBaseEdit;
            inp.onkeydown = function(ev) {
                ev.stopPropagation();
                if (ev.key === 'Enter') { inp.blur(); }
                if (ev.key === 'Escape') { inp.value = currentVal; inp.blur(); }
            };
        }

        // ══════════════════════════════════════════════════════════════
        //  MINI-ACCIONES DEL DASHBOARD CARD (botones cabecera)
        // ══════════════════════════════════════════════════════════════

        function dashOpenSell(slotIdx, e) {
            if (e) { e.stopPropagation(); e.preventDefault(); }
            // Seleccionar el slot si no está activo y abrir el modal de venta
            if (slotIdx !== activeIdx) {
                activeIdx = slotIdx;
                localStorage.setItem('c5x_last_slot', slotIdx);
                const s = slots[slotIdx];
                const cIn = document.getElementById('coinInput');
                if (cIn && s) cIn.value = s.name || '';
                const bIn = document.getElementById('baseInput');
                if (bIn && s && s.price > 0) { bIn.value = s.price; bIn.setAttribute('readonly', true); bIn.classList.add('locked-input'); }
                updateDashUI();
            }
            // Pequeño delay para que el slot quede activo antes de abrir modal
            setTimeout(() => openSellOptionsModal(), 50);
        }

        // Estado de qué cards están en posición flip
        const _dashFlipped = {};

        function dashFlipCard(slotIdx, e) {
            if (e) { e.stopPropagation(); e.preventDefault(); }
            const face = document.getElementById('dashPosFace-' + slotIdx);
            if (!face) return;
            // Poblar datos de posición antes de mostrar
            _updateDashPositionCard(slotIdx);
            face.classList.add('visible');
            _dashFlipped[slotIdx] = true;
        }

        function dashFlipBack(slotIdx, e) {
            if (e) { e.stopPropagation(); e.preventDefault(); }
            const face = document.getElementById('dashPosFace-' + slotIdx);
            if (!face) return;
            face.classList.remove('visible');
            _dashFlipped[slotIdx] = false;
        }

        function _updateDashPositionCard(slotIdx) {
            const slot = slots[slotIdx];
            const coinColor = getCoinColor ? getCoinColor(slot && slot.name) : 'var(--brand)';
            // Nombre
            const nameEl = document.getElementById('dashPosName-' + slotIdx);
            if (nameEl) { nameEl.textContent = (slot && slot.name) || '---'; nameEl.style.color = coinColor; }

            if (!slot || !slot.name) return;

            // Calcular totales
            let totalInvested = 0, totalQty = 0, levelsUsed = 0;
            for (let i = 0; i < 12; i++) {
                const key = getOrderKey(slotIdx, i);
                if (activeOrders[key] && activeOrders[key].status === 'filled') {
                    totalInvested += activeOrders[key].price * activeOrders[key].amount;
                    totalQty      += activeOrders[key].amount;
                    levelsUsed++;
                } else if (slot.buys && slot.buys.includes(i) && !activeOrders[key]) {
                    try { const d = getLevelData(slot, i); totalInvested += d.usd; totalQty += d.qty; levelsUsed++; } catch(e) {}
                }
                if (slot.multipleBuys && slot.multipleBuys[i]) {
                    for (const b of slot.multipleBuys[i]) { totalInvested += b.usd; totalQty += b.qty; }
                }
            }
            const avgPrice   = totalQty > 0 ? totalInvested / totalQty : 0;
            const targetPrice = avgPrice > 0 ? avgPrice * (1 + (botConfig.tp1Pct || 50) / 100) : 0;
            const fmt = v => v <= 0 ? '—' : v < 0.0001 ? v.toFixed(8) : v < 1 ? v.toFixed(6) : v.toFixed(4);

            // PnL vivo (precio de mercado si disponible)
            let pnlStr = '—', pnlColor = 'var(--text-primary)';
            if (avgPrice > 0 && typeof allGateETFs !== 'undefined' && allGateETFs) {
                const pair = (slot.name + '_USDT').toUpperCase();
                const live = allGateETFs.find(t => t.currency_pair === pair || t.currency_pair === slot.name + '_USDT');
                if (live) {
                    const mp = parseFloat(live.last);
                    const pnlDollar = totalQty > 0 ? (mp - avgPrice) * totalQty : 0;
                    pnlStr = (pnlDollar >= 0 ? '+' : '') + '$' + pnlDollar.toFixed(2);
                    pnlColor = pnlDollar >= 0 ? 'var(--long)' : 'var(--short)';
                }
            }

            const setVal = (id, txt, color) => {
                const el = document.getElementById(id + '-' + slotIdx);
                if (el) { el.textContent = txt; if (color) el.style.color = color; }
            };
            setVal('dashPosInv',    totalInvested > 0 ? '$' + totalInvested.toFixed(2) : '$0.00');
            setVal('dashPosAvg',    fmt(avgPrice));
            setVal('dashPosLvls',   levelsUsed + ' / 12');
            setVal('dashPosBase',   fmt(slot.price));
            setVal('dashPosTarget', fmt(targetPrice));
            setVal('dashPosPnl',    pnlStr, pnlColor);
        }
        function getSlotInvested(slotIdx) {
            const slot = slots[slotIdx];
            if (!slot || !slot.name) return 0;
            let total = 0;
            for (let lvl = 0; lvl < 12; lvl++) {
                const key = getOrderKey(slotIdx, lvl);
                if (activeOrders[key] && activeOrders[key].status === 'filled') {
                    total += (activeOrders[key].price * activeOrders[key].amount) || 0;
                } else if (slot.buys && slot.buys.includes(lvl) && !activeOrders[key]) {
                    try { const d = getLevelData(slot, lvl); total += d.usd || 0; } catch(e) {}
                }
                if (slot.multipleBuys && slot.multipleBuys[lvl]) {
                    for (const b of slot.multipleBuys[lvl]) total += b.usd || 0;
                }
            }
            return total;
        }

        function sortAndRenderDashboards() {
            // Capturar la referencia del slot activo ANTES de reordenar
            const activeSlotRef = slots[activeIdx];

            // Crear array de índices ordenados: slots con inversión DESC, vacíos al final
            const order = Array.from({ length: slots.length }, (_, i) => i);
            order.sort((a, b) => {
                const hasA = slots[a] && slots[a].name;
                const hasB = slots[b] && slots[b].name;
                if (!hasA && !hasB) return a - b; // mantener orden relativo vacíos
                if (!hasA) return 1;
                if (!hasB) return -1;
                const invA = getSlotInvested(a);
                const invB = getSlotInvested(b);
                if (invB !== invA) return invB - invA; // mayor inversión primero
                // Si igual inversión, mantener orden original
                return a - b;
            });
            // order[newIdx] = oldIdx  → necesitamos newOrder[newIdx] = oldIdx
            // "order" ya cumple esa semántica: order[newPosition] = oldIndex
            const newOrder = order;

            // ── REMAP: activeOrders keys s{oldIdx}_l{lvl} → s{newIdx}_l{lvl} ──
            const newActiveOrders = {};
            Object.keys(activeOrders).forEach(key => {
                const match = key.match(/^s(\d+)_(.+)$/);
                if (match) {
                    const oldIdx = parseInt(match[1]);
                    const rest   = match[2];
                    const newIdx = newOrder.indexOf(oldIdx);
                    if (newIdx !== -1) newActiveOrders[`s${newIdx}_${rest}`] = activeOrders[key];
                }
            });
            activeOrders = newActiveOrders;
            saveActiveOrders();

            // ── REMAP: slotModes ──
            const newSlotModes = newOrder.map(oldIdx => slotModes[oldIdx] || 'manual');
            slotModes = newSlotModes;
            localStorage.setItem('c5x_slot_modes', JSON.stringify(slotModes));

            // ── REMAP: trailingStopData ──
            const newTrailing = {};
            newOrder.forEach((oldIdx, newIdx) => {
                if (trailingStopData[oldIdx] !== undefined) newTrailing[newIdx] = trailingStopData[oldIdx];
            });
            trailingStopData = newTrailing;

            // ── REMAP: crashPausedSlots ──
            const newCrashPaused = {};
            newOrder.forEach((oldIdx, newIdx) => {
                if (crashPausedSlots[oldIdx] !== undefined)          newCrashPaused[newIdx]              = crashPausedSlots[oldIdx];
                if (crashPausedSlots[oldIdx + '_circuit'] !== undefined) newCrashPaused[newIdx + '_circuit'] = crashPausedSlots[oldIdx + '_circuit'];
            });
            crashPausedSlots = newCrashPaused;
            _saveCrashPauses();

            // ── REMAP: autoRestartTimers ──
            const newRestartTimers = {};
            newOrder.forEach((oldIdx, newIdx) => {
                if (autoRestartTimers[oldIdx] !== undefined) newRestartTimers[newIdx] = autoRestartTimers[oldIdx];
            });
            autoRestartTimers = newRestartTimers;

            // Reordenar el array de slots in-place
            const sorted = order.map(i => slots[i]);
            slots.splice(0, slots.length, ...sorted);

            // Actualizar activeIdx para que apunte al mismo slot
            const newActiveIdx = slots.indexOf(activeSlotRef);
            if (newActiveIdx >= 0 && newActiveIdx !== activeIdx) {
                activeIdx = newActiveIdx;
                localStorage.setItem('c5x_last_slot', activeIdx);
            }

            save();
            renderAllDashboards();
        }
        
        // ════════════════════════════════════════════════════════════════
        //  C5X NOTIFICATION SYSTEM — Service Worker + Push Notifications
        // ════════════════════════════════════════════════════════════════
        let swRegistration = null;
        let notifGranted   = false;

        // ── REGISTRO DEL SERVICE WORKER ──────────────────────────────────
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').then(reg => {
                    swRegistration = reg;
                    // Auto-actualizar cada 5 minutos
                    setInterval(() => reg.update(), 5 * 60 * 1000);
                    // Escuchar mensajes del SW
                    navigator.serviceWorker.addEventListener('message', onSwMessage);
                    console.log('✅ 5X SW registrado:', reg.scope);
                }).catch(err => console.warn('⚠️ SW error:', err));
            });
        }

        function onSwMessage(event) {
            // El SW puede enviarnos mensajes (ej. confirmación de notificación)
            if (event.data && event.data.type === 'SW_READY') {
                console.log('🔔 SW listo para notificaciones');
            }
        }

        // ── ENVIAR NOTIFICACIÓN NATIVA VÍA SW ───────────────────────────
        // Esta función funciona con la app abierta O en background (Android)
        function sendNativeNotif(title, body, opts = {}) {
            const options = {
                tag:               opts.tag  || 'c5x-alert',
                requireInteraction: opts.requireInteraction !== false ? true : false,
                silent:            opts.silent || false,
                data:              opts.data  || {},
                actions:           opts.actions || [],
                vibrate:           opts.vibrate || [200, 100, 200],
                icon:              opts.icon   || 'icon.png',
                badge:             'icon.png',
            };

            // Método 1: via Service Worker (funciona en background Android)
            if (swRegistration) {
                swRegistration.showNotification(title, {
                    body,
                    ...options
                }).catch(e => console.warn('SW notif error:', e));
                return;
            }

            // Método 2: fallback — Notification API directa (solo funciona en primer plano)
            if ('Notification' in window && Notification.permission === 'granted') {
                try {
                    new Notification(title, { body, icon: 'icon.png', ...options });
                } catch(e) {
                    console.warn('Notif fallback error:', e);
                }
            }
        }

        // ── PEDIR PERMISO DE NOTIFICACIONES ─────────────────────────────
        function requestNotifPermission() {
            if (!('Notification' in window)) {
                showToast('⚠️ Tu navegador no soporta notificaciones');
                dismissNotifBanner();
                return;
            }
            Notification.requestPermission().then(permission => {
                notifGranted = (permission === 'granted');
                localStorage.setItem('c5x_notif_perm', permission);
                localStorage.setItem('c5x_notif_asked', '1');
                dismissNotifBanner();
                if (notifGranted) {
                    showToast('🔔 Notificaciones activadas', 2500, false, true);
                    // Notificación de prueba para confirmar que funciona
                    setTimeout(() => {
                        sendNativeNotif(
                            '✅ 5X — Notificaciones Activas',
                            'Recibirás alertas de objetivos alcanzados, compras ejecutadas y más.',
                            { tag: 'c5x-test', requireInteraction: false, vibrate: [100] }
                        );
                    }, 500);
                    updateNotifStatusUI();
                    // Intentar registrar Periodic Background Sync (Chrome Android 80+)
                    registerPeriodicSync();
                } else {
                    showToast('🔕 Notificaciones denegadas', 2500);
                }
            });
        }

        // ── PERIODIC BACKGROUND SYNC (Chrome Android ≥80) ───────────────
        async function registerPeriodicSync() {
            if (!swRegistration) return;
            try {
                const status = await navigator.permissions.query({ name: 'periodic-background-sync' });
                if (status.state === 'granted') {
                    await swRegistration.periodicSync.register('c5x-market-check', {
                        minInterval: 15 * 60 * 1000 // cada 15 min
                    });
                    console.log('✅ Periodic Sync registrado');
                }
            } catch(e) {
                console.info('Periodic sync no disponible:', e.message);
            }
        }

        // ── MOSTRAR/OCULTAR BANNER ───────────────────────────────────────
        function showNotifBanner() {
            const banner = document.getElementById('notifPermBanner');
            if (banner) banner.classList.add('visible');
        }
        function dismissNotifBanner() {
            const banner = document.getElementById('notifPermBanner');
            if (banner) banner.classList.remove('visible');
            localStorage.setItem('c5x_notif_dismissed', Date.now());
        }

        // ── FIX NOTIFICACIONES: permiso automático al primer gesto ────
        // Antes: mostraba un banner de configuración que el usuario tenía que
        // leer y luego pulsar "ACTIVAR". En dispositivos Android (PWA) eso
        // genera fricción innecesaria.
        // Ahora: al primer toque/click del usuario en cualquier parte de la app
        // se llama a requestNotifPermission() directamente. El sistema operativo
        // muestra su diálogo nativo ("¿Permitir notificaciones?") sin pasos extra.
        // • 'default'  → nunca preguntado → pedir en el primer gesto
        // • 'granted'  → ya activo        → solo actualizar UI
        // • 'denied'   → bloqueado        → mostrar guía en ajustes (sin banner)
        function checkNotifPermission() {
            if (!('Notification' in window)) return;
            notifGranted = (Notification.permission === 'granted');

            if (Notification.permission === 'default') {
                // Los navegadores exigen un gesto de usuario previo a requestPermission
                const _askOnFirstGesture = () => {
                    document.removeEventListener('touchstart', _askOnFirstGesture);
                    document.removeEventListener('click',      _askOnFirstGesture);
                    if (Notification.permission === 'default') {
                        requestNotifPermission();
                    }
                };
                document.addEventListener('touchstart', _askOnFirstGesture, { once: true, passive: true });
                document.addEventListener('click',      _askOnFirstGesture, { once: true });
            }
            updateNotifStatusUI();
        }

        // ── RESTABLECER NOTIFICACIONES (borra historial de rechazo) ────
        function resetNotifState() {
            localStorage.removeItem('c5x_notif_asked');
            localStorage.removeItem('c5x_notif_dismissed');
            localStorage.removeItem('c5x_notif_perm');
            notifGranted = false;
            updateNotifStatusUI();
            if (Notification.permission === 'default') {
                setTimeout(showNotifBanner, 500);
                showToast('🔔 Sistema de notificaciones restablecido', 2500, false, true);
            } else if (Notification.permission === 'denied') {
                showToast('⚙️ Permiso bloqueado. Ve a Ajustes del sistema → 5X → Notificaciones', 5000);
            } else {
                showToast('✅ Notificaciones ya están activas', 2500, false, true);
            }
        }

        function updateNotifStatusUI() {
            const dot      = document.getElementById('notifStatusDot');
            const label    = document.getElementById('notifStatusLabel');
            const btnTest  = document.getElementById('notifSettingsBtn');
            const btnOpen  = document.getElementById('notifOpenSettingsBtn');
            const hint     = document.getElementById('notifDeniedHint');
            if (!dot) return;
            const perm = ('Notification' in window) ? Notification.permission : 'unavailable';
            dot.className = 'notif-status-dot ' + (perm === 'granted' ? 'granted' : perm === 'denied' ? 'denied' : '');
            if (label) {
                label.textContent = perm === 'granted' ? 'ACTIVAS' : perm === 'denied' ? 'BLOQUEADAS' : 'PENDIENTE';
                label.style.color = perm === 'granted' ? 'var(--long)' : perm === 'denied' ? 'var(--short)' : 'var(--text-tertiary)';
            }
            if (btnTest) btnTest.style.display = perm === 'granted' ? 'inline-flex' : 'none';
            if (btnOpen) btnOpen.style.display = perm === 'denied'  ? 'inline-flex' : 'none';
            if (hint)    hint.style.display    = 'none';
        }

        function handleNotifSettingsBtn() {
            const perm = ('Notification' in window) ? Notification.permission : 'unavailable';
            if (perm === 'granted') {
                // Probar notificación
                sendNativeNotif('🔔 5X — Prueba', 'Las notificaciones funcionan correctamente.', { tag: 'c5x-test', requireInteraction: false });
                showToast('🔔 Notificación de prueba enviada', 2000, false, true);
            } else if (perm === 'denied') {
                showToast('⚙️ Abre Ajustes del sistema → Notificaciones → 5X', 4000);
            } else {
                requestNotifPermission();
            }
        }
        // Tema: preferencia manual > sistema del teléfono
        (function() {
            const saved = localStorage.getItem('theme');
            const sysDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const dark = saved === 'dark' || (!saved && sysDark);
            if (!dark) document.documentElement.classList.add('pre-light');
        })();
        let isLight = false; // gestionado por applyTheme() al init
        // Bloquear tema del sistema — solo cambia manualmente
        (function() {
            const style = document.createElement('style');
            style.textContent = ':root { color-scheme: only light !important; }';
            document.head.appendChild(style);
        })();
        let isPrivateMode = true; 
        
        function createEmptySlots() { return Array(10).fill(null).map(() => ({ name:'', price:0, capital:5, buys:[], strat:'normal', locked: true, note: '', alerted: false, multipleBuys: {}, rebuyCount: 0, rebuyOldSpent: 0, rebuyOldQty: 0 })); }
        let storedReal = localStorage.getItem('c5x_slots_real');
        let slots = storedReal ? JSON.parse(storedReal) : createEmptySlots();
        
        // ASEGURAR que TODOS los slots tengan la estructura correcta y solo estrategia normal
        slots.forEach(s => { 
            if (!s.buys) s.buys = [];
            if (!s.multipleBuys) s.multipleBuys = {};
            s.strat = 'normal';
            if (typeof s.locked === 'undefined') s.locked = true;
            if (!s.capital) s.capital = 5;
            if (!s.note) s.note = '';
            if (typeof s.alerted === 'undefined') s.alerted = false;
            // Migrar rebuyDone (boolean legacy) → rebuyCount (0-3)
            if (typeof s.rebuyCount === 'undefined') {
                s.rebuyCount = (s.rebuyDone === true) ? 1 : 0;
            }
            delete s.rebuyDone; delete s.rebuyBase; delete s.roi;
            if (!s.rebuyOldSpent) s.rebuyOldSpent = 0;
            if (!s.rebuyOldQty)   s.rebuyOldQty   = 0;
        });
        
        // Asegurar que tengamos exactamente 10 slots (dashboards de trading)
        while(slots.length < 10) {
            slots.push({ 
                name:'', 
                price:0, 
                capital:5, 
                buys:[], 
                strat:'normal', 
                locked: true, 
                note: '', 
                alerted: false,
                multipleBuys: {},
                rebuyCount: 0,
                rebuyOldSpent: 0,
                rebuyOldQty: 0
            });
        }
        // Recortar a 10 si hay más (evita slots ocultos)
        if (slots.length > 10) slots = slots.slice(0, 10);
        
        let activeIdx = parseInt(localStorage.getItem('c5x_last_slot')); if(isNaN(activeIdx) || activeIdx < 0 || activeIdx >= slots.length) activeIdx = 0;

        // ── MULTI-DASHBOARD: renderiza las 10 tarjetas del Panel 1 ──
        function renderAllDashboards() {
            const container = document.getElementById('dashboardsContainer');
            if (!container) return;
            container.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const s = slots[i] || {};
                const isActive = (i === activeIdx);
                const coinName = s.name || '---';
                const coinColor = getCoinColor(s.name);
                const basePrice = s.price > 0 ? (s.price < 1 ? s.price.toFixed(6) : s.price.toFixed(4)) : '0.0000';
                const invested = getSlotInvested(i);
                // Badge de número de slot siempre visible
                const rankEmojis = ['🥇','🥈','🥉','4️⃣','5️⃣','6️⃣','7️⃣','8️⃣','9️⃣','🔟'];
                const rankClasses = ['rank-1','rank-2','rank-3','rank-4','rank-5','rank-6','rank-7','rank-8','rank-9','rank-10'];
                let rankBadge = '';
                if (invested > 0) {
                    rankBadge = `<span class="slot-rank-badge ${rankClasses[i] || ''}">${rankEmojis[i] || '#'+(i+1)} #${i+1}</span>`;
                }
                const card = document.createElement('div');
                card.className = 'dashboard-card' + (isActive ? ' slot-active' : '');
                card.id = 'dashCard-' + i;
                // ── INTERACCIÓN NUEVA ──────────────────────────────────
                // 1 tap   → seleccionar slot (sin navegar al Panel 3)
                // 2 taps  → abrir Panel 3 con gráfico + 12 niveles
                // ──────────────────────────────────────────────────────
                (function(idx) {
                    let _lastTap = 0;
                    card.addEventListener('click', (e) => {
                        // Ignorar clicks en elementos hijos interactivos
                        if (e.target.closest('[ontouchstart],[onmousedown],button,.trading-manual-btn,.dash-cell-sell')) return;
                        const now = Date.now();
                        const isDouble = (now - _lastTap) < 340;
                        _lastTap = isDouble ? 0 : now;
                        if (isDouble) {
                            // DOBLE TAP → abrir Panel 3
                            if (idx !== activeIdx) selectSlot(idx);
                            goToSlotLevels(idx);
                        } else {
                            // SIMPLE TAP → solo seleccionar slot
                            if (idx !== activeIdx) {
                                activateDashSlot(idx);
                            } else {
                                triggerHaptic();
                            }
                        }
                    });
                })(i);
                card.innerHTML = `
                    <div class="dash-compact-grid">
                        <!-- 1: ACTIVO -->
                        <div class="dash-cell-coin" id="basePriceBox-${i}">
                            <span class="dash-cell-coin-label">ACTIVO</span>
                            <div id="dashTradingCoin-${i}" class="dash-cell-coin-name" style="color:${coinColor};">${coinName}</div>
                        </div>
                        <!-- 2: BASE -->
                        <div class="dash-cell" id="dashBaseCell-${i}">
                            <span class="dash-cell-label">BASE</span>
                            <span class="dash-cell-value" id="dashBaseDisplay-${i}">${basePrice}</span>
                        </div>
                        <!-- 3: INVERSIÓN -->
                        <div class="dash-cell" id="investmentBox-${i}">
                            <span class="dash-cell-label">INVERSIÓN</span>
                            <span class="dash-cell-value" id="resInv-${i}">$0.00</span>
                        </div>
                        <!-- 4: PROMEDIO -->
                        <div class="dash-cell" id="avgCell-${i}">
                            <span class="dash-cell-label">PROMEDIO</span>
                            <span class="dash-cell-value" id="resAvg-${i}">0.0000</span>
                        </div>
                        <!-- 5: VENTA -->
                        <div class="dash-cell-sell" onclick="event.stopPropagation();dashOpenSell(${i},event);" title="Objetivos de venta">
                            <svg class="dash-cell-sell-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="5"/><circle cx="12" cy="12" r="1" fill="#fbbf24"/></svg>
                            <span class="dash-cell-sell-lbl">VENTA</span>
                        </div>
                        <!-- 6: OBJETIVO -->
                        <div class="dash-cell" id="targetSection-${i}"
                            ontouchstart="if(activeIdx===${i})startSellPress(event)" ontouchend="if(activeIdx===${i})endSellPress(event)"
                            onmousedown="if(activeIdx===${i})startSellPress(event)" onmouseup="if(activeIdx===${i})endSellPress(event)" onmouseleave="if(activeIdx===${i})cancelSellPress()"
                            style="cursor:pointer;">
                            <span class="dash-cell-label">OBJETIVO</span>
                            <span class="dash-cell-value" id="resTarget-${i}" style="font-size:9px;line-height:1.6;">0.0000</span>
                        </div>
                    </div>
                    <!-- elementos ocultos para JS (PNL y modo) -->
                    <div style="display:none;" id="dashPnlCell-${i}">
                        <span id="dashLiveRoi-${i}">—</span>
                        <span id="dashLivePnlDol-${i}">—</span>
                    </div>
                    <div style="display:none;" id="tradingModeBtn-${i}">
                        <span id="tradingModeText-${i}">MANUAL</span>
                        <span id="tradingModeIndicator-${i}">ESPERANDO</span>
                    </div>
                    <div class="dash-recovery-row" id="dashRecRow-${i}" style="display:none;">
                        <span class="dash-rec-label">RECUP.</span>
                        <div class="dash-rec-track"><div class="dash-rec-fill" id="dashRecFill-${i}" style="width:0%"></div></div>
                        <span class="dash-rec-pct" id="dashRecPct-${i}">—</span>
                    </div>`;
                container.appendChild(card);
            }
            // Actualizar stats de todos los slots
            for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
            updateTradingModeUIAll();
            // Reset any flipped cards on re-render
            Object.keys(_dashFlipped).forEach(k => { _dashFlipped[k] = false; });
        }

        // Activar slot en Panel 2 (dashboards) — solo cambia slot activo
        function activateDashSlot(i) {
            if (i === activeIdx) return; // ya activo, nada que hacer
            selectSlot(i);
            // Actualizar clases activas en los cards sin reconstruir el DOM completo
            document.querySelectorAll('.dashboard-card').forEach((card, idx) => {
                const isNowActive = (idx === i);
                card.classList.toggle('slot-active', isNowActive);
                const lbl = card.querySelector('.dash-slot-label');
                if (lbl) {
                    const coin = (slots[idx] && slots[idx].name) ? '' : '';
                    lbl.textContent = 'SLOT ' + (idx+1) + (isNowActive ? ' ● ACTIVO' : '');
                }
                const btn = card.querySelector('[id^="tradingModeBtn-"]');
                if (btn) btn.style.opacity = isNowActive ? '1' : '0.5';
            });
            // Si el usuario YA estaba viendo Panel 3, actualizar niveles también
            if (currentPanel === 2) forceRenderLevels(i);
        }

        // Ir directo al Panel 3 (12 niveles) del slot i — la función principal
        function goToSlotLevels(i) {
            triggerHaptic();
            // 1. Activar el slot sin re-renderizar el dashboard (evita flash)
            activeIdx = i;
            localStorage.setItem('c5x_last_slot', i);
            const s = slots[i];
            // Actualizar inputs — SIEMPRE restaurar precio real del slot
            const cIn = document.getElementById('coinInput');
            if (cIn) { cIn.value = s ? (s.name || '') : ''; }
            const bIn = document.getElementById('baseInput');
            if (bIn) {
                const precio = s && s.price > 0 ? s.price : (s && s.initialPrice > 0 ? s.initialPrice : '');
                bIn.value = precio;
                if (precio) { bIn.setAttribute('readonly', true); bIn.classList.add('locked-input'); }
            }
            // Resaltar tarjeta activa sin recrear el DOM
            document.querySelectorAll('.dashboard-card').forEach((card, idx) => {
                card.classList.toggle('slot-active', idx === i);
                const lbl = card.querySelector('.dash-slot-label');
                if (lbl) lbl.textContent = 'SLOT ' + (idx+1) + (idx === i ? ' ● ACTIVO' : '');
                const btn = card.querySelector('[id^="tradingModeBtn-"]');
                if (btn) btn.style.opacity = idx === i ? '1' : '0.5';
            });
            updateDashUI();
            // Sincronizar barra superior Panel 3: coin + modo + PNL reset
            const coinLbl = document.getElementById('levelsPanelCoinLabel');
            if (coinLbl) {
                coinLbl.textContent = (s && s.name) ? s.name : '---';
                coinLbl.style.color = (s && s.name) ? getCoinColor(s.name) : '';
            }
            // Resetear PNL hasta que llegue el primer tick
            const p3Pct0 = document.getElementById('levelsPanelPnlPct');
            const p3Dol0 = document.getElementById('levelsPanelPnlDol');
            if (p3Pct0) { p3Pct0.textContent = '—'; p3Pct0.style.color = ''; }
            if (p3Dol0) { p3Dol0.textContent = '—'; p3Dol0.style.color = ''; }
            updateTradingModeUIAll();
            // 2. Renderizar niveles inmediatamente (síncronamente)
            forceRenderLevels(i);
            // 3. Navegar al Panel 3 y registrar en historial para back gesture
            switchPanel(2);
            if (window.innerWidth < 1024) {
                window.history.pushState({ c5xView: 'operate', c5xPanel: 1 }, '', '#dashboards');
            }
            // 4. Backup: segundo render tras la animación de panel
            setTimeout(() => forceRenderLevels(i), 320);
        }

        // Cerrar Panel 3 y volver a los dashboards (Panel 1)
        function closeLevelsPanel() {
            triggerHaptic();
            switchPanel(1);
            // Reconstruir dashboards frescos al volver
            setTimeout(renderAllDashboards, 50);
        }

        // Renderizar niveles del slot i de forma forzada y confiable
        function forceRenderLevels(slotIdx) {
            const grid = document.getElementById('levelsGrid');
            if (!grid) return;
            activeIdx = slotIdx; // garantizar que activeIdx es correcto
            renderLevels();
            // Cargar chart del símbolo correcto
            const sym = slots[slotIdx] && slots[slotIdx].name ? slots[slotIdx].name : 'BTC5L';
            if (sym) setTimeout(() => loadChart2(sym), 80);
            activeIdx = slotIdx; // mantener correcto tras renderLevels
        }
        // Tap en nombre de moneda → panel 2 (Chart2 + 12 Niveles)
        function openCoinInLevels(slotIdx) {
            goToSlotLevels(slotIdx); // unificado
        }
        let activeTF = localStorage.getItem('c5x_last_tf') || '60';
        let chartSymbol = '';
        let history = JSON.parse(localStorage.getItem('c5x_history')) || [];
        let strategyParams = JSON.parse(localStorage.getItem('c5x_strategy_params')) || { normal: { capital: 5, inc: 6, desc: 16, dd: 16 } };
        
        // Bot config
        let botConfig = JSON.parse(localStorage.getItem('c5x_bot_config')) || {
            enabled:      true,
            normalProfit: 120,
            autoRoi:      120,
            checkInterval: 30,
            crashDrop:     8,    // % caída en 2min para detectar crash activo
            crashFast:     3,    // % caída en 2min para "caída rápida"
            crashWindow:   5,    // minutos para medir velocidad de precio
            maxLevels:    12,
            restartDelay:  0,
            velBoost:     true,
            contextAware: true,
            circuitBreaker: 70,
            circuitEnabled: false,
            crashEnabled:   false,
            // ── ESTRATEGIA DE SALIDAS ──────────────────────────────────
            // TP1: precio = avg + tp1Pct(50%) → vende 50% del activo
            // TRAILING: cuando el 50% restante llega a avg + trailActivePct(100%)
            //           se activa un trailing stop. El activo sigue corriendo
            //           hasta que el precio retrocede trailDropPct(15%) desde su máximo.
            // REBUY: si tras TP1 el activo cae rebuyDropPct(16%) desde el precio
            //        de venta de TP1 → reactiva 12 niveles. Solo ocurre 1 vez.
            tp1Pct:         50,   // TP1: avg + 50% → vende 50%
            trailActivePct: 100,  // TRAILING ACTIVA cuando avg + 100% (2da mitad)
            trailDropPct:    15,  // Retroceso desde máximo → vende el resto
            rebuyDropPct:    16,  // Caída desde precio TP1 → reactivar 12 niveles (hasta 3 veces)
            rebalPause:      true
        };
        // ── Migración y valores faltantes ──────────────────────────────
        if (!botConfig.autoRoi)        botConfig.autoRoi        = 120;
        if (!botConfig.normalProfit)   botConfig.normalProfit   = 120;
        if (!botConfig.velBoost)       botConfig.velBoost       = true;
        if (!botConfig.contextAware)   botConfig.contextAware   = true;
        if (!botConfig.circuitBreaker) botConfig.circuitBreaker = 70;
        if (botConfig.circuitEnabled === undefined) botConfig.circuitEnabled = false;
        if (botConfig.crashEnabled   === undefined) botConfig.crashEnabled   = false;
        if (!botConfig.crashDrop)      botConfig.crashDrop      = 8;
        if (!botConfig.crashFast)      botConfig.crashFast      = 3;
        if (botConfig.rebalPause     === undefined) botConfig.rebalPause     = true;
        if (botConfig.tp1Pct         === undefined) botConfig.tp1Pct         = 50;
        if (!botConfig.trailActivePct) botConfig.trailActivePct = 100;
        if (!botConfig.trailDropPct)   botConfig.trailDropPct   = 15;
        if (!botConfig.rebuyDropPct)   botConfig.rebuyDropPct   = 16;
        // Limpiar campos obsoletos migrados
        delete botConfig.tp2BaseMulti;
        delete botConfig.tp2FallbackPct;
        delete botConfig.trailingStop;
        // Historial de precios — Fix #2: se restaura de sessionStorage en recargas
        let priceHistory = (function() {
            try {
                const raw = sessionStorage.getItem('c5x_price_hist');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    const cutoff = Date.now() - 4 * 60 * 60 * 1000;
                    Object.keys(parsed).forEach(sym => {
                        parsed[sym] = (parsed[sym] || []).filter(p => p.time > cutoff);
                        if (!parsed[sym].length) delete parsed[sym];
                    });
                    return parsed;
                }
            } catch(_) {}
            return {};
        })();
        setInterval(function() {
            try {
                const now = Date.now(), compressed = {};
                Object.keys(priceHistory).forEach(sym => {
                    const buckets = {};
                    (priceHistory[sym] || []).forEach(p => {
                        const min = Math.floor(p.time / 60000);
                        if (!buckets[min]) buckets[min] = p;
                    });
                    const pts = Object.values(buckets)
                        .filter(p => now - p.time < 4 * 60 * 60 * 1000)
                        .sort((a, b) => a.time - b.time).slice(-240);
                    if (pts.length) compressed[sym] = pts;
                });
                sessionStorage.setItem('c5x_price_hist', JSON.stringify(compressed));
            } catch(_) {}
        }, 30000);
        // Slots pausados por anti-crash: {slotIdx: pauseUntilTimestamp}
        // FIX PERSISTENCIA CIRCUIT BREAKER: cargar desde localStorage al inicio
        // Antes: objeto en memoria — se perdía al recargar la página
        // Ahora: se restaura la pausa activa. Si hay un colapso en curso y el usuario
        // recarga, el bot NO reanuda compras hasta que expire el timer.
        let crashPausedSlots = (() => {
            try {
                const saved = JSON.parse(localStorage.getItem('c5x_circuit_pauses') || '{}');
                const now = Date.now();
                // Filtrar pausas ya expiradas para no restaurar estados viejos
                const valid = {};
                Object.entries(saved).forEach(([k, ts]) => {
                    if (typeof ts === 'number' && ts > now) valid[k] = ts;
                });
                return valid;
            } catch(e) { return {}; }
        })();
        function _saveCrashPauses() {
            try { localStorage.setItem('c5x_circuit_pauses', JSON.stringify(crashPausedSlots)); } catch(e) {}
        }
        // Timers de reinicio automático: {slotIdx: timeoutId}
        let autoRestartTimers = {};
        
        if (!strategyParams.normal) strategyParams.normal = { capital: 5, inc: 6, desc: 16, dd: 16 };
        
        let currentSection = 'operate';
        let modalCallback = null;
        let customMultipliers = JSON.parse(localStorage.getItem('c5x_multipliers')) || [1.0, 1.0, 1.5, 1.5, 2.0, 2.0, 5.0, 5.0, 8.0, 8.0, 16.0, 16.0];
        let etfFavorites = JSON.parse(localStorage.getItem('c5x_etf_favorites')) || [];
        let globalCapital = parseFloat(localStorage.getItem('c5x_global_capital')) || 0; 
        let availableUSDT = 1000.00; // USDT disponible (se actualizará desde Gate.io)
        let exchangeFee = parseFloat(localStorage.getItem('c5x_fee')) || 0.1;
        // ── FIX ADMIN-CLIENT-SIDE: PIN nunca viaja en texto plano ──────
        // El PIN se guarda como hash SHA-256. La clave 'c5x_config' ya no
        // contiene el PIN raw — sólo 'dd' y configuraciones no-sensibles.
        let appConfig = JSON.parse(localStorage.getItem('c5x_config')) || { dd: 10 };
        // Hash de '2524' como PIN por defecto (SHA-256, primeros 16 hex)
        const _DEFAULT_PIN_HASH = '228971770cc3111e';
        function _hashPin(raw) {
            return CryptoJS.SHA256(raw).toString().substring(0, 16);
        }
        // Migrar instalaciones antiguas que aún tengan pin en texto plano
        (function _migratePinIfNeeded() {
            const stored = localStorage.getItem('c5x_config');
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (parsed.pin && parsed.pin.length <= 6) {
                        localStorage.setItem('c5x_pin_hash', _hashPin(parsed.pin));
                        delete parsed.pin;
                        localStorage.setItem('c5x_config', JSON.stringify(parsed));
                        appConfig = parsed;
                    }
                } catch(e) {}
            }
            // Corregir hash incorrecto de versiones anteriores
            const h = localStorage.getItem('c5x_pin_hash');
            if (!h || h === 'cb5369e70e82be7b3a5895b8fc28b1e0') {
                localStorage.setItem('c5x_pin_hash', _DEFAULT_PIN_HASH);
            }
        })();
        // ── FIX TIMEZONE: helpers con detección automática de zona horaria ──
        // Antes: toLocaleTimeString('es', ...) → hardcoded a España
        // Ahora: Intl.DateTimeFormat detecta la timezone real del dispositivo
        const _userTZ = Intl.DateTimeFormat().resolvedOptions().timeZone;
        function _fmtTime(d) {
            return new Intl.DateTimeFormat(undefined, {
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hour12: false, timeZone: _userTZ
            }).format(d instanceof Date ? d : new Date(d));
        }
        function _fmtTimeShort(d) {
            return new Intl.DateTimeFormat(undefined, {
                hour: '2-digit', minute: '2-digit',
                hour12: false, timeZone: _userTZ
            }).format(d instanceof Date ? d : new Date(d));
        }
        function _fmtDate(d) {
            return new Intl.DateTimeFormat(undefined, {
                year: 'numeric', month: '2-digit', day: '2-digit',
                timeZone: _userTZ
            }).format(d instanceof Date ? d : new Date(d));
        }
        // ── FIX 2: apiConfig comienza vacío — se carga async desde IDB en init() ──
        // Las keys NUNCA se leen de localStorage. El cargador IDB está en init().
        let apiConfig = { key: '', secret: '' };
        let _rawTickerAssets = (() => {
            try { return JSON.parse(localStorage.getItem('c5x_ticker_assets')) || []; } catch(e) { return []; }
        })();
        // Siempre garantizar las monedas base aunque localStorage esté vacío o corrupto
        const _BASE_COINS = ["BTC","ETH","SUI","AVAX","BNB"];
        if (!_rawTickerAssets.length) _rawTickerAssets = [..._BASE_COINS];
        // Asegurar que las base coins siempre estén incluidas
        _BASE_COINS.forEach(c => { if (!_rawTickerAssets.includes(c)) _rawTickerAssets.unshift(c); });
        let tickerAssets = _rawTickerAssets.filter(t => t && !t.match(/[35][LS]/));
        localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets)); 
        let isTickerPinned = localStorage.getItem('c5x_ticker_pinned') === 'true'; 
        let assetIdx = parseInt(localStorage.getItem('c5x_ticker_index')) || 0; 
        let currentTickerSymbol = "BTC";
        let currentWs = null; 
        let tickerIntervalId = null;
        let tickerSpeed = parseInt(localStorage.getItem('c5x_ticker_speed')) || 7;
        let radarLimit = parseInt(localStorage.getItem('c5x_radar_limit')) || 10; 
        let radarSpeed = parseInt(localStorage.getItem('c5x_radar_speed')) || 7; 
        let autoAdjustThreshold = parseFloat(localStorage.getItem('c5x_auto_adjust_threshold')) || 3; 
        let allGateETFs = []; let topDroppers = []; let dropperIdx = 0; let radarQueue = [];
        let radarIntervalId = null;
        let monitorLimit = parseInt(localStorage.getItem('c5x_monitor_limit')) || 10;
        // Modo de trading POR SLOT (no global) — cada slot tiene su propio modo
        let slotModes = JSON.parse(localStorage.getItem('c5x_slot_modes') || 'null') || ['manual','manual','manual','manual','manual','manual','manual','manual','manual','manual'];
        // BUG FIX: Si slotModes viene de una versión anterior con solo 5 entradas, extender a 10
        while (slotModes.length < 10) slotModes.push('manual');
        // Helper: modo del slot activo (alias para compatibilidad)
        function getActiveMode() { return slotModes[activeIdx] || 'manual'; }
        function setSlotMode(idx, mode) { slotModes[idx] = mode; localStorage.setItem('c5x_slot_modes', JSON.stringify(slotModes)); }
        // Legacy compat — tradingMode siempre refleja el slot activo
        Object.defineProperty(window, 'tradingMode', { get: () => getActiveMode(), set: (v) => setSlotMode(activeIdx, v) });
        let activeOrders = {}; 
        let isHeaderPinnedByScroll = false;
        let tickerPressTimer = null; let tickerLongPressTriggered = false;
        let tradingPressTimer = null; let strategyPressTimer = null; let modePressTimer = null; let longPressTriggered = false;
        let isETFMonitorVisible = true;
        let clearSlotPressTimer = null; let clearSlotLongPressTriggered = false;
        let etfSearchPressTimer = null; let etfSearchLongPressTriggered = false;
        let sellMonitorInterval = null; // declarado aquí para evitar TDZ en executeSellOption/executeSellNow

        // ── TRAILING BACKGROUND NOTIFIER ────────────────────────────────
        // Cuando el trailing está activo en modo MANUAL, envía recordatorios periódicos
        // para que el usuario sepa que debe mantener la app activa.
        let _trailReminderTimer = null;
        const _TRAIL_REMINDER_MS = 120000; // recordatorio cada 2 minutos

        function startTrailReminder(sym, trailActPct, trailDropPct) {
            stopTrailReminder();
            _trailReminderTimer = setInterval(() => {
                const t = activeSellTarget;
                if (!t || (!t.trailActivated && t.type !== 'trail_active')) {
                    stopTrailReminder();
                    return;
                }
                const live = allGateETFs && allGateETFs.find(e => e.currency_pair === sym + '_USDT');
                const lp   = live ? parseFloat(live.last) : 0;
                const avg  = t.avgPrice || 0;
                const roiNow = avg > 0 && lp > 0 ? ((lp - avg) / avg * 100).toFixed(1) : '—';
                const maxStr = t.trailMax && t.trailMax > 0 ? (t.trailMax < 1 ? '$'+t.trailMax.toFixed(6) : '$'+t.trailMax.toFixed(4)) : '—';

                if (t.trailActivated) {
                    sendNativeNotif(
                        `📈 TRAILING ACTIVO — ${sym}`,
                        `+${roiNow}% · Máx: ${maxStr} · Stop si cae -${trailDropPct}% · Mantén la app abierta`,
                        { tag: 'c5x-trail-reminder-' + sym, requireInteraction: false, vibrate: [100, 50, 100] }
                    );
                } else {
                    // Trailing armado, esperando activación
                    sendNativeNotif(
                        `⏳ TRAILING ARMADO — ${sym}`,
                        `+${roiNow}% · Activa a avg+${trailActPct}% · Mantén la app abierta`,
                        { tag: 'c5x-trail-arm-' + sym, requireInteraction: false, vibrate: [50] }
                    );
                }
            }, _TRAIL_REMINDER_MS);
        }
        function stopTrailReminder() {
            if (_trailReminderTimer) { clearInterval(_trailReminderTimer); _trailReminderTimer = null; }
        }

        function handleTickerTouchStart(e) { startTickerPress(); }
        function handleTickerTouchEnd(e) { endTickerPress(); }
        function handleTickerMouseDown(e) { if(e.type==='touchstart')return; startTickerPress(); }
        function handleTickerMouseUp(e) { endTickerPress(); }
        function startTickerPress() { tickerLongPressTriggered = false; tickerPressTimer = setTimeout(() => { tickerLongPressTriggered = true; toggleTickerPin(); }, 1600); }
        function endTickerPress() { if(tickerPressTimer) clearTimeout(tickerPressTimer); }
        function cancelTickerPress() { if(tickerPressTimer) clearTimeout(tickerPressTimer); }
        
        function startClearSlotPress(e) {
            if (e) e.preventDefault();
            clearSlotLongPressTriggered = false;
            const cell = document.getElementById('avgCell-' + activeIdx);
            if (cell) cell.classList.add('pressing');
            clearSlotPressTimer = setTimeout(() => {
                clearSlotLongPressTriggered = true;
                if (cell) cell.classList.remove('pressing');
                clearCurrentSlot();
                triggerHaptic();
                if(navigator.vibrate) navigator.vibrate([100, 50, 100]);
            }, 2000); 
        }
        function cancelClearSlotPress() { 
            if (clearSlotPressTimer) { clearTimeout(clearSlotPressTimer); clearSlotPressTimer = null; } 
            const cell = document.getElementById('avgCell-' + activeIdx);
            if (cell) cell.classList.remove('pressing');
            if (!clearSlotLongPressTriggered) { showHoldHint('Limpiar Slot'); } 
            clearSlotLongPressTriggered = false; 
        }
        
        function clearCurrentSlot() {
            const s = slots[activeIdx];
            if (!s.name) {
                showToast("⚠️ El slot ya está vacío");
                return;
            }
            s.name = '';
            s.price = 0;
            s.capital = 5;
            s.buys = [];
            s.strat = 'normal';
            s.note = '';
            s.alerted = false;
            s.multipleBuys = {};
            s.rebuyCount = 0;
            s.rebuyOldSpent = 0;
            s.rebuyOldQty   = 0;
            setSlotMode(activeIdx, 'manual');
            // Cancelar timer de reinicio auto si existe
            if (autoRestartTimers[activeIdx]) { clearTimeout(autoRestartTimers[activeIdx]); delete autoRestartTimers[activeIdx]; }
            delete trailingStopData[activeIdx];
            delete crashPausedSlots[activeIdx];
            delete crashPausedSlots[activeIdx + '_circuit'];
            _saveCrashPauses(); // FIX: limpiar pausa al resetear slot
            for (let i = 0; i < 12; i++) {
                const key = getOrderKey(activeIdx, i);
                if (activeOrders[key]) {
                    delete activeOrders[key];
                }
            }
            save();
            saveActiveOrders();
            saveInvestmentValue(); 
            
            sortSlots();
            
            selectSlot(0);
            renderAllDashboards();
            
            showToast("🗑️ Slot limpiado y movido al final");
        }
        
        function showHoldHint(action) { showToast(`👆 Mantén presionado para ${action}`); }
        function getOrderKey(slotIdx, levelIdx) { return `s${slotIdx}_l${levelIdx}`; }
        function toggleETFMonitor() { triggerHaptic(); const etfList = document.getElementById('desktop-etf-list'); const toggleBtn = document.getElementById('etfMonitorToggleBtn'); const toggleIcon = document.getElementById('etfToggleIcon'); isETFMonitorVisible = !isETFMonitorVisible; if (isETFMonitorVisible) { etfList.classList.remove('collapsed'); toggleBtn.classList.remove('collapsed'); toggleIcon.classList.remove('rotated'); } else { etfList.classList.add('collapsed'); toggleBtn.classList.add('collapsed'); toggleIcon.classList.add('rotated'); } localStorage.setItem('c5x_etf_monitor_visible', isETFMonitorVisible); }
        
        function loadETFMonitorState() { const saved = localStorage.getItem('c5x_etf_monitor_visible'); if (saved !== null) { isETFMonitorVisible = saved === 'true'; if (!isETFMonitorVisible) { const etfList = document.getElementById('desktop-etf-list'); const toggleBtn = document.getElementById('etfMonitorToggleBtn'); const toggleIcon = document.getElementById('etfToggleIcon'); if (etfList) etfList.classList.add('collapsed'); if (toggleBtn) toggleBtn.classList.add('collapsed'); if (toggleIcon) toggleIcon.classList.add('rotated'); } } }
        let sellScrollStartY = 0;
        let sellScrollStartTime = 0;
        let isSellScrolling = false;
        let sellPressTimer = null;
        let activeSellTarget = null; // {type: 'now'|50|75|100, targetPrice: number, avgPrice: number}
        
        function startSellPress(e) { 
            sellScrollStartY = e.touches ? e.touches[0].clientY : e.clientY;
            sellScrollStartTime = Date.now();
            isSellScrolling = false;
            
            const btnEl = document.getElementById('targetSection-' + activeIdx);
            if (btnEl) btnEl.classList.add('pressing');
            
            sellPressTimer = setTimeout(() => { 
                if (!isSellScrolling) {
                    if (navigator.vibrate) navigator.vibrate([80, 50, 80]);
                    if (btnEl) btnEl.classList.remove('pressing');
                    openSellOptionsModal();
                }
            }, 2400);
        }
        
        function endSellPress(e) { 
            const currentY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            const scrollDistance = Math.abs(currentY - sellScrollStartY);
            const scrollTime = Date.now() - sellScrollStartTime;
            
            const btnEl = document.getElementById('targetSection-' + activeIdx);
            if (btnEl) btnEl.classList.remove('pressing');
            
            if (scrollDistance > 10 || scrollTime < 150) {
                isSellScrolling = true;
            }
            
            if (sellPressTimer) clearTimeout(sellPressTimer);
        }
        
        function cancelSellPress() { 
            isSellScrolling = true;
            const btnEl = document.getElementById('targetSection-' + activeIdx);
            if (btnEl) btnEl.classList.remove('pressing');
            if (sellPressTimer) clearTimeout(sellPressTimer);
        }
        
        function openSellOptionsModal() {
            const s = slots[activeIdx];
            if (!s || !s.name || s.buys.length === 0) {
                return showToast("⚠️ No hay compras para vender");
            }
            const avg = calculateAvgPriceForSlotData(s, activeIdx);
            if (avg <= 0) return showToast("⚠️ Sin precio promedio");

            const tp1Pct      = botConfig.tp1Pct        || 50;
            const trailActPct = botConfig.trailActivePct || 100;
            const trailDrop   = botConfig.trailDropPct   || 15;
            const live        = allGateETFs && allGateETFs.find(t => t.currency_pair === s.name + '_USDT');
            const lp          = live ? parseFloat(live.last) : 0;
            const inv         = getSlotInvested(activeIdx);
            const qty         = avg > 0 && inv > 0 ? inv / avg : 0;
            const totalUsd    = lp > 0 && qty > 0 ? lp * qty : 0;
            const pnlPct      = avg > 0 && lp > 0 ? ((lp - avg) / avg) * 100 : 0;
            const pnlUsd      = inv > 0 ? (pnlPct / 100) * inv : 0;
            const fP  = p => p <= 0 ? '$—' : p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : '$'+p.toFixed(2);
            const fU  = v => '$' + Math.abs(v).toFixed(2);
            const _st = (id, v) => { const e = document.getElementById(id); if (e) e.textContent = v; };

            _st('sellModalCoin', s.name);
            _st('sellModalAvg',  'Promedio: ' + fP(avg));
            _st('sellModalCurrentPrice', lp > 0 ? fP(lp) : '$—');

            const pnlEl = document.getElementById('sellModalPnl');
            if (pnlEl) {
                pnlEl.textContent = lp > 0 ? `${pnlUsd >= 0 ? '+' : '-'}${fU(pnlUsd)} (${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%)` : '—';
                pnlEl.style.color = pnlPct >= 0 ? 'var(--long)' : 'var(--short)';
            }

            _st('sellModalTotalUsd', totalUsd > 0 ? '$' + totalUsd.toFixed(2) : lp > 0 ? '...' : '$—');
            _st('sellModalQtyLine',  qty > 0 ? qty.toFixed(4) + ' ' + s.name : '—');
            _st('sellModalInvLine',  inv > 0 ? 'Invertido: $' + inv.toFixed(2) : '—');
            _st('smTp1Pct',    tp1Pct);
            _st('smTp1Price',  fP(avg * (1 + tp1Pct / 100)));
            // Trailing se activa desde precio TP1 + trailActPct%, no desde avg
            const tp1EstPx = avg * (1 + tp1Pct / 100);
            _st('smTrailPct',  trailActPct);
            _st('smTrailPrice', fP(tp1EstPx * (1 + trailActPct / 100)));
            _st('smDropPct',   trailDrop);
            // Rebuy
            _st('smRebuyPct',  botConfig.rebuyDropPct || 16);
            _st('smRebuyCount', s.rebuyCount || (activeSellTarget && activeSellTarget.slotIndex === activeIdx ? activeSellTarget.rebuyCount || 0 : 0));

            // Estado activo
            const statusEl = document.getElementById('sellActiveStatus');
            if (statusEl) {
                if (activeSellTarget && activeSellTarget.slotIndex === activeIdx) {
                    statusEl.style.display = 'block';
                    const t = activeSellTarget;
                    let label = '';
                    if (t.trailActivated || t.type === 'trail_active') {
                        label = '📈 TRAILING ACTIVO — máximo: ' + fP(t.trailMax || 0);
                    } else if (t.tp1Done || t.type === 'trail_arm') {
                        const tp1Px = t.tp1SellPrice || 0;
                        const tp2ActivatePx = tp1Px > 0 ? tp1Px * (1 + trailActPct / 100) : 0;
                        label = '✅ TP1 ejecutado — trailing activa a TP1+' + trailActPct + '% ' + (tp2ActivatePx > 0 ? '(' + fP(tp2ActivatePx) + ')' : '');
                    } else {
                        label = '⏳ Esperando TP1 — objetivo: ' + fP(t.targetPrice || 0);
                    }
                    _st('sellActiveMode',   label);
                    _st('sellActiveDetail', 'Objetivo actual: ' + fP(t.targetPrice || 0));
                } else {
                    statusEl.style.display = 'none';
                }
            }

            document.getElementById('sellOptionsModal').style.display = 'flex';
            setTimeout(() => document.getElementById('sellOptionsModal').classList.add('show'), 10);
        }
        
        function executeSellOption(option) {
            const s = slots[activeIdx];
            const avgPrice = calculateAvgPriceForSlotData(s, activeIdx);
            
            if (option === 'now') {
                _showHoldConfirmSell(s, avgPrice);
                return;
            } else {
                // Calcular precio objetivo según la opción
                let targetPrice, labelPct;
                if (option === 120 || option === 'tp2' || option === 'trail_arm') {
                    // TP2 se activa desde el precio estimado de TP1 + trailActivePct%
                    const avgNow = calculateAvgPriceForSlotData(s, activeIdx);
                    const trailActivePct = botConfig.trailActivePct || 100;
                    const tp1EstPrice = avgNow * (1 + (botConfig.tp1Pct || 50) / 100); // TP1 estimado
                    targetPrice = tp1EstPrice * (1 + trailActivePct / 100);
                    labelPct = `TRAILING TP1+${trailActivePct}%`;
                } else {
                    targetPrice = avgPrice * (1 + (option / 100));
                    labelPct = `+${option}%`;
                }
                
                activeSellTarget = {
                    slotIndex: activeIdx,
                    type: option,
                    targetPrice: targetPrice,
                    avgPrice: avgPrice,
                    basePrice: s.price,
                    symbol: s.name,
                    tp1Done: false  // para tracking de rebuy en checkSellTargets
                };
                
                localStorage.setItem('c5x_sell_target', JSON.stringify(activeSellTarget));
                closeModals();
                
                const targetSection = document.getElementById('targetSection-' + activeIdx);
                if (targetSection) {
                    targetSection.style.borderColor = 'var(--long)';
                    targetSection.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(14, 203, 129, 0.1))';
                }
                const resTarget = document.getElementById('resTarget-' + activeIdx);
                if (resTarget) { updateDashboardStatsForSlot(activeIdx); } // keep dual TP1/TRAIL format
                
                showToast(`🎯 Objetivo: $${targetPrice < 1 ? targetPrice.toFixed(6) : targetPrice.toFixed(4)} (${labelPct})`, 3000, false, true);
                
                if (!sellMonitorInterval) {
                    sellMonitorInterval = setInterval(() => {
                        checkSellTargets();
                    }, 3000);
                }
            }
        }

        // ── Hold-to-confirm modal para ventas críticas ──────────────
        let _holdSellTimer = null;
        let _holdSellInterval = null;
        function _showHoldConfirmSell(s, avgPrice) {
            const existing = document.getElementById('holdSellModal');
            if (existing) existing.remove();

            // Calcular valor total actual
            const live    = allGateETFs && allGateETFs.find(t => t.currency_pair === s.name + '_USDT');
            const lp      = live ? parseFloat(live.last) : 0;
            const inv     = getSlotInvested(activeIdx);
            const qty     = avgPrice > 0 && inv > 0 ? inv / avgPrice : 0;
            const totalUsd = lp > 0 && qty > 0 ? lp * qty : 0;
            const pnlPct  = avgPrice > 0 && lp > 0 ? ((lp - avgPrice) / avgPrice * 100) : 0;
            const pnlUsd  = totalUsd > 0 ? totalUsd - inv : 0;
            const fP = p => p <= 0 ? '$—' : p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : '$'+p.toFixed(2);
            const totalStr  = totalUsd > 0 ? '$' + totalUsd.toFixed(2) : fP(lp);
            const pnlColor  = pnlPct >= 0 ? 'var(--long)' : 'var(--short)';
            const pnlSign   = pnlUsd >= 0 ? '+' : '-';
            const pnlStr    = inv > 0 && totalUsd > 0
                ? `${pnlSign}$${Math.abs(pnlUsd).toFixed(2)} (${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%)`
                : pnlPct !== 0 ? `${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%` : '—';

            const modal = document.createElement('div');
            modal.id = 'holdSellModal';
            modal.style.cssText = 'position:fixed;inset:0;z-index:9998;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;padding:24px;';
            modal.innerHTML = `
                <div style="background:var(--surface);border:2px solid rgba(239,68,68,0.5);border-radius:22px;padding:22px 20px;max-width:310px;width:100%;text-align:center;">
                    <div style="font-size:34px;margin-bottom:8px;">🔴</div>
                    <div style="font-family:'Orbitron';font-size:13px;font-weight:900;color:var(--short);letter-spacing:1px;margin-bottom:4px;">VENDER EN MERCADO</div>
                    <div style="font-family:var(--font-head);font-size:10px;color:var(--text-tertiary);margin-bottom:14px;">${s.name} · precio actual ${fP(lp)}</div>

                    <div style="background:rgba(239,68,68,.08);border:1px solid rgba(239,68,68,.25);border-radius:14px;padding:14px;margin-bottom:14px;">
                        <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);letter-spacing:.8px;margin-bottom:4px;">RECIBIRÁS APROX.</div>
                        <div style="font-family:'Orbitron';font-size:26px;font-weight:900;color:#fff;">${totalStr}</div>
                        <div style="font-family:var(--font-num);font-size:11px;font-weight:700;color:${pnlColor};margin-top:2px;">${pnlStr}</div>
                        ${qty > 0 ? `<div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);margin-top:6px;">${qty.toFixed(4)} ${s.name} × ${fP(lp)}</div>` : ''}
                    </div>

                    <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);margin-bottom:14px;line-height:1.6;">
                        Cierra el <strong style="color:#fff">100%</strong> de la posición.<br>Esta acción no se puede deshacer.
                    </div>

                    <div style="position:relative;height:50px;border-radius:14px;overflow:hidden;margin-bottom:10px;cursor:pointer;user-select:none;"
                         id="holdSellBtn"
                         ontouchstart="_startHoldSell(event)"
                         ontouchend="_cancelHoldSell(event)"
                         ontouchcancel="_cancelHoldSell(event)"
                         onmousedown="_startHoldSell(event)"
                         onmouseup="_cancelHoldSell(event)"
                         onmouseleave="_cancelHoldSell(event)">
                        <div id="holdSellBg"       style="position:absolute;inset:0;background:rgba(239,68,68,.18);border:1.5px solid rgba(239,68,68,.45);border-radius:14px;"></div>
                        <div id="holdSellProgress" style="position:absolute;top:0;left:0;height:100%;width:0%;background:rgba(239,68,68,.6);border-radius:14px;transition:none;"></div>
                        <div style="position:relative;z-index:1;height:100%;display:flex;align-items:center;justify-content:center;gap:8px;">
                            <span style="font-size:16px;">👆</span>
                            <span id="holdSellLabel" style="font-family:var(--font-head);font-size:12px;font-weight:800;color:var(--short);letter-spacing:1px;">MANTÉN 3 SEGUNDOS</span>
                        </div>
                    </div>
                    <button onclick="_cancelHoldSell();document.getElementById('holdSellModal').remove();"
                        style="width:100%;padding:12px;border-radius:12px;background:transparent;border:1px solid var(--border);font-family:var(--font-head);font-size:11px;font-weight:700;color:var(--text-secondary);cursor:pointer;">
                        CANCELAR
                    </button>
                </div>`;
            document.body.appendChild(modal);
        }

        function _startHoldSell(e) {
            if (e && e.cancelable) e.preventDefault();
            const HOLD_MS = 3000;
            const startTime = Date.now();
            const progress = document.getElementById('holdSellProgress');
            const label    = document.getElementById('holdSellLabel');
            _holdSellInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const pct = Math.min((elapsed / HOLD_MS) * 100, 100);
                if (progress) progress.style.width = pct + '%';
                const rem = Math.ceil((HOLD_MS - elapsed) / 1000);
                if (label) label.textContent = rem > 0 ? `MANTÉN ${rem}s...` : '¡SOLTANDO!';
            }, 50);
            _holdSellTimer = setTimeout(() => {
                clearInterval(_holdSellInterval);
                const modal = document.getElementById('holdSellModal');
                if (modal) modal.remove();
                closeModals();
                executeSellNow(slots[activeIdx], activeIdx);
            }, HOLD_MS);
        }

        function _cancelHoldSell(e) {
            if (_holdSellTimer)    { clearTimeout(_holdSellTimer);   _holdSellTimer = null; }
            if (_holdSellInterval) { clearInterval(_holdSellInterval); _holdSellInterval = null; }
            const progress = document.getElementById('holdSellProgress');
            const label    = document.getElementById('holdSellLabel');
            if (progress) progress.style.width = '0%';
            if (label)    label.textContent = 'MANTÉN 3 SEGUNDOS';
        }
        
        // ══════════════════════════════════════════════════════════════════
        //  _finalizeSlotSell — limpieza completa y unificada post-venta
        //  Llamada por TODAS las rutas de venta para garantizar que el
        //  dashboard, Panel 3, inputs y estado interno queden limpios.
        // ══════════════════════════════════════════════════════════════════
        function _finalizeSlotSell(slotIdx) {
            const strat   = (slots[slotIdx] && slots[slotIdx].strat) || 'normal';
            const capital = strategyParams.normal.capital;

            // 1. Limpiar datos del slot
            slots[slotIdx] = {
                name:'', price:0, capital, buys:[], strat,
                locked:true, note:'', alerted:false, multipleBuys:{},
                rebuyCount:0, rebuyOldSpent:0, rebuyOldQty:0
            };

            // 2. Limpiar órdenes activas del slot
            const prefix = `s${slotIdx}_`;
            Object.keys(activeOrders).forEach(k => { if (k.startsWith(prefix)) delete activeOrders[k]; });
            saveActiveOrders();

            // 3. Resetear modo de trading a manual
            slotModes[slotIdx] = 'manual';
            localStorage.setItem('c5x_slot_modes', JSON.stringify(slotModes));

            // 4. Limpiar trailing stop data
            if (trailingStopData && trailingStopData[slotIdx] !== undefined) {
                delete trailingStopData[slotIdx];
            }

            // 5. Limpiar crash pauses y restart timers
            if (crashPausedSlots) {
                delete crashPausedSlots[slotIdx];
                delete crashPausedSlots[slotIdx + '_circuit'];
                _saveCrashPauses();
            }
            if (autoRestartTimers && autoRestartTimers[slotIdx]) {
                clearTimeout(autoRestartTimers[slotIdx]);
                delete autoRestartTimers[slotIdx];
            }

            // 6. Limpiar objetivo de venta activo si pertenecía a este slot
            if (activeSellTarget && activeSellTarget.slotIndex === slotIdx) {
                activeSellTarget = null;
                localStorage.removeItem('c5x_sell_target');
            }
            if (!activeSellTarget && sellMonitorInterval) {
                clearInterval(sellMonitorInterval);
                sellMonitorInterval = null;
            }

            // 7. Limpiar multiTP / trailingState del sistema avanzado
            if (typeof trailingState !== 'undefined' && trailingState && trailingState.slotIdx === slotIdx) {
                trailingState  = null;
                activeSellMode = null;
                localStorage.removeItem('c5x_trailing');
            }
            if (typeof multiTPTargets !== 'undefined' && multiTPTargets.length &&
                multiTPTargets.some(t => t.slotIdx === slotIdx)) {
                multiTPTargets = [];
                activeSellMode = null;
                localStorage.removeItem('c5x_multitp');
            }

            // 8. Limpiar visual del objetivo de venta
            const tSect = document.getElementById('targetSection-' + slotIdx);
            if (tSect) { tSect.style.borderColor = ''; tSect.style.background = ''; }

            // 9. Guardar estado
            save();

            // 10. Reordenar dashboards (mueve slot vacío al final) y re-renderizar
            //     Esto también actualiza activeIdx al nuevo índice del slot vacío.
            sortAndRenderDashboards();

            // 11. Siempre activar el slot activo correcto (post-sort)
            //     activeIdx fue actualizado por sortAndRenderDashboards para apuntar
            //     al slot vacío en su nueva posición.
            selectSlot(activeIdx);

            updateTradingModeUIAll();
        }

        function executeSellNow(slot, slotIdx) {
            // Simular venta inmediata
            const currentPrice = parseFloat(document.getElementById('t-price').textContent.replace('$', '')) || slot.price;
            const avgPrice = calculateAvgPriceForSlotData(slot, slotIdx);
            const profitPercent = ((currentPrice - avgPrice) / avgPrice * 100).toFixed(2);
            
            showToast(`💰 Vendido: ${slot.name} al +${profitPercent}%`, 3000, false, true);
            sendNativeNotif(`💰 VENTA EJECUTADA — ${slot.name}`, `Ganancia: +${profitPercent}% ✓ 5X registró la venta correctamente.`, { tag: 'c5x-sell', requireInteraction: false });
            
            // Registrar en historial ANTES de limpiar
            addToHistory(slot, slotIdx, currentPrice, 'manual');
            
            // Limpiar estado completo + refrescar UI
            _finalizeSlotSell(slotIdx);
        }
        
        function checkSellTargets() {
            if (!activeSellTarget) {
                // Cargar desde localStorage si existe
                const saved = localStorage.getItem('c5x_sell_target');
                if (saved) {
                    try {
                        activeSellTarget = JSON.parse(saved);
                    } catch(e) {
                        return;
                    }
                } else {
                    return;
                }
            }
            
            const s = slots[activeSellTarget.slotIndex];
            if (!s || !s.name || s.name !== activeSellTarget.symbol) {
                // Slot fue limpiado o cambió
                activeSellTarget = null;
                localStorage.removeItem('c5x_sell_target');
                return;
            }
            
            // Obtener precio actual del coin objetivo (no del ticker, que puede mostrar otro)
            let currentPrice = 0;
            const liveETF = allGateETFs.find(t => t.currency_pair === activeSellTarget.symbol + '_USDT');
            if (liveETF) {
                currentPrice = parseFloat(liveETF.last);
            } else {
                // Fallback: usar precio del ticker solo si el símbolo coincide
                const tickerSym = document.getElementById('t-sym') ? document.getElementById('t-sym').textContent : '';
                if (tickerSym === activeSellTarget.symbol) {
                    currentPrice = parseFloat(document.getElementById('t-price').textContent.replace('$',''));
                }
            }
            if (isNaN(currentPrice) || currentPrice <= 0) return;

            // ── REBUY POST-TP1 en monitor manual — hasta 3 ciclos ────────
            // Cada vez que TP1 se ejecutó y el precio cae rebuyDropPct% desde
            // ese precio de venta → se reabren 12 niveles acumulando el 50%
            // restante al nuevo promedio. Máximo 3 rebuys por operación.
            const _rebuyCount = activeSellTarget.rebuyCount || 0;
            if (activeSellTarget.tp1Done && activeSellTarget.tp1SellPrice && _rebuyCount < 3) {
                const rebuyDropPct = botConfig.rebuyDropPct || 16;
                const dropFromTP1  = ((activeSellTarget.tp1SellPrice - currentPrice) / activeSellTarget.tp1SellPrice) * 100;
                if (dropFromTP1 >= rebuyDropPct) {
                    activeSellTarget.rebuyCount = _rebuyCount + 1;
                    // Reset trailing para nuevo ciclo
                    activeSellTarget.tp1Done        = false;
                    activeSellTarget.tp1SellPrice   = 0;
                    activeSellTarget.trailActivated = false;
                    activeSellTarget.trailMax       = 0;
                    localStorage.setItem('c5x_sell_target', JSON.stringify(activeSellTarget));
                    const slotR = slots[activeSellTarget.slotIndex];
                    if (slotR) {
                        slotR.rebuyCount = activeSellTarget.rebuyCount;

                        // ── Acumular el 50% restante al blend de promedio ──
                        let _oS = 0, _oQ = 0;
                        const _lim2 = customMultipliers.length || 12;
                        for (let _k = 0; _k < _lim2; _k++) {
                            const _bk = getOrderKey(activeSellTarget.slotIndex, _k);
                            if (activeOrders[_bk] && activeOrders[_bk].status === 'filled') {
                                _oS += activeOrders[_bk].price * activeOrders[_bk].amount;
                                _oQ += activeOrders[_bk].amount;
                            } else if (slotR.buys && slotR.buys.includes(_k) && !activeOrders[_bk]) {
                                const _ld2 = getLevelDataData(slotR, _k);
                                _oS += _ld2.usd; _oQ += _ld2.qty;
                            }
                        }
                        // Acumular (no reemplazar) el 50% restante de este ciclo
                        slotR.rebuyOldSpent = (slotR.rebuyOldSpent || 0) + _oS * 0.50;
                        slotR.rebuyOldQty   = (slotR.rebuyOldQty   || 0) + _oQ * 0.50;

                        slotR.price     = currentPrice;
                        slotR.buys = (slotR.buys||[]).filter(bi => {
                            const bk = getOrderKey(activeSellTarget.slotIndex, bi);
                            return activeOrders[bk] && activeOrders[bk].status === 'filled';
                        });
                        slotR.multipleBuys = {};
                        const pfxR = `s${activeSellTarget.slotIndex}_`;
                        Object.keys(activeOrders).forEach(k => { if (k.startsWith(pfxR) && activeOrders[k].status !== 'filled') delete activeOrders[k]; });
                        saveActiveOrders(); save();
                        if (activeSellTarget.slotIndex === activeIdx) { calculate(); renderLevels(); }
                        const dropStr = dropFromTP1.toFixed(1);
                        const newBase = currentPrice < 1 ? currentPrice.toFixed(6) : currentPrice.toFixed(4);
                        const cycleLeft = 3 - activeSellTarget.rebuyCount;
                        showToast(`🔄 Rebuy ${activeSellTarget.rebuyCount}/3: −${dropStr}% desde TP1 → 12 niveles · ${cycleLeft} restante${cycleLeft !== 1 ? 's' : ''}`, 5000, false, true);
                        sendNativeNotif(`🔄 Rebuy ${activeSellTarget.rebuyCount}/3 Post-TP1`, `↓${dropStr}% → 12 niveles · Base $${newBase} · ${cycleLeft} ciclo${cycleLeft !== 1 ? 's' : ''} más disponible${cycleLeft !== 1 ? 's' : ''}`);
                    }
                }
            }

            // ── TRAILING STOP — sin tope al alza ────────────────────────
            if (activeSellTarget.trailActivated) {
                // Actualizar máximo histórico (precio puede subir indefinidamente)
                if (currentPrice > activeSellTarget.trailMax) activeSellTarget.trailMax = currentPrice;
                const trailDropPct   = botConfig.trailDropPct || 15;
                const trailStopPrice = activeSellTarget.trailMax * (1 - trailDropPct / 100);
                localStorage.setItem('c5x_sell_target', JSON.stringify(activeSellTarget));
                if (currentPrice <= trailStopPrice) {
                    const profitPercent = ((currentPrice - activeSellTarget.avgPrice) / activeSellTarget.avgPrice * 100).toFixed(2);
                    stopTrailReminder();
                    showToast(`🔔 TRAILING STOP −${trailDropPct}% → vendiendo 50% restante +${profitPercent}%`, 5000, false, true);
                    sendNativeNotif('🔔 Trailing Stop ejecutado', `+${profitPercent}% · Máx $${activeSellTarget.trailMax.toFixed(4)} → actual $${currentPrice.toFixed(4)}`);
                    if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                    activeSellTarget.targetPrice = currentPrice; // forzar cierre final
                } else {
                    return; // Seguir monitoreando — sin tope al alza
                }
            }

            // Verificar si el precio alcanzó el objetivo
            if (currentPrice >= activeSellTarget.targetPrice) {
                const profitPercent = ((currentPrice - activeSellTarget.avgPrice) / activeSellTarget.avgPrice * 100).toFixed(2);

                // Si es TP1 → vende 50%, arma trailing desde precio TP1
                if ((activeSellTarget.type === 50 || activeSellTarget.type === (botConfig.tp1Pct || 50)) && !activeSellTarget.tp1Done) {
                    activeSellTarget.tp1Done      = true;
                    activeSellTarget.tp1SellPrice = currentPrice;
                    const trailActivePct = botConfig.trailActivePct || 100;
                    // TP2 se calcula desde el PRECIO DE VENTA TP1, no desde avg
                    const trailTarget = currentPrice * (1 + trailActivePct / 100);
                    activeSellTarget.targetPrice    = trailTarget;
                    activeSellTarget.type           = 'trail_arm';
                    activeSellTarget.trailActivated = false;
                    activeSellTarget.trailMax       = 0;
                    localStorage.setItem('c5x_sell_target', JSON.stringify(activeSellTarget));
                    const fmtTarget = trailTarget < 1 ? trailTarget.toFixed(6) : trailTarget.toFixed(4);
                    showToast(`🎯 TP1 +${profitPercent}% → Trailing activa a TP1+${trailActivePct}% ($${fmtTarget})`, 4000, false, true);
                    sendNativeNotif('🎯 TP1 Ejecutado', `+${profitPercent}% · Trailing activa desde TP1+${trailActivePct}% ($${fmtTarget})`);
                    return;
                }

                // Si llegó a TP1_precio + trailActivePct% → activar trailing SIN TOPE AL ALZA
                if (activeSellTarget.type === 'trail_arm' && !activeSellTarget.trailActivated) {
                    activeSellTarget.trailActivated = true;
                    activeSellTarget.trailMax       = currentPrice;
                    activeSellTarget.targetPrice    = 0; // Solo cierra por trailing stop, nunca por precio fijo
                    activeSellTarget.type           = 'trail_active';
                    const trailDropPct = botConfig.trailDropPct || 15;
                    localStorage.setItem('c5x_sell_target', JSON.stringify(activeSellTarget));
                    showToast(`📈 TRAILING ACTIVADO +${profitPercent}% — sin tope · cierra si retrocede −${trailDropPct}% del máximo`, 3500, false, true);
                    sendNativeNotif('📈 Trailing Activado', `+${profitPercent}% · Calculado desde precio TP1 · Cierra al retroceder −${trailDropPct}% desde el máximo`);
                    startTrailReminder(activeSellTarget.symbol, botConfig.trailActivePct || 100, trailDropPct);
                    return;
                }
                
                showToast(`🎉 OBJETIVO ALCANZADO! +${profitPercent}%`, 4000, false, true);
                sendNativeNotif('🎉 OBJETIVO ALCANZADO!', 'Tu posición cerró con +' + profitPercent + '% de ganancia. ¡Felicidades!', { tag: 'c5x-obj-auto', requireInteraction: true, vibrate: [300,100,300,100,300] });
                
                if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 100]);
                
                // Calcular PnL real antes de limpiar
                const _sIdx = activeSellTarget.slotIndex;
                let _spent = 0, _qty = 0, _lp = s.price;
                const _lim = customMultipliers.length || 12;
                for (let _i = 0; _i < _lim; _i++) {
                    const _pl = (_i === 0) ? s.price : _lp * (1 - (getStepForLevel('normal', _i) / 100));
                    _lp = _pl;
                    const _k = getOrderKey(_sIdx, _i);
                    if (activeOrders[_k] && activeOrders[_k].status === 'filled') { _spent += activeOrders[_k].price * activeOrders[_k].amount; _qty += activeOrders[_k].amount; }
                    else if (s.buys && s.buys.includes(_i) && !activeOrders[_k]) { const _m = customMultipliers[_i]||1; const _u = _m*strategyParams.normal.capital; _spent += _u; _qty += _u/_pl; }
                    if (_i >= 4 && _i <= 9 && s.multipleBuys && s.multipleBuys[_i]) { for (const _b of s.multipleBuys[_i]) { _spent += _b.usd; _qty += _b.qty; } }
                }
                const _saleVal = _qty * currentPrice;
                const _netPnl = _saleVal - _spent;
                const _avgPx = _qty > 0 ? _spent / _qty : 0;
                const logEntry = {
                    date: _fmtDate(new Date()), time: _fmtTime(new Date()),
                    coin: s.name, profit: _netPnl.toFixed(2), netProfit: _netPnl,
                    roi: activeSellTarget.profitPercent || profitPercent + '%',
                    exitPrice: currentPrice, avgPrice: _avgPx, totalSpent: _spent
                };
                // Registrar historial
                if (!history) history = [];
                history.push(logEntry);
                localStorage.setItem('c5x_history', JSON.stringify(history));
                renderHistory();

                // Limpiar estado completo + refrescar UI
                _finalizeSlotSell(_sIdx);
            }
        }
        
        function addToHistory(slot, slotIdx, exitPrice, mode) {
            const avgPrice = calculateAvgPriceForSlotData(slot, slotIdx);
            let totalInvested = 0;
            
            // Calcular inversión total
            slot.buys.forEach(levelIdx => {
                const levelData = getLevelData(slot, levelIdx);
                totalInvested += levelData.usd;
            });
            
            // Agregar inversiones de compras múltiples
            if (slot.multipleBuys) {
                Object.values(slot.multipleBuys).forEach(buysArray => {
                    if (Array.isArray(buysArray)) {
                        buysArray.forEach(buy => {
                            totalInvested += buy.usd;
                        });
                    }
                });
            }
            
            const grossProfit = (exitPrice - avgPrice) * (totalInvested / avgPrice);
            const netProfit = grossProfit - (totalInvested * (exchangeFee / 100));
            const roi = ((netProfit / totalInvested) * 100).toFixed(2);
            
            const log = {
                date: _fmtDate(new Date()),
                time: mode === 'auto' ? 'AUTO' : _fmtTime(new Date()),
                coin: slot.name,
                avgPrice: avgPrice,
                exitPrice: exitPrice,
                totalInv: totalInvested,
                profit: grossProfit.toFixed(2),
                netProfit: netProfit.toFixed(2),
                roi: roi + '%'
            };
            
            history.push(log);
            localStorage.setItem('c5x_history', JSON.stringify(history));
            renderHistory();
            calculateGlobalStats();
        }
        
        function updateStrategyButtonVisuals() { /* Estrategia única NORMAL - sin elemento visual */ }
        
        // startStrategyTogglePress / endStrategyTogglePress / cancelStrategyTogglePress
        // eliminadas — eran stubs vacíos sin funcionalidad real

        function init() { 
             try {
                if(!tickerAssets || tickerAssets.length === 0) { tickerAssets = ["BTC", "ETH", "SUI", "AVAX", "BNB"]; localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets)); }
                // Filtrar tokens ETF del ticker (no 3L, 5L, 3S, 5S)
                tickerAssets = tickerAssets.filter(t => !t.match(/[35][LS]/));
                applyTheme(parseInt(localStorage.getItem('c5x_theme_idx') ?? '2') || 2);
                // Seguir cambios del sistema en tiempo real (si no hay elección manual)
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                    if (!localStorage.getItem('theme')) {
                        isLight = !e.matches;
                        document.body.classList.toggle('light-mode', isLight);
                        updateThemeIcon();
                        if (chartSymbol) loadChart(chartSymbol);
                    }
                });

                
                slots.forEach(s => { if (!s.strat) s.strat = 'normal'; });
                loadInvestmentValue(); loadSlotsLevels(); updateThemeIcon(); loadActiveOrders(); loadSellOrder(); loadSellTarget(); updateStrategyButtonVisuals(); updateTradingModeUI(); loadETFMonitorState();
                // ── FIX #9: Cargar keys desde IndexedDB al arranque ──
                // _decryptKeys es ahora async y lee desde IDB (no localStorage)
                _decryptKeys().then(dec => {
                    if (dec.key && dec.secret) {
                        apiConfig = dec;
                        isPrivateMode = true;
                        fetchWalletBalance();
                        startFullSyncSchedule();
                        _resetInactivityTimer();
                        // Actualizar placeholders en ajustes si ya están en DOM
                        const elK = document.getElementById('apiKey');
                        const elS = document.getElementById('apiSecret');
                        if (elK) elK.placeholder = '●●●●●●●●' + dec.key.slice(-4);
                        if (elS) elS.placeholder = '●●●●●●●●' + dec.secret.slice(-4);
                    }
                }).catch(e => console.warn('[5X] init keys error:', e));
                if(!slots[activeIdx]) activeIdx = 0;
                updateDashUI();  selectSlot(activeIdx); renderHistory(); updatePinUI(); startTickerSystem(); startMultiBuyLive(); updateETFFloatButtonVisibility(); fetchAndCalcTopDroppers(); setupSwipe(); setupPanelSwipe(); (function(){ const c=document.getElementById('panelsContainer'); if(c && window.innerWidth < 1024) c.style.transform='translateX(0%)'; })(); renderAllDashboards(); setTimeout(sortAndRenderDashboards, 300);
                document.querySelectorAll('.tf-btn').forEach(btn => { if(btn.dataset.tf === activeTF) btn.classList.add('active'); });
                calculateGlobalStats(); updateStats('D'); updateDashboardStats(); startGateMonitoring();
                startMasterClock(); // reloj maestro — todas las rotaciones sincronizadas cada 10s
                checkNotifPermission(); // verificar permisos de notificación
                initGateDashboard(); // dashboard en panel 2, inicializar desde el arranque
                // Establecer estado inicial del historial de navegación
                // Esto previene que el primer "Atrás" cierre la app
                window.history.replaceState({ c5xView: 'operate' }, '', window.location.pathname);
                window.addEventListener('scroll', handleWindowScroll);
                document.body.addEventListener('click', unlockAudioAndWake, { once: true }); document.body.addEventListener('touchstart', unlockAudioAndWake, { once: true }); requestWakeLock();
                loadBotConfigUI(); // Cargar valores UI del bot
                // Cargar valores cacheados de wallet instantáneamente
                const _ct = localStorage.getItem('c5x_cached_total');
                const _cl = localStorage.getItem('c5x_cached_libre');
                if (_ct && parseFloat(_ct) > 0) {
                    const _fUSD = v => '$' + parseFloat(v).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                    setGdEl('gdTotal', _fUSD(_ct));
                    setGdEl('gdLibre', _fUSD(_cl || '0'));
                    const _pct = parseFloat(_ct) > 0 ? ((parseFloat(_cl||0) / parseFloat(_ct)) * 100).toFixed(0) : 0;
                    setGdEl('gdLibrePct', _pct + '% disponible');
                }
                // Restaurar slots que estaban en auto
                slotModes.forEach((mode, idx) => {
                    if (mode === 'auto' && slots[idx] && slots[idx].name && slots[idx].price) {
                        const prevActive = activeIdx;
                        activeIdx = idx;
                        startAutoTrading();
                        activeIdx = prevActive;
                    }
                });
                loadGateETFs(); 
                // Iniciar monitoreo de objetivos de venta (interval separado del bot)
                if (!sellMonitorInterval) {
                    sellMonitorInterval = setInterval(() => {
                        checkSellTargets();
                    }, 3000);
                }
                
                // GUARDADO AUTOMÁTICO cada 30 segundos
                setInterval(() => {
                    save();
                    saveActiveOrders();
                    saveSellOrder();
                    saveSellTargetIfNeeded();
                }, 30000);
                
                // GUARDADO antes de cerrar/salir
                window.addEventListener('beforeunload', (e) => {
                    save();
                    saveActiveOrders();
                    saveSellOrder();
                    saveSellTargetIfNeeded();
                    localStorage.setItem('c5x_history', JSON.stringify(history));
                });
                
                // GUARDADO al cambiar de pestaña o minimizar
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        save();
                        saveActiveOrders();
                        saveSellOrder();
                    }
                });
                
                // Verificar sesión guardada
                applyRoleVisibility();
                const savedSession = localStorage.getItem('c5x_session');
                const savedName = localStorage.getItem('c5x_my_name');
                if (savedSession === 'admin') {
                    setAdminMode(true);
                    _doUnlock();
                } else if (savedSession === 'user' && savedName) {
                    _doUnlock();
                } else {
                    showLoginWall();
                }
            } catch(e) { console.error("Init Error", e); showToast("⚠️ Error de inicio: " + e.message); }
        }
        
        function loadSellTarget() {
            const saved = localStorage.getItem('c5x_sell_target');
            if (saved) {
                try {
                    activeSellTarget = JSON.parse(saved);
                    // Actualizar UI si el slot activo tiene objetivo
                    if (activeSellTarget && activeSellTarget.slotIndex === activeIdx) {
                        const targetSection = document.getElementById('targetSection-' + activeIdx);
                        if (targetSection) {
                            targetSection.style.borderColor = 'var(--long)';
                            targetSection.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(14, 203, 129, 0.1))';
                        }
                        const resTarget = document.getElementById('resTarget-' + activeIdx);
                        if (resTarget) { updateDashboardStatsForSlot(activeIdx); } // keep dual format
                    }
                } catch(e) {
                    console.warn("Error cargando objetivo de venta", e);
                }
            }
        }
        function handleWindowScroll() { const scrollY = window.scrollY; const threshold = 30; const brandBtn = document.querySelector('.brand-btn'); const themeBtn = document.querySelector('.theme-btn'); if (scrollY > threshold) { if (!isHeaderPinnedByScroll) { isHeaderPinnedByScroll = true; if(brandBtn) brandBtn.classList.add('hidden'); if(themeBtn) themeBtn.classList.add('hidden'); } } else { if (isHeaderPinnedByScroll) { isHeaderPinnedByScroll = false; if(brandBtn) brandBtn.classList.remove('hidden'); if(themeBtn) themeBtn.classList.remove('hidden'); updateTicker(); } } }
        function startTradingPress(e) { if(e.type==='touchstart' && e.cancelable) e.preventDefault(); longPressTriggered = false; tradingPressTimer = setTimeout(() => { longPressTriggered = true; toggleTradingMode(); }, 1600); }
        function cancelTradingPress(e) { if (tradingPressTimer) clearTimeout(tradingPressTimer); }
        let levelPressTimer = null;
        let levelLongPressTriggered = false;
        let currentPressedLevel = -1;
        let scrollStartY = 0;
        let scrollStartTime = 0;
        let isScrolling = false;
        function startLevelPress(e, levelIndex) { 
            scrollStartY = e.touches ? e.touches[0].clientY : e.clientY;
            scrollStartTime = Date.now();
            isScrolling = false;
            currentPressedLevel = levelIndex; 
            levelLongPressTriggered = false; 
            
            // Agregar clase visual de presión
            const cardEl = document.querySelector(`[data-level-index="${levelIndex}"]`);
            if (cardEl) {
                cardEl.classList.add('pressing');
            }
            
            levelPressTimer = setTimeout(() => { 
                if (!isScrolling) {
                    levelLongPressTriggered = true; 
                    if (navigator.vibrate) navigator.vibrate([80, 50, 80]); 
                    
                    // Remover clase de presión antes de ejecutar
                    if (cardEl) cardEl.classList.remove('pressing');
                    
                    handleLevelClick(levelIndex); 
                }
            }, 1800); 
        }
        function endLevelPress(e) { 
            const currentY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            const scrollDistance = Math.abs(currentY - scrollStartY);
            const scrollTime = Date.now() - scrollStartTime;
            
            // Remover clase de presión
            const cardEl = document.querySelector(`[data-level-index="${currentPressedLevel}"]`);
            if (cardEl) cardEl.classList.remove('pressing');
            
            // Si se movió más de 10px o pasó menos de 150ms, es scroll
            if (scrollDistance > 10 || scrollTime < 150) {
                isScrolling = true;
            }
            
            if (levelPressTimer) clearTimeout(levelPressTimer); 
            levelLongPressTriggered = false; 
            currentPressedLevel = -1; 
        }
        function cancelLevelPress() { 
            isScrolling = true;
            
            // Remover clase de presión
            const cardEl = document.querySelector(`[data-level-index="${currentPressedLevel}"]`);
            if (cardEl) cardEl.classList.remove('pressing');
            
            if (levelPressTimer) clearTimeout(levelPressTimer); 
            levelLongPressTriggered = false; 
            currentPressedLevel = -1; 
        }
        
        function updateDashUI() { 
            const s = slots[activeIdx]; 
            const btnMode = document.getElementById('tradingModeBtn-' + activeIdx); 
            const capitalInput = document.getElementById('capitalInput'); 
            if (btnMode) btnMode.classList.remove('locked'); 
            updateStrategyButtonVisuals(); 
            
            if(capitalInput) { 
                capitalInput.value = s.capital || 5; 
                capitalInput.removeAttribute('readonly'); 
                capitalInput.style.opacity = '1'; 
                capitalInput.style.cursor = 'text'; 
            } 
            
            updateBodyMode(s.name); 
            updateTradingInfoDisplay(); 
            calculate(); 
        }
        
        function updateCapitalAndSave() { 
            const capitalInput = document.getElementById('capitalInput'); 
            const s = slots[activeIdx]; 
            
            if (capitalInput && s) { 
                const newCapital = parseFloat(capitalInput.value) || 5; 
                s.capital = newCapital; 
                save(); 
                calculate(); 
                showToast("💾 Capital guardado"); 
            } 
        }
        
        function updateTradingInfoDisplay() {
            const s = slots[activeIdx];
            const coinEl = document.getElementById('dashTradingCoin-' + activeIdx);
            if (coinEl) {
                coinEl.textContent = s.name || '---';
                coinEl.style.color = getCoinColor(s.name);
            }
            const baseEl = document.getElementById('dashBaseDisplay-' + activeIdx);
            if (baseEl && s.price > 0) {
                const p = s.price;
                baseEl.textContent = p < 0.0001 ? p.toFixed(10).replace(/\.?0+$/, '') : p < 1 ? p.toFixed(6) : p.toFixed(4);
            } else if (baseEl) {
                baseEl.textContent = '0.0000';
            }
        }
        
        function toggleTradingMode() {
            triggerHaptic();
            if(navigator.vibrate) navigator.vibrate([50, 50]);
            const currentMode = slotModes[activeIdx] || 'manual';
            if (currentMode === 'manual') {
                setSlotMode(activeIdx, 'auto');
                updateTradingModeUI();
                startAutoTrading(); // arranca bot solo para este slot
                showToast(`🤖 Slot ${activeIdx + 1} AUTOMÁTICO activado`);
            } else {
                setSlotMode(activeIdx, 'manual');
                updateTradingModeUI();
                showToast(`👆 Slot ${activeIdx + 1} en MANUAL`);
            }
        }
        function updateTradingModeUI() { 
            updateTradingModeUIAll(); 
        }
        function updateTradingModeUIAll() {
            const modeEmoji = "💎";
            for (let i = 0; i < 10; i++) {
                const btn = document.getElementById('tradingModeBtn-' + i);
                const text = document.getElementById('tradingModeText-' + i);
                const indicator = document.getElementById('tradingModeIndicator-' + i);
                if (!btn) continue;
                const thisMode = slotModes[i] || 'manual'; // Modo individual por slot
                if (thisMode === 'auto') {
                    btn.classList.add('auto-mode');
                    if (text) text.textContent = 'AUTOMÁTICO';
                    if (indicator) indicator.textContent = `${modeEmoji} ACTIVO`;
                } else {
                    btn.classList.remove('auto-mode');
                    if (text) text.textContent = 'MANUAL';
                    if (indicator) indicator.textContent = 'ESPERANDO';
                }
            }
            // ── Sincronizar botón de modo en Panel 3 (barra superior) ──
            const lpModeBtn  = document.getElementById('levelsPanelModeBtn');
            const lpModeText = document.getElementById('levelsPanelModeText');
            const lpModeInd  = document.getElementById('levelsPanelModeIndicator');
            const curMode = slotModes[activeIdx] || 'manual';
            if (lpModeBtn) {
                lpModeBtn.classList.toggle('auto-mode', curMode === 'auto');
            }
            if (lpModeText) lpModeText.textContent = curMode === 'auto' ? 'AUTO' : 'MANUAL';
            if (lpModeInd)  lpModeInd.textContent  = curMode === 'auto' ? '💎 ACTIVO' : 'MANTÉN 2s';
        }
        function updateTickerWithActiveCoin() { const s = slots[activeIdx]; if (s && s.name) { let price = s.price || 0; const liveData = allGateETFs.find(t => t.currency_pair === s.name + "_USDT"); if (liveData) price = parseFloat(liveData.last); updateTickerUI(s.name, price, true); document.getElementById('t-dot').style.background = 'var(--brand)'; } else { updateTickerUI("SIN COIN", 0, false); } }
        function getCoinColor(name) { if (!name) return 'var(--brand)'; const upper = name.toUpperCase(); if (upper.includes('3S') || upper.includes('5S') || upper.endsWith('S')) return 'var(--short)'; if (upper.includes('3L') || upper.includes('5L') || upper.endsWith('L')) return 'var(--long)'; return 'var(--brand)'; }
        function loadActiveOrders() { const storageKey = 'c5x_active_orders_real'; const saved = localStorage.getItem(storageKey); if (saved) { try { activeOrders = JSON.parse(saved); } catch (e) { activeOrders = {}; } } else { activeOrders = {}; } }
        function saveActiveOrders() { const storageKey = 'c5x_active_orders_real'; localStorage.setItem(storageKey, JSON.stringify(activeOrders)); }
        function updateLevelsUI() { const levelCards = document.querySelectorAll('[data-level-index]'); levelCards.forEach((card, index) => { card.classList.remove('order-selected', 'order-pending', 'order-filled', 'order-error', 'is-filled', 'is-filled-extra', 'is-pending', 'bought'); const badge = card.querySelector('.order-status-badge'); if (badge) badge.remove(); const key = getOrderKey(activeIdx, index); const s = slots[activeIdx]; const isBought = s.buys && s.buys.includes(index); const canBuyMultiple = (index >= 4 && index <= 9); const buyCount = (canBuyMultiple && s.multipleBuys && s.multipleBuys[index]) ? s.multipleBuys[index].length : 0; if (activeOrders[key]) { const order = activeOrders[key]; if (order.status === 'open') { updateLevelStatus(index, 'pending', 'PENDIENTE'); card.classList.add('is-pending'); } else if (order.status === 'filled') { updateLevelStatus(index, 'filled', 'EJECUTADA ✓'); card.classList.add('is-filled'); } } else if (buyCount > 1) { card.classList.add('is-filled-extra'); } else if (buyCount === 1 || isBought) { card.classList.add('is-filled'); } }); }
        function saveSellTargetIfNeeded() {
            if (activeSellTarget) {
                localStorage.setItem('c5x_sell_target', JSON.stringify(activeSellTarget));
            }
        }
        function loadSellOrder() { const saved = localStorage.getItem('c5x_sell_order'); if (saved) { try { const sellOrder = JSON.parse(saved); const sellIcon = document.getElementById('sellIcon'); const targetSection = document.getElementById('targetSection-' + activeIdx); if (sellOrder.status === 'open') { if(sellIcon) sellIcon.textContent = '⏳'; targetSection.style.borderColor = 'var(--long)'; targetSection.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(14, 203, 129, 0.1))'; showToast("📊 Orden de venta activa"); monitorSellOrder(sellOrder.orderId, sellOrder.symbol); } } catch (e) { console.error("Error cargando orden de venta:", e); } } }
        
        function selectSlot(i) { 
            triggerHaptic(); 
            activeIdx = i; 
            localStorage.setItem('c5x_last_slot', i); 
            
            // MOSTRAR niveles por defecto al cambiar de slot
            const levelsContainer = document.getElementById('levelsGrid'); 
            if (levelsContainer) levelsContainer.classList.remove('collapsed'); 
            
            const s = slots[i]; 
            const cInput = document.getElementById('coinInput'); 
            if (cInput) { cInput.value = s.name; cInput.setAttribute('readonly', true); cInput.classList.remove('editing-mode'); cInput.classList.add('locked-input'); }
            
            const bInput = document.getElementById('baseInput'); 
            if (bInput) {
                // SIEMPRE mostrar el precio real del slot — nunca dejarlo vacío si hay precio
                bInput.value = (s.price > 0) ? s.price : '';
                bInput.setAttribute('readonly', true);
                bInput.classList.add('locked-input');
                bInput.classList.remove('manual-edit');
            }
            
            const capInput = document.getElementById('capitalInput');
            if (capInput) capInput.value = s.capital; 
            
            const indicator = document.getElementById('priceAdjustIndicator'); 
            if (indicator) { 
                if (s.priceAdjusted && s.initialPrice) { 
                    const dropPercent = (((s.price - s.initialPrice) / s.initialPrice) * 100); 
                    indicator.style.display = 'block'; 
                    indicator.title = `Ajustado automáticamente de $${s.initialPrice.toFixed(4)} (${dropPercent.toFixed(1)}%)`; 
                } else { 
                    indicator.style.display = 'none'; 
                } 
            } 
            
            // Resaltar tarjeta activa en el multi-dashboard
            document.querySelectorAll('.dashboard-card').forEach((card, idx) => {
                card.classList.toggle('slot-active', idx === i);
                const lbl = card.querySelector('.dash-slot-label');
                if (lbl) lbl.textContent = `SLOT ${idx+1}${idx === i ? ' ● ACTIVO' : ''}`;
                const btn = card.querySelector('[id^="tradingModeBtn-"]');
                if (btn) btn.style.opacity = idx === i ? '1' : '0.5';
            });
            
            loadChart(s.name); 
            // Chart2 (Panel 3) siempre refleja el slot activo
            if (currentPanel === 2) { setTimeout(() => loadChart2(getChart2Symbol()), 100); }
            updateDashUI(); 
            updateTickerWithActiveCoin(); 
            renderLevels();
            // Sincronizar barra superior del Panel 3 (moneda + modo)
            const coinLbl3 = document.getElementById('levelsPanelCoinLabel');
            if (coinLbl3) {
                coinLbl3.textContent = (s && s.name) ? s.name : '---';
                coinLbl3.style.color = (s && s.name) ? getCoinColor(s.name) : '';
            }
            updateTradingModeUIAll();
            
            // Actualizar UI del objetivo de venta si hay uno activo para este slot
            const targetSection = document.getElementById('targetSection-' + i);
            const resTarget = document.getElementById('resTarget-' + i);
            if (activeSellTarget && activeSellTarget.slotIndex === i) {
                if (targetSection) {
                    targetSection.style.borderColor = 'var(--long)';
                    targetSection.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(14, 203, 129, 0.1))';
                }
                if (resTarget) { updateDashboardStatsForSlot(i); } // keep dual TP1/TRAIL format
            } else {
                if (targetSection) {
                    targetSection.style.borderColor = '';
                    targetSection.style.background = '';
                }
            }
        }
        function updateCoin() { const el = document.getElementById('coinInput'); let val = el.value.toUpperCase().replace('USDT','').trim(); el.value = val; slots[activeIdx].name = val; save();  loadChart(val); calculate(); }
        function rotateDash() { 
            // Solo estrategia normal disponible - función mantenida para compatibilidad
            triggerHaptic(); 
            showToast(`⚡ ESTRATEGIA: NORMAL`); 
        }
        function calculate() {
            const s = slots[activeIdx];
            const baseInput = document.getElementById('baseInput');
            if (!baseInput || baseInput.classList.contains('manual-edit')) return;
            const inputVal = parseFloat(baseInput.value);
            const newPrice = isNaN(inputVal) ? 0 : inputVal;
            // PROTECCIÓN: si el slot tiene buys o niveles activos, NUNCA resetear a 0
            const hasActivity = (s.buys && s.buys.length > 0) ||
                Object.keys(activeOrders).some(k => k.startsWith('s' + activeIdx + '_'));
            if (newPrice === 0 && hasActivity) {
                // Restaurar el input con el precio actual del slot
                if (s.price > 0) baseInput.value = s.price;
                renderLevels();
                return;
            }
            if (newPrice === 0 && s.price > 0 && !baseInput.classList.contains('manual-edit')) {
                // Input vacío pero slot tiene precio — no sobreescribir
                baseInput.value = s.price;
                renderLevels();
                return;
            }
            if (newPrice > 0) {
                if (s.price === 0 && !s.initialPrice) s.initialPrice = newPrice;
                s.price = newPrice;
                save();
            }
            renderLevels();
            updateDashboardStats();
            baseInput.setAttribute('readonly', true);
            baseInput.classList.add('locked-input');
        }
        function getStrategyParams(stratType) { return strategyParams.normal; }
        /**
         * Calcula el paso (%) de caída entre el nivel anterior y el nivel actual.
         * 
         * Fórmula de precios por niveles:
         *   N1  = precio_base                                    (0% caída)
         *   N2  = precio_N1 × (1 - desc/100)                    → step = desc        (ej: -16%)
         *   N3  = precio_N2 × (1 - (desc + inc×1)/100)          → step = desc + inc  (ej: -22%)
         *   N4  = precio_N3 × (1 - (desc + inc×2)/100)          → step = desc+inc×2  (ej: -28%)
         *   N5  = precio_N4 × (1 - (desc + inc×3)/100)          → step = desc+inc×3  (ej: -34%)
         *   N6  = precio_N5 × (1 - (desc + inc×4)/100)          → step = desc+inc×4  (ej: -40%)
         *   N7  = precio_N6 × (1 - (desc + inc×5)/100)          → step = desc+inc×5  (ej: -46%)
         *   N8  = precio_N7 × (1 - (desc + inc×6)/100)          → step = desc+inc×6  (ej: -52%)
         *   N9  = precio_N8 × (1 - (desc + inc×7)/100)          → step = desc+inc×7  (ej: -58%)
         *   N10 = precio_N9 × (1 - (desc + inc×8)/100)          → step = desc+inc×8  (ej: -64%)
         *   N11 = precio_N10 × (1 - (desc + inc×9)/100)         → step = desc+inc×9  (ej: -70%)
         *   N12 = precio_N11 × (1 - (desc + inc×10)/100)        → step = desc+inc×10 (ej: -76%)
         * 
         * @param {string} stratType  - tipo de estrategia (actualmente solo 'normal')
         * @param {number} levelIndex - índice 0-based (0=N1, 1=N2 … 11=N12)
         * @returns {number} porcentaje de caída respecto al nivel anterior
         */
        function getStepForLevel(stratType, levelIndex) {
            const params = strategyParams.normal;
            if (levelIndex <= 0) {
                return 0; // N1 = precio base, sin caída
            }
            // Para N2 (levelIndex=1): step = desc
            // Para Nk (levelIndex=k-1, k≥2): step = desc + inc × (levelIndex - 1)
            return params.desc + (params.inc * (levelIndex - 1));
        }

        /**
         * Calcula el porcentaje de caída ACUMULADA desde N1 (precio base) hasta el nivel i.
         * @param {object} slot  - slot activo con slot.price y slot.strat
         * @param {number} i     - índice 0-based del nivel (0=N1 … 11=N12)
         * @returns {number}  % caída acumulada (valor negativo, ej: -16.00 para N2 con desc=16)
         */
        function getCumulativeDropPct(slot, i) {
            if (i <= 0) return 0;
            let price = slot.price;
            for (let k = 1; k <= i; k++) {
                const step = getStepForLevel(slot.strat, k);
                price = price * (1 - step / 100);
            }
            return ((price - slot.price) / slot.price) * 100; // negativo
        }
        function toggleTickerPin() { triggerHaptic(); isTickerPinned = !isTickerPinned; localStorage.setItem('c5x_ticker_pinned', isTickerPinned); const pill = document.getElementById('mainTickerPill'); if(isTickerPinned) { const currentSym = document.getElementById('t-sym').textContent; const foundIdx = tickerAssets.indexOf(currentSym); if(foundIdx !== -1) { assetIdx = foundIdx; localStorage.setItem('c5x_ticker_index', assetIdx); } pill.classList.add('pinned-mode'); if(navigator.vibrate) navigator.vibrate([50,50]); showToast("⚓ PRECIO FIJADO: " + currentSym); } else { pill.classList.remove('pinned-mode'); showToast("▶️ ROTACIÓN ACTIVADA"); updateTicker(); } }
        function updatePinUI() { const pill = document.getElementById('mainTickerPill'); if(isTickerPinned) pill.classList.add('pinned-mode'); else pill.classList.remove('pinned-mode'); }
        function viewTickerChart(e) { if(e) e.stopPropagation(); chartSymbol = currentTickerSymbol.toUpperCase(); loadChart(chartSymbol); if(currentSection !== 'operate') switchView('operate', false); }
        function updateTF(tf, btn) { triggerHaptic(); activeTF = tf; localStorage.setItem('c5x_last_tf', tf); document.querySelectorAll('.tf-btn').forEach(b => { b.classList.remove('active'); if(b.dataset.tf === tf) b.classList.add('active'); }); loadChart(chartSymbol); if (currentPanel === 2) { setTimeout(() => loadChart2(getChart2Symbol()), 150); } }
        let tvWidget = null;
        let tvWidget2 = null;
        // Símbolo para Chart2 (Panel 3): slot activo o BTC5L si vacío
        function getChart2Symbol() {
            const name = slots[activeIdx] && slots[activeIdx].name;
            return name ? name.toUpperCase() : 'BTC5L';
        }

        function loadChart(coin) { chartSymbol = (coin || 'BTC3L').toUpperCase(); if(tvWidget) { try{ tvWidget.remove(); }catch(e){} } if(typeof TradingView !== 'undefined') { tvWidget = new TradingView.widget({ "autosize": true, "symbol": `GATEIO:${chartSymbol.replace('USDT','') }USDT`, "interval": activeTF, "theme": isLight ? "light" : "dark", "container_id": "tv_chart", "hide_top_toolbar": true, "backgroundColor": isLight ? "#F2F0E9" : "#0b0e11", "locale": "es", "disabled_features": ["use_localstorage_for_settings"], "enabled_features": ["study_templates"] }); } setTimeout(() => { addTradingLevelsToChart(); }, 500); }
        function loadChart2(coin) { const sym = (coin || chartSymbol || 'BTC3L').toUpperCase(); if(tvWidget2) { try{ tvWidget2.remove(); }catch(e){} } if(typeof TradingView !== 'undefined') { tvWidget2 = new TradingView.widget({ "autosize": true, "symbol": `GATEIO:${sym.replace('USDT','') }USDT`, "interval": activeTF, "theme": isLight ? "light" : "dark", "container_id": "tv_chart2", "hide_top_toolbar": true, "backgroundColor": isLight ? "#F2F0E9" : "#0b0e11", "locale": "es", "disabled_features": ["use_localstorage_for_settings"], "enabled_features": ["study_templates"] }); } }
        function addTradingLevelsToChart() { const overlay = document.getElementById('priceLinesOverlay'); if (!overlay) return; overlay.innerHTML = ''; const s = slots[activeIdx]; const avg = calculateAvgPriceForSlotData(s, activeIdx); if (avg <= 0 || !s.buys || s.buys.length === 0 || !s.price) { return; } const tp1Pct = botConfig.tp1Pct || 50; const roiTarget = tp1Pct; const targetPrice = avg * (1 + (roiTarget / 100)); let lowestPrice = s.price; const maxLevel = Math.max(...s.buys); let currentP = s.price; for(let i = 1; i <= maxLevel; i++) { const step = getStepForLevel(s.strat, i); currentP = currentP * (1 - (step / 100)); } lowestPrice = currentP; const priceRange = targetPrice - lowestPrice; const minPrice = lowestPrice - (priceRange * 0.1); const maxPrice = targetPrice + (priceRange * 0.1); const totalRange = maxPrice - minPrice; function getPricePosition(price) { const percentage = ((price - minPrice) / totalRange) * 100; return 100 - percentage; } const avgPos = getPricePosition(avg); const avgLine = document.createElement('div'); avgLine.className = 'price-line avg-line'; avgLine.style.top = avgPos + '%'; avgLine.innerHTML = `<div class="price-label avg">🟢 PROM: $${avg.toFixed(avg < 1 ? 6 : 4)}</div>`; overlay.appendChild(avgLine); const targetPos = getPricePosition(targetPrice); const targetLine = document.createElement('div'); targetLine.className = 'price-line target-line'; targetLine.style.top = targetPos + '%'; targetLine.innerHTML = `<div class="price-label target">🎯 +${roiTarget}%: $${targetPrice.toFixed(targetPrice < 1 ? 6 : 4)}</div>`; overlay.appendChild(targetLine); let lastPrice = s.price; s.buys.forEach((levelIdx) => { let tempP = s.price; for(let i = 1; i <= levelIdx; i++) { const step = getStepForLevel(s.strat, i); tempP = tempP * (1 - (step / 100)); } const buyPos = getPricePosition(tempP); const buyLine = document.createElement('div'); buyLine.className = 'price-line buy-line'; buyLine.style.top = buyPos + '%'; buyLine.innerHTML = `<div class="price-label buy">🔹 N${levelIdx + 1}</div>`; overlay.appendChild(buyLine); }); }
        function renderLevels() {
            const grid = document.getElementById('levelsGrid');
            let s = slots[activeIdx];
            // Sin moneda activa → usar BTC5L como default
            if (!s || !s.name) {
                let p = 0;
                if (typeof allGateETFs !== 'undefined' && allGateETFs.length > 0) {
                    const e = allGateETFs.find(t => t.currency_pair === 'BTC5L_USDT');
                    if (e) { p = parseFloat(e.last) || 0; if (p > 0) localStorage.setItem('c5x_btc5l_cache', String(p)); }
                }
                if (!p) { const c = parseFloat(localStorage.getItem('c5x_btc5l_cache')); if (c > 0) p = c; }
                if (!p) { p = 1.0; if (typeof allGateETFs !== 'undefined' && !allGateETFs.length) setTimeout(renderLevels, 2000); }
                s = { name: 'BTC5L', price: p, strat: 'normal', buys: [], multipleBuys: {} };
            }
            if (s.price <= 0) { grid.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-tertiary)">DEFINE PRECIO BASE</div>'; return; } const limit = customMultipliers ? customMultipliers.length : 12; let html = ''; let currentPrice = s.price; let totalInvested = 0; let totalQty = 0; let _runInv = 0; let _runQty = 0; const params = getStrategyParams(s.strat); for (let i = 0; i < limit; i++) { let levelPrice, step; if (i === 0) { levelPrice = s.price; step = 0; } else { step = getStepForLevel(s.strat, i); levelPrice = currentPrice * (1 - (step / 100)); } currentPrice = levelPrice;
            // % caída acumulada desde N1 (precio base)
            const cumulativeDrop = i === 0 ? 0 : ((levelPrice - s.price) / s.price * 100); let multiplier = customMultipliers ? (customMultipliers[i] || 1) : 1; let levelCapital = params.capital * multiplier; let qty = levelCapital / levelPrice; const key = getOrderKey(activeIdx, i); let badgeHtml = ''; let cardStateClass = ''; const isBoughtLegacy = s.buys.includes(i); const canBuyMultiple = (i >= 4 && i <= 9); // N5-N10 multi-buy
            // Detectar nivel alcanzado por precio real (base > real)
            const _liveP = getLivePrice(s.name);
            let _isTriggered = false;
            if (_liveP > 0 && _liveP < s.price && !isBoughtLegacy && !activeOrders[key]) {
                let _cp = s.price;
                for (let _k = 1; _k <= i; _k++) { const _st = getStepForLevel(s.strat, _k); _cp = _cp * (1 - _st/100); }
                _isTriggered = _liveP <= _cp;
            }
            let buyCount = 0; let accumulatedUSDT = 0; let accumulatedQty = 0; if (canBuyMultiple && s.multipleBuys && s.multipleBuys[i]) { buyCount = s.multipleBuys[i].length; for (let buy of s.multipleBuys[i]) { accumulatedUSDT += buy.usd; accumulatedQty += buy.qty; } } if(activeOrders[key]) { const status = activeOrders[key].status === 'open' ? 'PENDIENTE' : 'EJECUTADA ✓'; const cssClass = activeOrders[key].status === 'open' ? 'pending' : 'filled'; badgeHtml = `<div class="order-status-badge ${cssClass}">${status}</div>`; if(activeOrders[key].status === 'filled') { cardStateClass = 'is-filled'; totalInvested += levelCapital; totalQty += qty; } else { cardStateClass = 'is-pending'; } } else if (_isTriggered) { cardStateClass = 'is-triggered';
            } else if (isBoughtLegacy || buyCount > 0) { cardStateClass = (canBuyMultiple && buyCount > 1) ? 'is-filled-extra' : 'is-filled'; if (buyCount > 0) { totalInvested += accumulatedUSDT; totalQty += accumulatedQty; } else { totalInvested += levelCapital; totalQty += qty; } } const displayPrice = (levelPrice < 1) ? levelPrice.toFixed(6) : levelPrice.toFixed(4); let displayStep = step; const buyTimesLabel = ''; const multiBuyBadge = (canBuyMultiple && buyCount > 0) ? `<div class="multi-buy-indicator">${buyCount}</div>` : ''; const accumulatedLabel = (canBuyMultiple && accumulatedUSDT > 0) ? `<div class="u-val-accumulated">+$${accumulatedUSDT.toFixed(2)}</div>` : '';
            const triggeredBadge = _isTriggered ? `<div class="order-status-badge triggered" style="background:rgba(251,191,36,0.12);color:var(--warning);border:1px solid rgba(251,191,36,0.4);font-size:8px;padding:3px 7px;border-radius:10px;">⚡ ALCANZADO</div>` : '';
            // ── PROMEDIO ACUMULADO POR NIVEL (modo AUTO) ──────────────────
            if (cardStateClass === 'is-filled' || cardStateClass === 'is-filled-extra') {
                if (activeOrders[key] && activeOrders[key].status === 'filled') {
                    _runInv += activeOrders[key].price * activeOrders[key].amount;
                    _runQty += activeOrders[key].amount;
                } else if (isBoughtLegacy && !activeOrders[key]) {
                    _runInv += levelCapital; _runQty += qty;
                }
                if (canBuyMultiple && accumulatedUSDT > 0) { _runInv += accumulatedUSDT; _runQty += accumulatedQty; }
            }
            const _isAutoNow = (slotModes[activeIdx]||'manual') === 'auto';
            const _runAvg = _runQty > 0 ? _runInv / _runQty : 0;
            const _tRoi = botConfig.tp1Pct || 50; // TP1 — primera salida al avg+50%
            const _avgBadge = (cardStateClass === 'is-filled' && _runAvg > 0 && _isAutoNow) ?
                `<div class="level-avg-badge"><span class="lab-prom">≈PROM N1–N${i+1}: $${_runAvg < 1 ? _runAvg.toFixed(6) : _runAvg.toFixed(4)}</span><span class="lab-target">TARGET $${((_runAvg*(1+_tRoi/100)) < 1 ? (_runAvg*(1+_tRoi/100)).toFixed(6) : (_runAvg*(1+_tRoi/100)).toFixed(4))}</span></div>` : ''; html += `<div class="unified-card ${cardStateClass}" ${canBuyMultiple?'data-multi-live="1"':''} data-level-index="${i}" ontouchstart="startLevelPress(event, ${i})" ontouchend="endLevelPress(event)" onmousedown="startLevelPress(event, ${i})" onmouseup="endLevelPress(event)" onmouseleave="cancelLevelPress()"><div class="u-index">${i + 1}${canBuyMultiple ? `<br><small style="font-size:7px;">×${getMaxBuysForLevel(i)}</small>` : ''}</div><div class="u-center"><div class="u-title" style="font-size:18px;">$${displayPrice}${s.multiBuyAnchor&&s.multiBuyAnchor['calc_'+i]?'<span style="font-size:8px;color:var(--warning);margin-left:3px;">⟳</span>':''}</div><div class="u-sub">CANT: ${(canBuyMultiple && buyCount > 0 ? accumulatedQty : qty).toFixed(4)}</div></div><div class="u-right">${multiBuyBadge}<div class="u-val-primary">$${(canBuyMultiple && accumulatedUSDT > 0 ? accumulatedUSDT : levelCapital).toFixed(2)}</div><div class="u-val-secondary" style="color:var(--short)">${i === 0 ? '0%' : cumulativeDrop.toFixed(1) + '%'}</div><div style="font-family:var(--font-num);font-size:8px;color:var(--text-tertiary);text-align:right;">${i === 0 ? 'BASE' : 'paso -' + displayStep.toFixed(0) + '%'}</div></div>${triggeredBadge}${badgeHtml}${canBuyMultiple?`<div class="mb-live-strip" id="mb-strip-${i}"><div class="mb-live-reel animating" id="mb-reel-${i}"><div class="mb-live-item"><div class="mb-live-dot" style="background:var(--brand)"></div><span class="mb-live-label">MERCADO</span><span class="mb-live-val neutral" id="mb-lp-${i}">···</span></div><div class="mb-live-item"><div class="mb-live-dot" style="background:var(--warning)"></div><span class="mb-live-label">AHORRO</span><span class="mb-live-val saving" id="mb-ls-${i}">···</span></div><div class="mb-live-item"><div class="mb-live-dot" style="background:var(--long)"></div><span class="mb-live-label">PROM+ESTA</span><span class="mb-live-val positive" id="mb-la-${i}">···</span></div></div></div>`:''}${_avgBadge}
        </div>`; } grid.innerHTML = html; updateLevelsUI(); }
        function updateMultiBuyLiveStrips() {
            const s = slots[activeIdx];
            if (!s || !s.name || !s.price) return;
            const live = allGateETFs && allGateETFs.find(t => t.currency_pair === s.name+'_USDT');
            const lp = live ? parseFloat(live.last) : 0;
            if (!lp || lp <= 0) return;
            // Calcular totales actuales
            let tInv=0, tQty=0;
            for (let j=0; j<12; j++) {
                const k = getOrderKey(activeIdx,j);
                if (activeOrders[k]&&activeOrders[k].status==='filled') { tInv+=activeOrders[k].price*activeOrders[k].amount; tQty+=activeOrders[k].amount; }
                else if (s.buys&&s.buys.includes(j)) { const d=getLevelData(s,j); tInv+=d.usd; tQty+=d.qty; }
                if (j>=4&&j<=9&&s.multipleBuys&&s.multipleBuys[j]) { for(const b of s.multipleBuys[j]){tInv+=b.usd;tQty+=b.qty;} }
            }
            for (let i=4; i<=9; i++) {
                const pe=document.getElementById('mb-lp-'+i);
                const se=document.getElementById('mb-ls-'+i);
                const ae=document.getElementById('mb-la-'+i);
                if (!pe) continue;
                const ld=getLevelData(s,i);
                const p2=getStrategyParams(s.strat);
                const m2=customMultipliers?(customMultipliers[i]||1):1;
                const cap=p2.capital*m2;
                const bq=cap/lp;
                pe.textContent='$'+(lp<1?lp.toFixed(6):lp.toFixed(4));
                const sv=((ld.price-lp)/ld.price*100);
                if(sv>0.05){se.textContent='-'+sv.toFixed(1)+'% vs nivel';se.className='mb-live-val saving';}
                else if(sv<-0.05){se.textContent='+'+Math.abs(sv).toFixed(1)+'% sobre';se.className='mb-live-val neutral';}
                else{se.textContent='En precio';se.className='mb-live-val neutral';}
                if(tQty+bq>0){const na=(tInv+cap)/(tQty+bq);ae.textContent='$'+(na<1?na.toFixed(6):na.toFixed(4));ae.className=tQty>0&&na<tInv/tQty?'mb-live-val positive':'mb-live-val neutral';}
            }
        }

        function getLevelData(s, i) {
            // Cálculo secuencial puro — idéntico a renderLevels para que card y modal siempre coincidan
            let currentPrice = s.price;
            for (let k = 0; k <= i; k++) {
                if (k === 0) { currentPrice = s.price; }
                else { const step = getStepForLevel(s.strat, k); currentPrice = currentPrice * (1-(step/100)); }
            }
            const params = getStrategyParams(s.strat);
            let multiplier = customMultipliers ? (customMultipliers[i]||1) : 1;
            let levelCapital = params.capital * multiplier;
            return { price: currentPrice, qty: levelCapital/currentPrice, usd: levelCapital };
        }
        // ══════════════════════════════════════════════════════════════
        //  ESTRATEGIA: COMPRA ACUMULADA CUANDO PRECIO REAL < BASE EDITADA
        //  Si el usuario pone un precio base MAYOR al real, detectar hasta
        //  qué nivel ha caído el ETF y ofrecer comprar todos de golpe
        //  al precio REAL de mercado (no a los precios calculados por nivel)
        // ══════════════════════════════════════════════════════════════
        function getLivePrice(slotName) {
            const live = allGateETFs && allGateETFs.find(t => t.currency_pair === slotName + '_USDT');
            return live ? parseFloat(live.last) : 0;
        }

        function detectTriggeredLevels(slot, slotIdx) {
            // Retorna: { levels: [idx,...], livePrice, deepestLevel }
            // Solo aplica si slot tiene precio base Y hay precio real < precio base
            if (!slot || !slot.name || slot.price <= 0) return null;
            const livePrice = getLivePrice(slot.name);
            if (livePrice <= 0 || livePrice >= slot.price) return null; // Real no es menor al base

            // Calcular qué niveles han sido alcanzados por el precio real
            let currentPrice = slot.price;
            const triggeredLevels = [];
            const limit = customMultipliers ? customMultipliers.length : 12;

            for (let i = 0; i < limit; i++) {
                let levelPrice;
                if (i === 0) {
                    levelPrice = slot.price; // N1 = precio base
                } else {
                    const step = getStepForLevel(slot.strat, i);
                    levelPrice = currentPrice * (1 - step / 100);
                }
                currentPrice = levelPrice;

                // Si el precio real cayó POR DEBAJO de este nivel (estrictamente), está "alcanzado"
                // Para N1 usamos < (no <=) porque si livePrice == slot.price no debe disparar
                if (livePrice < levelPrice) {
                    // Solo incluir niveles que NO han sido comprados ya
                    const key = getOrderKey(slotIdx, i);
                    const alreadyBought = (slot.buys && slot.buys.includes(i))
                        || (activeOrders[key] && (activeOrders[key].status === 'open' || activeOrders[key].status === 'filled'));
                    if (!alreadyBought) {
                        triggeredLevels.push({ idx: i, calcPrice: levelPrice });
                    }
                } else {
                    break; // Precio real está por encima de este nivel, no hay más
                }
            }

            if (triggeredLevels.length === 0) return null;
            return {
                levels: triggeredLevels,
                livePrice,
                deepestLevel: triggeredLevels[triggeredLevels.length - 1].idx
            };
        }

        function showAccumulatedBuyModal(slot, slotIdx, triggered) {
            // Calcular capital total acumulado de los niveles alcanzados
            const params = getStrategyParams(slot.strat);
            let totalCapUsd = 0;
            triggered.levels.forEach(({ idx }) => {
                const mult = customMultipliers ? (customMultipliers[idx] || 1) : 1;
                totalCapUsd += params.capital * mult;
            });
            const livePrice = triggered.livePrice;
            const totalQty = totalCapUsd / livePrice;
            const levelNums = triggered.levels.map(l => 'N' + (l.idx + 1)).join('+');
            const deepest = triggered.deepestLevel + 1;

            // Mostrar modal con compra acumulada
            window._modalOpts = {
                amount: totalCapUsd,
                price: livePrice,
                isMarket: true,
                customTitle: `ACUM. ${levelNums}`,
                customSub: `${triggered.levels.length} niveles al precio actual`
            };

            const title = `ACUM. ${levelNums}`;
            showConfirmModal(title, `$${totalCapUsd.toFixed(2)} USDT`, (accepted) => {
                if (!accepted) return;

                // Registrar TODOS los niveles alcanzados como comprados al precio REAL
                triggered.levels.forEach(({ idx }) => {
                    const mult = customMultipliers ? (customMultipliers[idx] || 1) : 1;
                    const capUsd = params.capital * mult;
                    const qty = capUsd / livePrice;

                    // Registrar en buys del slot
                    if (!slot.buys.includes(idx)) slot.buys.push(idx);

                    // Para niveles multi-buy (N5-N10) usar multipleBuys
                    const canBuyMultiple = (idx >= 4 && idx <= 9);
                    if (canBuyMultiple) {
                        if (!slot.multipleBuys) slot.multipleBuys = {};
                        if (!slot.multipleBuys[idx]) slot.multipleBuys[idx] = [];
                        slot.multipleBuys[idx].push({
                            price: livePrice, qty, usd: capUsd,
                            isMarket: true, isAccumulated: true,
                            timestamp: Date.now()
                        });
                    }

                    // Recalcular anclas para niveles posteriores
                    if (canBuyMultiple && idx < 9) {
                        if (!slot.multiBuyAnchor) slot.multiBuyAnchor = {};
                        slot.multiBuyAnchor[idx] = livePrice;
                        let anc = livePrice;
                        for (let nl = idx + 1; nl <= 9; nl++) {
                            const st = getStepForLevel(slot.strat, nl);
                            anc = anc * (1 - st / 100);
                            slot.multiBuyAnchor['calc_' + nl] = anc;
                        }
                    }
                });

                // Guardar estado
                save();
                saveSlotsLevels();
                localStorage.setItem('c5x_slots', JSON.stringify(slots));

                // Enviar UNA SOLA orden MARKET por el total
                sendAccumulatedOrder(slot, slotIdx, triggered, livePrice, totalQty, totalCapUsd);

                // Refrescar UI
                renderLevels();
                for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
                refreshAllDashboardData();
                showToast(`✅ ${levelNums} comprados @$${livePrice.toFixed(livePrice < 1 ? 6 : 4)}`);
            });
        }

        async function sendAccumulatedOrder(slot, slotIdx, triggered, livePrice, totalQty, totalCapUsd) {
            const symbol = slot.name.toUpperCase();
            // Usar la key del nivel más profundo para tracking
            const deepIdx = triggered.deepestLevel;
            const key = getOrderKey(slotIdx, deepIdx) + '_acc';

            if (!apiConfig.key || !apiConfig.secret) {
                // Simulación
                triggered.levels.forEach(({ idx }) => {
                    const k = getOrderKey(slotIdx, idx);
                    activeOrders[k] = {
                        orderId: 'SIM_ACC_' + Date.now() + '_' + idx,
                        status: 'filled', price: livePrice,
                        amount: (customMultipliers ? customMultipliers[idx] || 1 : 1) * strategyParams.normal.capital / livePrice,
                        symbol, timestamp: Date.now(), simulated: true,
                        isMarket: true, isAccumulated: true, mode: 'manual'
                    };
                });
                saveActiveOrders();
                if (slotIdx === activeIdx) renderLevels();
                return;
            }

            try {
                const amount = totalQty.toFixed(4);
                const orderParams = {
                    currency_pair: symbol + '_USDT', side: 'buy',
                    amount, type: 'market', time_in_force: 'ioc'
                };
                const response = await callGateApi('POST', '/spot/orders', orderParams, true);
                if (response && response.id) {
                    // Marcar todos los niveles con el mismo order ID
                    triggered.levels.forEach(({ idx }) => {
                        const k = getOrderKey(slotIdx, idx);
                        activeOrders[k] = {
                            orderId: response.id, status: 'filled', price: livePrice,
                            amount: (customMultipliers ? customMultipliers[idx] || 1 : 1) * strategyParams.normal.capital / livePrice,
                            symbol, timestamp: Date.now(), simulated: false,
                            isMarket: true, isAccumulated: true, mode: 'manual'
                        };
                    });
                    saveActiveOrders();
                    if (slotIdx === activeIdx) renderLevels();
                    showToast(`✅ MARKET ACUMULADO — ID:${response.id}`);
                } else {
                    throw new Error('Respuesta inválida');
                }
            } catch(err) {
                showToast(`❌ Error orden acumulada: ${err.message}`);
            }
        }

        // ══════════════════════════════════════════════════════════════
        function updateDashboardStats(currentMarketPrice = null) {
            // Actualizar slot activo inmediatamente
            updateDashboardStatsForSlot(activeIdx, currentMarketPrice);
            // Programar refresh de los demás slots y dashboard general en siguiente tick
            setTimeout(() => {
                for (let i = 0; i < 10; i++) { if (i !== activeIdx) updateDashboardStatsForSlot(i); }
                if (typeof refreshAllDashboardData === 'function') refreshAllDashboardData();
            }, 50);
        }

        function updateDashboardStatsForSlot(slotIdx, currentMarketPrice = null) { 
            const slot = slots[slotIdx]; 
            const suffix = '-' + slotIdx;
            const invEl = document.getElementById('resInv' + suffix);
            const avgEl = document.getElementById('resAvg' + suffix);
            const targetEl = document.getElementById('resTarget' + suffix);
            if (!invEl) return;
            if (!slot || !slot.name) { 
                invEl.textContent = '$0.00'; 
                avgEl.textContent = '0.0000'; 
                targetEl.textContent = '0.0000'; 
                if (slotIdx === activeIdx) updateTradingInfoDisplay(); 
                return; 
            } 
            let totalInvested = 0; 
            let totalQuantity = 0; 
            for (let i = 0; i < 12; i++) { 
                const key = getOrderKey(slotIdx, i); 
                const canBuyMultiple = (i >= 4 && i <= 9); // N5-N10 multi-buy
                if (activeOrders[key] && activeOrders[key].status === 'filled') { 
                    const order = activeOrders[key]; 
                    totalInvested += order.price * order.amount; 
                    totalQuantity += order.amount; 
                } else if (slot.buys && slot.buys.includes(i) && !activeOrders[key]) { 
                    const d = getLevelData(slot, i); 
                    totalInvested += d.usd; 
                    totalQuantity += d.qty; 
                }
                if (canBuyMultiple && slot.multipleBuys && slot.multipleBuys[i]) {
                    for (let buy of slot.multipleBuys[i]) {
                        totalInvested += buy.usd;
                        totalQuantity += buy.qty;
                    }
                }
            } 
            invEl.textContent = totalInvested > 0 ? `$${totalInvested.toFixed(2)}` : '$0.00'; 
            const avgPrice = totalQuantity > 0 ? totalInvested / totalQuantity : 0; 

            // ── PROMEDIO — con indicador visual si hay rebuy activo ──
            const avgFmt = p => p <= 0 ? '0.0000' : (p < 0.0001 ? p.toFixed(10).replace(/\.?0+$/, '') : p < 1 ? p.toFixed(6) : p.toFixed(4));
            const _rbc = slot.rebuyCount || 0;
            if (_rbc > 0 && slot.rebuyOldQty > 0) {
                // Rebuy activo: mostrar ciclo actual y promedio blend
                avgEl.innerHTML = `<span style="color:var(--warning);font-size:8px;display:block;line-height:1.2;letter-spacing:.3px;">🔄BLEND ${_rbc}/3</span>${avgFmt(avgPrice)}`;
            } else {
                avgEl.textContent = avgFmt(avgPrice);
            }

            // ── OBJETIVO — muestra TP1 (avg+50%) y TRAILING (desde precio TP1 +100%) ──
            const tp1Pct   = botConfig.tp1Pct         || 50;
            const trailPct = botConfig.trailActivePct || 100;
            const dropPct  = botConfig.trailDropPct   || 15;
            if (avgPrice > 0) {
                const tp1Price   = avgPrice * (1 + tp1Pct   / 100);
                // TP2/Trailing se activa desde el precio de venta TP1, no desde avg
                const trailPrice = tp1Price  * (1 + trailPct / 100);
                // Check if TP1 already done — show real trail activation price
                const tData = trailingStopData && trailingStopData[slotIdx];
                const realTrailPx = (tData && tData.tp1SellPrice && tData.tp1SellPrice > 0)
                    ? tData.tp1SellPrice * (1 + trailPct / 100)
                    : trailPrice;
                const trailLabel = tData && tData.tp1SellPrice
                    ? `📈TP1+${trailPct}%`
                    : `📈 TP1+${trailPct}%`;
                targetEl.innerHTML =
                    `<span style="color:var(--long);font-size:8px;display:block;line-height:1.3;">🟢TP1+${tp1Pct}% ${avgFmt(tp1Price)}</span>` +
                    `<span style="color:var(--brand);font-size:8px;display:block;line-height:1.3;">${trailLabel} ${avgFmt(realTrailPx)}</span>`;
            } else {
                targetEl.textContent = '0.0000';
            }
            // Actualizar coin y base para este slot
            const coinEl = document.getElementById('dashTradingCoin' + suffix);
            if (coinEl) { coinEl.textContent = slot.name || '---'; coinEl.style.color = getCoinColor(slot.name); }
            const baseEl = document.getElementById('dashBaseDisplay' + suffix);
            if (baseEl) { baseEl.textContent = slot.price > 0 ? (slot.price < 1 ? slot.price.toFixed(6) : slot.price.toFixed(4)) : '0.0000'; }
            if (slotIdx === activeIdx) updateTradingInfoDisplay(); 
        }
        // ── REFRESCO COMPLETO DE TODOS LOS DASHBOARDS ──────────────────
        // Se llama tras cualquier compra/cambio de nivel para sincronizar
        // el Panel 2 (5 slots) y el Panel 1 (Gate.io dashboard) al instante
        function refreshAllDashboardData() {
            // 1. Actualizar los 10 slots del Panel de Dashboards
            for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
            // 2. Reordenar dashboards por inversión
            setTimeout(sortAndRenderDashboards, 200);
            // 2. Recalcular inversión activa para Gate.io
            const enUso = calcGdEnUso();
            const libre = globalCapital > 0 ? globalCapital - enUso : 0;
            const total = globalCapital > 0 ? globalCapital : enUso;
            setGdEl('gdEnUso', '$' + enUso.toFixed(2));
            if (total > 0) {
                const librePct = ((libre / total) * 100).toFixed(0);
                setGdEl('gdLibrePct', librePct + '% disponible');
            }
            const activeSlots = slots.filter(s => s.name).length;
            setGdEl('gdSlotCount', activeSlots + (activeSlots === 1 ? ' slot activo' : ' slots activos'));
            // 3. Refrescar barra de portafolio
            renderGdDualBar();
            // 4. PNL
            calcGdStats();
        }

        function switchStrategy(strategy) { 
            // Solo estrategia normal disponible
            triggerHaptic(); 
            if(navigator.vibrate) navigator.vibrate([80, 50]); 
            const s = slots[activeIdx]; 
            
            s.strat = 'normal'; 
            s.capital = strategyParams.normal.capital || 5; 
            showToast(`⚡ ESTRATEGIA NORMAL - Capital: $${s.capital}`, 2500); 
            
            save(); 
            updateStrategyButtonVisuals(); 
            updateDashUI(); 
            calculate(); 
        }

        async function fetchWalletBalance() { 
            try { 
                // Obtener TODOS los balances spot
                const allBalances = await callGateApi("GET", "/spot/accounts", {}, true); 
                if (!allBalances || !Array.isArray(allBalances)) throw new Error("Sin respuesta");
                
                // USDT disponible
                const usdtRow = allBalances.find(b => b.currency === 'USDT');
                const usdtAvailable = usdtRow ? parseFloat(usdtRow.available) + parseFloat(usdtRow.locked || 0) : 0;
                availableUSDT = usdtRow ? parseFloat(usdtRow.available) : 0;
                globalCapital = availableUSDT;
                localStorage.setItem('c5x_global_capital', globalCapital);
                const elCap = document.getElementById('setGlobalCapital');
                if(elCap) elCap.value = availableUSDT.toFixed(2);

                // Calcular valor total incluyendo todos los activos con allGateETFs
                let totalUSD = usdtAvailable;
                const nonUsdt = allBalances.filter(b => b.currency !== 'USDT' && (parseFloat(b.available) + parseFloat(b.locked||0)) > 0);
                for (const bal of nonUsdt) {
                    const amt = parseFloat(bal.available) + parseFloat(bal.locked || 0);
                    const ticker = allGateETFs ? allGateETFs.find(t => t.currency_pair === bal.currency + '_USDT') : null;
                    if (ticker) {
                        totalUSD += amt * parseFloat(ticker.last);
                    } else if (gdMarketData && gdMarketData[bal.currency]) {
                        totalUSD += amt * gdMarketData[bal.currency].price;
                    }
                }

                // Guardar caché persistente solo si el valor es real
                if (totalUSD > 1) {
                    localStorage.setItem('c5x_cached_total', totalUSD.toFixed(2));
                    localStorage.setItem('c5x_cached_libre', availableUSDT.toFixed(2));
                }

                // Actualizar UI
                const totalBalanceEl = document.getElementById('totalBalanceDisplay');
                if (totalBalanceEl) totalBalanceEl.textContent = '$' + totalUSD.toFixed(2);
                updateGdMetrics(totalUSD, availableUSDT);
                autoImportGatePositions(); 
            } catch (e) { 
                console.warn('fetchWalletBalance error:', e);
                const savedCapital = globalCapital || 0; 
                const totalBalanceEl = document.getElementById('totalBalanceDisplay');
                if (totalBalanceEl) totalBalanceEl.textContent = "$" + savedCapital.toFixed(2);
            } 
        }
        async function autoImportGatePositions() { try { const balances = await callGateApi("GET", "/spot/accounts", {}, true); if(!balances || !Array.isArray(balances)) return; const activeBalances = balances.filter(b => b.currency !== 'USDT' && parseFloat(b.available) > 0.001); let imported = 0; activeBalances.forEach(bal => { const coinName = bal.currency; const exists = slots.some(s => s.name === coinName); if (!exists) { const emptyIdx = slots.findIndex(s => !s.name || s.name === ''); if (emptyIdx !== -1) { slots[emptyIdx].name = coinName; slots[emptyIdx].price = 0; slots[emptyIdx].capital = 5; slots[emptyIdx].strat = 'normal'; slots[emptyIdx].locked = true; imported++; } } }); if (imported > 0) { save(); selectSlot(activeIdx); renderAllDashboards(); showToast(`✅ ${imported} pos. importada(s)`); } } catch(e) { console.warn("Auto-Import Error", e); } }
        function setLightMode(isLightMode) { triggerHaptic(); applyTheme(isLightMode ? 1 : 0); }
        let secCallback = null;
        function reqSec(cb) { secCallback = cb; const m = document.getElementById('securityModal'); document.getElementById('secInput').value = ''; m.style.display = 'flex'; void m.offsetWidth; }
        function validateSecurity() {
            const inp = document.getElementById('secInput').value;
            closeModals();
            // ── FIX: comparar siempre contra el HASH, nunca contra texto plano ──
            const storedHash = localStorage.getItem('c5x_pin_hash') || _DEFAULT_PIN_HASH;
            if (_hashPin(inp) === storedHash) {
                if(secCallback) secCallback();
            } else {
                showToast("⛔ PIN INCORRECTO");
            }
        }
        // ════════════════════════════════════════════════════════════════
        //  FIX CRÍTICO 2 — CLAVES API: IndexedDB + limpieza por inactividad
        // ════════════════════════════════════════════════════════════════
        // ANTES: localStorage con AES cuya clave era predecible (userAgent+width)
        //   → cualquier extensión, iframe o XSS podía leer localStorage completo
        // AHORA:
        //   1. La clave de cifrado AES se genera con crypto.getRandomValues y se
        //      guarda en IndexedDB (aislado por origen, inaccesible a JS de terceros)
        //   2. Las API keys cifradas van a IndexedDB, NO a localStorage
        //   3. Tras 30 min de inactividad, apiConfig se limpia de memoria
        //      (las keys persisten cifradas en IDB pero salen de la variable JS)

        // ── IDB helper minimalista ────────────────────────────────────
        const _idb = {
            _db: null,
            async open() {
                if (this._db) return this._db;
                return new Promise((res, rej) => {
                    const req = indexedDB.open('c5x_secure', 1);
                    req.onupgradeneeded = e => e.target.result.createObjectStore('kv');
                    req.onsuccess  = e => { this._db = e.target.result; res(this._db); };
                    req.onerror    = e => rej(e);
                });
            },
            async get(key) {
                const db = await this.open();
                return new Promise((res, rej) => {
                    const tx = db.transaction('kv', 'readonly');
                    const req = tx.objectStore('kv').get(key);
                    req.onsuccess = () => res(req.result ?? null);
                    req.onerror   = () => res(null);
                });
            },
            async set(key, value) {
                const db = await this.open();
                return new Promise((res, rej) => {
                    const tx = db.transaction('kv', 'readwrite');
                    tx.objectStore('kv').put(value, key);
                    tx.oncomplete = () => res(true);
                    tx.onerror    = () => res(false);
                });
            },
            async del(key) {
                const db = await this.open();
                return new Promise((res) => {
                    const tx = db.transaction('kv', 'readwrite');
                    tx.objectStore('kv').delete(key);
                    tx.oncomplete = () => res(true);
                    tx.onerror    = () => res(false);
                });
            }
        };

        // ── Obtener o crear clave AES almacenada en IDB ───────────────
        async function _getOrCreateIdbSalt() {
            let salt = await _idb.get('c5x_aes_salt');
            if (!salt) {
                // Generar 32 bytes criptográficamente seguros
                const bytes = new Uint8Array(32);
                crypto.getRandomValues(bytes);
                salt = Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
                await _idb.set('c5x_aes_salt', salt);
            }
            return salt;
        }

        // ── Cifrar keys → IDB ─────────────────────────────────────────
        async function _encryptKeys(k, s) {
            const salt = await _getOrCreateIdbSalt();
            const payload = JSON.stringify({ key: k, secret: s, ts: Date.now() });
            const encrypted = CryptoJS.AES.encrypt(payload, salt).toString();
            await _idb.set('c5x_api_keys_v3', encrypted);
            // Eliminar versiones antiguas de localStorage si existen
            localStorage.removeItem('c5x_api_keys');
            return true;
        }

        // ── Descifrar keys desde IDB ──────────────────────────────────
        async function _decryptKeys() {
            try {
                // v3: IDB con salt aleatorio
                const encrypted = await _idb.get('c5x_api_keys_v3');
                if (encrypted) {
                    const salt = await _idb.get('c5x_aes_salt');
                    if (salt) {
                        const dec = CryptoJS.AES.decrypt(encrypted, salt).toString(CryptoJS.enc.Utf8);
                        const parsed = JSON.parse(dec);
                        if (parsed.key && parsed.secret) return { key: parsed.key, secret: parsed.secret };
                    }
                }
                // Migración v2 (localStorage AES) → v3 (IDB)
                const v2Raw = localStorage.getItem('c5x_api_keys');
                if (v2Raw) {
                    const v2 = JSON.parse(v2Raw);
                    if (v2 && v2.v === 2 && v2.ek && v2.es) {
                        const oldSalt = 'c5x_v2_' + (navigator.userAgent.length + screen.width);
                        const k = CryptoJS.AES.decrypt(v2.ek, oldSalt).toString(CryptoJS.enc.Utf8);
                        const s = CryptoJS.AES.decrypt(v2.es, oldSalt).toString(CryptoJS.enc.Utf8);
                        if (k && s) {
                            // Migrar a v3 automáticamente
                            await _encryptKeys(k, s);
                            console.info('[5X] API keys migradas de localStorage → IndexedDB');
                            return { key: k, secret: s };
                        }
                    }
                    // v1 plaintext → migrar
                    if (v2 && v2.key && v2.secret) {
                        await _encryptKeys(v2.key, v2.secret);
                        localStorage.removeItem('c5x_api_keys');
                        return { key: v2.key, secret: v2.secret };
                    }
                }
            } catch(e) { console.warn('[5X] _decryptKeys error:', e); }
            return { key: '', secret: '' };
        }

        // ── Limpieza de memoria por inactividad (30 min) ──────────────
        let _inactivityTimer = null;
        const _INACTIVITY_MS = 30 * 60 * 1000; // 30 min
        function _resetInactivityTimer() {
            if (_inactivityTimer) clearTimeout(_inactivityTimer);
            _inactivityTimer = setTimeout(() => {
                // Limpiar keys de memoria (siguen en IDB cifradas)
                if (apiConfig.key || apiConfig.secret) {
                    apiConfig = { key: '', secret: '' };
                    isPrivateMode = false;
                    showToast('🔒 Sesión inactiva — reconecta tus API Keys', 5000, true);
                    console.info('[5X] API keys limpiadas de memoria por inactividad');
                }
            }, _INACTIVITY_MS);
        }
        // Reiniciar timer en cada interacción del usuario
        ['touchstart','click','keydown','scroll'].forEach(ev =>
            document.addEventListener(ev, _resetInactivityTimer, { passive: true })
        );
        _resetInactivityTimer(); // iniciar al cargar

        function saveApiKeysSecure() {
            reqSec(async () => {
                const k = document.getElementById('apiKey').value.trim();
                const s = document.getElementById('apiSecret').value.trim();
                if (k && s) {
                    apiConfig = { key: k, secret: s };
                    // FIX: guardar en IndexedDB cifrado, nunca en localStorage
                    await _encryptKeys(k, s);
                    showToast('✅ API Keys Guardadas (cifradas en IDB)');
                    document.getElementById('apiKey').value   = '';
                    document.getElementById('apiSecret').value = '';
                    document.getElementById('apiKey').placeholder    = '●●●●●●●●' + k.slice(-4);
                    document.getElementById('apiSecret').placeholder = '●●●●●●●●' + s.slice(-4);
                    isPrivateMode = true;
                    _resetInactivityTimer();
                    startFullSyncSchedule();
                } else {
                    showToast('⚠️ Campos vacíos');
                }
            });
        }
        function saveGlobalCapSecure() { if (!isSuperAdmin) { showToast('⛔ Admin requerido'); return; } reqSec(() => { const val = parseFloat(document.getElementById('setGlobalCapital').value); const feeVal = parseFloat(document.getElementById('setFee').value); if(!isNaN(val)) { globalCapital = val; localStorage.setItem('c5x_global_capital', globalCapital); } if(!isNaN(feeVal)) { exchangeFee = feeVal; localStorage.setItem('c5x_fee', exchangeFee); } calculateGlobalStats(); showToast("✅ Capital y Comisión Guardados"); }); }
        function saveRadarSecure() { reqSec(() => { const lim = parseInt(document.getElementById('setRadarLimit').value); const spd = parseInt(document.getElementById('setRadarSpeed').value); const tickSpd = parseInt(document.getElementById('setTickerSpeed').value); const monLim = parseInt(document.getElementById('setMonitorLimit').value); const autoAdj = parseFloat(document.getElementById('setAutoAdjustThreshold').value); if(lim > 0) { radarLimit = lim; localStorage.setItem('c5x_radar_limit', lim); fetchAndCalcTopDroppers(); } if(spd > 0) { radarSpeed = spd; localStorage.setItem('c5x_radar_speed', spd); startRadarRotation(); } if(tickSpd > 0) { tickerSpeed = tickSpd; localStorage.setItem('c5x_ticker_speed', tickSpd); startTickerSystem(); } if(monLim > 0) { monitorLimit = monLim; localStorage.setItem('c5x_monitor_limit', monLim); if(typeof applyRadarSort==='function') applyRadarSort(); } if(autoAdj > 0) { autoAdjustThreshold = autoAdj; localStorage.setItem('c5x_auto_adjust_threshold', autoAdj); } showToast("✅ Tiempos y Límites Actualizados"); }); }
        function saveMultiSecure() { reqSec(() => { const inputs = document.querySelectorAll('.multi-inp'); let newMultipliers = []; inputs.forEach(inp => { let val = parseFloat(inp.value); if(!isNaN(val)) newMultipliers.push(val); }); if(newMultipliers.length >= 5) { customMultipliers = newMultipliers; localStorage.setItem('c5x_multipliers', JSON.stringify(customMultipliers)); calculate(); showToast("✅ Multiplicadores Guardados"); } else { showToast("⚠️ Mínimo 5 Niveles"); } }); }
        function savePassSecure() { reqSec(() => { const newPass = document.getElementById('setNewPass').value; if(newPass && newPass.length === 4) { /* FIX: guardar solo el hash, nunca el PIN raw */ localStorage.setItem('c5x_pin_hash', _hashPin(newPass)); /* Limpiar pin legacy si existiera */ if(appConfig.pin) { delete appConfig.pin; localStorage.setItem('c5x_config', JSON.stringify(appConfig)); } showToast("✅ Contraseña Cambiada"); } else { showToast("⚠️ Clave debe ser 4 dígitos"); } }); }
        function updateStratExitSummary() {
            const el = document.getElementById('stratExitSummary');
            if (!el) return;
            const tp1  = botConfig.tp1Pct         || 50;
            const tact = botConfig.trailActivePct  || 100;
            const trd  = botConfig.trailDropPct    || 15;
            const rb   = botConfig.rebuyDropPct    || 16;
            el.innerHTML =
                `🟢 <b>TP1</b>: avg+${tp1}% → vende 50% del activo<br>` +
                `📈 <b>TRAILING</b>: activa a avg+${tact}% → corre hasta retroceso -${trd}% desde máximo → vende el 50% restante<br>` +
                `🔄 <b>REBUY</b>: si cae -${rb}% desde TP1 → reactiva 12 niveles (hasta 3 veces) · acumula promedios<br>` +
                `⚡ <b>CRASH</b>: niveles saltados se compran acumulados en una sola orden`;
        }

        function saveStrategyParams(strategyType) { 
            if (!isSuperAdmin) { showToast('⛔ Admin requerido'); return; }
            reqSec(() => { 
                if (strategyType === 'normal') { 
                    const capital = parseFloat(document.getElementById('setCapitalNormal').value); 
                    const inc     = parseFloat(document.getElementById('setIncNormal').value); 
                    const desc    = parseFloat(document.getElementById('setDescNormal').value); 
                    const dd      = parseFloat(document.getElementById('setDDNormal').value); 
                    
                    const _markErr = (id, msg) => {
                        const el = document.getElementById(id);
                        if (el) { el.style.borderColor = 'var(--short)'; el.style.boxShadow = '0 0 6px rgba(248,113,113,0.4)'; setTimeout(() => { el.style.borderColor=''; el.style.boxShadow=''; }, 2500); }
                        showToast('⚠️ ' + msg);
                    };
                    if (isNaN(capital) || capital < 1 || capital > 10000)  return _markErr('setCapitalNormal', 'Capital: entre $1 y $10,000');
                    if (isNaN(inc)     || inc < 0.5 || inc > 100)          return _markErr('setIncNormal',     'Nivel 2+: entre 0.5% y 100%');
                    if (isNaN(desc)    || desc < 0.5 || desc > 100)        return _markErr('setDescNormal',    'Nivel 1: entre 0.5% y 100%');
                    if (isNaN(dd)      || dd < 1 || dd > 100)              return _markErr('setDDNormal',      'DD Máx: entre 1% y 100%');
                    
                    strategyParams.normal = { capital, inc, desc, dd }; 
                    localStorage.setItem('c5x_strategy_params', JSON.stringify(strategyParams)); 
                    showToast(`✅ Estrategia normal guardada`); 
                    updateStratExitSummary();
                    
                    const currentSlot = slots[activeIdx]; 
                    if (currentSlot.strat === 'normal') { 
                        calculate(); 
                    } 
                }
            }); 
        }
        function updateStats(tf) { triggerHaptic(); document.querySelectorAll('.stat-btn').forEach(b => b.classList.remove('active')); const btns = document.querySelectorAll('.stat-btn'); if(tf === 'D') btns[0].classList.add('active'); else if(tf === 'W') btns[1].classList.add('active'); else if(tf === 'M') btns[2].classList.add('active'); else if(tf === 'A') btns[3].classList.add('active'); const chart = document.getElementById('pnlChart'); chart.innerHTML = ''; const now = new Date(); let totalNet = 0; let wins = 0, total = 0; const filtered = history.filter(h => { if(!h.date) return false; const parts = h.date.split('/'); const hDate = new Date(parts[2], parts[1]-1, parts[0]); const diffTime = Math.abs(now - hDate); const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); if(tf === 'D' && diffDays <= 7) return true; if(tf === 'W' && diffDays <= 60) return true; if(tf === 'M' && diffDays <= 365) return true; if(tf === 'A') return true; return false; }).reverse(); let groups = {}; filtered.forEach(h => { let key = h.date; if(tf === 'M' || tf === 'A') { const parts = h.date.split('/'); key = parts[1] + '/' + parts[2].substring(2); } if(!groups[key]) groups[key] = 0; const p = (h.netProfit !== undefined) ? parseFloat(h.netProfit) : (parseFloat(h.profit) || 0); groups[key] += p; totalNet += p; total++; if(p > 0) wins++; }); const keys = Object.keys(groups); const maxVal = Math.max(...Object.values(groups).map(Math.abs), 1); keys.forEach(k => { const val = groups[k]; const heightPct = (Math.abs(val) / maxVal) * 100; const bar = document.createElement('div'); bar.className = `chart-bar ${val >= 0 ? 'win' : 'loss'}`; bar.style.height = Math.max(heightPct, 5) + '%'; bar.setAttribute('data-val', (val>=0?'+':'') + Math.round(val)); chart.appendChild(bar); }); if(keys.length === 0) chart.innerHTML = '<div style="width:100%; text-align:center; color:var(--text-tertiary); font-size:10px; padding-bottom:20px;">SIN ACTIVIDAD RECIENTE</div>'; const netEl = document.getElementById('chartNeto'); netEl.textContent = (totalNet>=0?'+':'') + '$' + totalNet.toFixed(2); netEl.style.color = totalNet >= 0 ? 'var(--long)' : 'var(--short)'; document.getElementById('chartWr').textContent = total > 0 ? Math.round((wins/total)*100) + '%' : '0%'; }
        function openMenuViaButton() { document.getElementById('navModal').style.display = 'flex'; }
        function closeMenuViaButton() { document.getElementById('navModal').style.display = 'none'; switchView('operate'); }

        // ── NAVEGACIÓN CON HISTORIAL DEL NAVEGADOR ──────────────────────
        // Permite que el botón Atrás del móvil regrese al dashboard
        // en lugar de cerrar la app.

        function switchView(viewName) {
            triggerHaptic();
            document.getElementById('navModal').style.display = 'none';
            closeUserMenu();

            // Si ya estamos en esa sección, no hacer nada
            if (currentSection === viewName) return;

            // Empujar estado al historial del navegador
            // (solo si vamos a una sección diferente de operate)
            if (viewName !== 'operate') {
                window.history.pushState({ c5xView: viewName }, '', '#' + viewName);
            } else {
                // Al volver a operate: reemplazar estado para no acumular
                window.history.replaceState({ c5xView: 'operate' }, '', window.location.pathname);
            }

            updateViewVisuals(viewName);
        }

        function updateViewVisuals(viewName) {
            currentSection = viewName;
            document.querySelectorAll('.app-section').forEach(el => el.classList.remove('active'));
            const section = document.getElementById('section-' + viewName);
            if (section) section.classList.add('active');
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('selected'));
            const navItem = document.getElementById('nav-' + viewName);
            if (navItem) navItem.classList.add('selected');
            const spacer = document.querySelector('.content-spacer');
            // Usar CSS directamente — el env() no se puede leer con parseInt en todos los browsers
            if (spacer) {
                spacer.style.marginTop = '';  // resetear inline para que CSS variable funcione
            }
            if (viewName === 'operate') {
                if (chartSymbol) loadChart(chartSymbol);
                if (currentPanel === 2) forceRenderLevels(activeIdx);
                // ── CRITICAL FIX: reconstruir dashboards SIEMPRE al volver a Operar
                // Garantiza que cualquier operación cerrada quede reflejada correctamente
                setTimeout(renderAllDashboards, 30);
            }
            if (viewName === 'etf') loadGateETFs();
            if (viewName === 'settings') { loadSettingsValues(); renderTickerSettings(); applyRoleVisibility(); }
            if (viewName === 'support')  { renderSupportChat(); loadSupportMessages(); }
            if (viewName === 'strategy') { renderStrategyParams(); }
            if (viewName === 'log') updateStats('D');
            updateETFFloatButtonVisibility();
            window.scrollTo(0, 0);
        }

        // Botón Atrás del sistema (Android/iOS/PC)
        window.onpopstate = function(event) {
            // Cerrar modal de menú si está abierto
            document.getElementById('navModal').style.display = 'none';
            closeUserMenu();

            // ── Si el Panel 3 (12 niveles) está abierto → cerrarlo primero
            if (currentPanel === 2 && currentSection === 'operate') {
                switchPanel(1);
                setTimeout(renderAllDashboards, 50);
                return;
            }

            const estado = event.state;

            if (estado && estado.c5xView && estado.c5xView !== 'operate') {
                // Hay un estado previo que no es operate → navegar a él
                updateViewVisuals(estado.c5xView);
            } else {
                // Sin estado o es operate → volver al dashboard principal
                updateViewVisuals('operate');
                // Asegurar que exista un estado base para no salir con el siguiente Atrás
                window.history.replaceState({ c5xView: 'operate' }, '', window.location.pathname);
            }
        };
        function setupSwipe() {
            document.addEventListener('touchstart', e => {
                window.touchStartX = e.changedTouches[0].screenX;
                window.touchStartY = e.changedTouches[0].screenY;
                window._touchTarget = e.target;
                window._panelSwipeActive = false; // reset flag
            }, {passive: true});
            document.addEventListener('touchend', e => {
                // Ignorar si el panel swipe está activo (detectado por is-dragging)
                const panelCont = document.getElementById('panelsContainer');
                if (panelCont && panelCont.classList.contains('is-dragging')) return;
                if (window._panelSwipeActive) return;
                // ── Ignorar swipe si el toque empezó en un elemento interactivo ──
                const t = window._touchTarget;
                if (t) {
                    const tag = t.tagName.toLowerCase();
                    // inputs, selects, textareas, botones: nunca swipe
                    if (['input','select','textarea','button'].includes(tag)) return;
                    // Si está dentro de un contenedor con scroll horizontal propio
                    if (t.closest('[data-noscroll], .etf-tab-content, #etfGrid, #logGrid, #botDashLog, #botDashSlots, #radarFilterBar, #radarTickerContainer, .levels-container, .chat-messages, .settings-grid, .stats-card, textarea, pre')) return;
                }
                let touchEndX = e.changedTouches[0].screenX;
                let touchEndY = e.changedTouches[0].screenY;
                handleSwipe(window.touchStartX, window.touchStartY, touchEndX, touchEndY);
            }, {passive: true});
        }
        function handleSwipe(tsX, tsY, teX, teY) {
            const threshold = 100; // ← subido de 60 a 100px para evitar swipes accidentales
            const diffX = teX - tsX;
            const diffY = teY - tsY;

            // Ignorar si componente vertical supera al horizontal (scroll normal)
            if (Math.abs(diffY) > Math.abs(diffX) * 0.7) return;
            // Ignorar si el movimiento es pequeño
            if (Math.abs(diffX) < threshold) return;

            // En sección OPERAR: navegar entre slots
            if (currentSection === 'operate') {
                const occupiedIndices = slots.map((s, i) => s.name ? i : -1).filter(i => i !== -1);
                if (occupiedIndices.length === 0) {
                    if (diffX < -threshold) { let next = activeIdx + 1; if(next > 4) next = 0; selectSlot(next); }
                    else if (diffX > threshold) { let prev = activeIdx - 1; if(prev < 0) prev = 4; selectSlot(prev); }
                    return;
                }
                let currentPos = occupiedIndices.indexOf(activeIdx);
                if (diffX < -threshold) {
                    let nextPos = currentPos === -1 ? 0 : (currentPos + 1) % occupiedIndices.length;
                    selectSlot(occupiedIndices[nextPos]);
                } else if (diffX > threshold) {
                    let prevPos = currentPos === -1 ? occupiedIndices.length - 1 : (currentPos - 1 + occupiedIndices.length) % occupiedIndices.length;
                    selectSlot(occupiedIndices[prevPos]);
                }
            }
            // En otras secciones: NO swipe entre secciones (demasiado accidental)
            // Solo se navega con el menú o botones
        }
        async function requestWakeLock() { try { if ('wakeLock' in navigator) await navigator.wakeLock.request('screen'); } catch (err) {} }
        function unlockAudioAndWake() {
            const audio = document.getElementById('alertSound');
            if (audio) { audio.play().then(() => { audio.pause(); audio.currentTime = 0; }).catch(() => {}); }
            // FIX: el permiso ya se gestiona automáticamente en checkNotifPermission()
            // No se muestra ningún banner — el sistema operativo pregunta directamente
            notifGranted = ('Notification' in window && Notification.permission === 'granted');
            requestWakeLock();
        }
        function showToast(txt, duration = 2500, isAlert = false, isSuccess = false) { const t = document.getElementById("toast"); t.textContent = txt; t.className = ""; if(isAlert) t.classList.add("alert-mode"); if(isSuccess) t.classList.add("success-mode"); t.classList.add("show"); setTimeout(() => { t.classList.remove("show"); }, duration); }
        
        function sortSlots() {
            // Build index map before sorting
            const oldOrder = slots.map((s, i) => i);
            const filled = slots.map((s,i) => ({s, i})).filter(x => x.s.name && x.s.name !== '');
            const empty  = slots.map((s,i) => ({s, i})).filter(x => !x.s.name || x.s.name === '');
            const sorted = [...filled, ...empty];
            const newOrder = sorted.map(x => x.i); // newOrder[newIdx] = oldIdx

            // Remap activeOrders keys: s{oldIdx}_l{lvl} → s{newIdx}_l{lvl}
            const newActiveOrders = {};
            Object.keys(activeOrders).forEach(key => {
                const match = key.match(/^s(\d+)_(.+)$/);
                if (match) {
                    const oldIdx = parseInt(match[1]);
                    const rest = match[2];
                    const newIdx = newOrder.indexOf(oldIdx);
                    if (newIdx !== -1) newActiveOrders[`s${newIdx}_${rest}`] = activeOrders[key];
                }
            });
            activeOrders = newActiveOrders;
            saveActiveOrders();

            // Remap slotModes
            const newSlotModes = newOrder.map(oldIdx => slotModes[oldIdx] || 'manual');
            slotModes = newSlotModes;
            localStorage.setItem('c5x_slot_modes', JSON.stringify(slotModes));

            // Remap trailingStopData
            const newTrailing = {};
            newOrder.forEach((oldIdx, newIdx) => {
                if (trailingStopData[oldIdx]) newTrailing[newIdx] = trailingStopData[oldIdx];
            });
            trailingStopData = newTrailing;

            slots = sorted.map(x => x.s);
            save();
        }
        
        function calculateGlobalStats() { let totalRealizedProfit = history.reduce((sum, item) => { return sum + (item.netProfit !== undefined ? parseFloat(item.netProfit) : (parseFloat(item.profit) || 0)); }, 0); let currentEquity = globalCapital + totalRealizedProfit; }
        
        function cleanSlotOnly() { 
            triggerHaptic(); 
            if(confirm("¿Limpiar datos del Slot actual?")) { 
                const currentStrat = slots[activeIdx].strat || 'normal'; 
                const currentCapital = strategyParams.normal.capital; 
                slots[activeIdx] = { name:'', price:0, capital: currentCapital, buys:[], strat: currentStrat, locked: true, note: '', alerted: false, multipleBuys: {}, rebuyCount: 0, rebuyOldSpent: 0, rebuyOldQty: 0 }; 
                
                for (let i = 0; i < 12; i++) {
                    const key = getOrderKey(activeIdx, i);
                    if (activeOrders[key]) delete activeOrders[key];
                }
                saveActiveOrders();
                
                sortSlots();
                // BUG FIX: reconstruir el DOM del dashboard DESPUÉS de sortSlots()
                renderAllDashboards();
                selectSlot(0);
                
                showToast("🗑️ Slot Limpiado y reordenado"); 
            } 
        }
        
        async function fetchAndCalcTopDroppers() { 
            const elVal = document.getElementById('radarValue'); 
            const elStatus = document.getElementById('radarStatus'); 
            const radarContainer = document.getElementById('radarTickerContainer'); 
            elStatus.className = 'radar-status-dot offline'; 
            
            try { 
                // Intentar Gate.io directo primero, luego fallback a proxy si falla
                let res;
                try {
                    res = await callGatePublic("/spot/tickers");
                } catch(corsErr) {
                    console.warn("⚠️ Gate.io directo falló, intentando proxy...", corsErr.message);
                    // Fallback: usar el proxy configurado
                    const proxyUrl = localStorage.getItem('c5x_proxy_url') || '';
                    if (proxyUrl) {
                        const pr = await fetch(proxyUrl + '?endpoint=/spot/tickers', { method:'GET', headers:{'Accept':'application/json'} });
                        res = await pr.json();
                    } else { throw corsErr; }
                }
                let tickers = Array.isArray(res) ? res : (res.result || res.data || []); 
                if(tickers.length === 0) throw new Error("No data"); 
                
                elStatus.className = 'radar-status-dot online'; 
                
                // Obtener info de BTC y ETH para correlación
                const btcTicker = tickers.find(t => t.currency_pair === 'BTC_USDT');
                const ethTicker = tickers.find(t => t.currency_pair === 'ETH_USDT');
                const btcChange = btcTicker ? parseFloat(btcTicker.change_percentage) : 0;
                const ethChange = ethTicker ? parseFloat(ethTicker.change_percentage) : 0;
                const btcVolume = btcTicker ? parseFloat(btcTicker.quote_volume) : 0;
                
                console.log(`📊 BTC: ${btcChange.toFixed(2)}% | ETH: ${ethChange.toFixed(2)}% | BTC Vol: $${(btcVolume/1e9).toFixed(2)}B`);
                
                allGateETFs = tickers.filter(t => { 
                    const pair = t.currency_pair; 
                    return pair.endsWith('_USDT') && (pair.includes('3L') || pair.includes('3S') || pair.includes('5L') || pair.includes('5S')); 
                }).map(t => { 
                    const change = parseFloat(t.change_percentage); 
                    const volume = parseFloat(t.quote_volume); 
                    const price = parseFloat(t.last);
                    const high24h = parseFloat(t.high_24h);
                    const low24h = parseFloat(t.low_24h);
                    const leverage = t.currency_pair.match(/5[LS]/) ? 5 : 3; 
                    const isShort = t.currency_pair.includes('S');
                    const isLong = t.currency_pair.includes('L');
                    const baseCoin = t.currency_pair.replace('_USDT', '').replace(/[35][LS]/, '');
                    
                    // Determinar el cambio del activo principal
                    let mainCoinChange = 0;
                    if (baseCoin === 'BTC') mainCoinChange = btcChange;
                    else if (baseCoin === 'ETH') mainCoinChange = ethChange;
                    else mainCoinChange = btcChange * 0.8; // Aproximación para otros
                    
                    let score = 0; 
                    let zone = 'WARM';
                    let isGoldenOpportunity = false;
                    
                    // ===========================================
                    // SISTEMA AVANZADO DE DETECCIÓN DE OPORTUNIDADES
                    // ===========================================
                    
                    // 1. ANÁLISIS DE CORRELACIÓN CON ACTIVO PRINCIPAL
                    let correlationScore = 0;
                    if (isShort && mainCoinChange > 30) correlationScore = 40;
                    else if (isShort && mainCoinChange > 25) correlationScore = 35;
                    else if (isShort && mainCoinChange > 20) correlationScore = 25;
                    else if (isLong && mainCoinChange < -30) correlationScore = 40;
                    else if (isLong && mainCoinChange < -25) correlationScore = 35;
                    else if (isLong && mainCoinChange < -20) correlationScore = 25;
                    else if (isShort && mainCoinChange > 0) correlationScore = 5;
                    else if (isLong && mainCoinChange < 0) correlationScore = 5;
                    
                    // 2. ANÁLISIS DE CAÍDA (Factor más importante)
                    let dropScore = 0;
                    if (change < -85) dropScore = 50;
                    else if (change < -80) dropScore = 45;
                    else if (change < -75) dropScore = 40;
                    else if (change < -70) dropScore = 35;
                    else if (change < -65) dropScore = 30;
                    else if (change < -60) dropScore = 25;
                    else if (change < -55) dropScore = 20;
                    else if (change < -50) dropScore = 15;
                    else dropScore = 10;
                    
                    // 3. ANÁLISIS DE VOLUMEN (Liquidez)
                    let volumeScore = 0;
                    if (volume > 20000000) volumeScore = 20;
                    else if (volume > 15000000) volumeScore = 18;
                    else if (volume > 10000000) volumeScore = 15;
                    else if (volume > 7000000) volumeScore = 12;
                    else if (volume > 5000000) volumeScore = 10;
                    else if (volume > 3000000) volumeScore = 8;
                    else if (volume > 1000000) volumeScore = 5;
                    else volumeScore = 2;
                    
                    // 4. ANÁLISIS DE VOLATILIDAD (24h range)
                    const volatilityRange = high24h > 0 ? ((high24h - low24h) / low24h) * 100 : 0;
                    let volatilityScore = 0;
                    if (volatilityRange > 100) volatilityScore = 15; // Altísima volatilidad
                    else if (volatilityRange > 80) volatilityScore = 12;
                    else if (volatilityRange > 60) volatilityScore = 10;
                    else if (volatilityRange > 40) volatilityScore = 8;
                    else if (volatilityRange > 20) volatilityScore = 5;
                    else volatilityScore = 2;
                    
                    // 5. BONUS POR APALANCAMIENTO
                    const leverageScore = leverage === 5 ? 10 : 5;
                    
                    // 6. ANÁLISIS DE MOMENTUM (RSI simulado basado en posición en el rango)
                    let rsiSimulated = 50;
                    if (high24h > low24h && high24h > 0) {
                        rsiSimulated = ((price - low24h) / (high24h - low24h)) * 100;
                    }
                    let momentumScore = 0;
                    if (rsiSimulated < 10) momentumScore = 10; // Extrema sobreventa
                    else if (rsiSimulated < 20) momentumScore = 8;
                    else if (rsiSimulated < 30) momentumScore = 5;
                    else if (rsiSimulated < 40) momentumScore = 3;
                    
                    // 7. BONUS POR CONTEXTO DE MERCADO
                    let marketContextScore = 0;
                    const btcIsExtreme = Math.abs(btcChange) > 15;
                    if (btcIsExtreme && btcVolume > 5e9) marketContextScore = 5; // Mercado muy activo
                    
                    // ===========================================
                    // CÁLCULO DE SCORE TOTAL
                    // ===========================================
                    score = dropScore + volumeScore + correlationScore + volatilityScore + 
                            leverageScore + momentumScore + marketContextScore;
                    
                    // ===========================================
                    // DETECCIÓN DE OPORTUNIDADES
                    // ===========================================
                    if (change < -75 && correlationScore >= 35) {
                        isGoldenOpportunity = true;
                        score = 100;
                        console.log(`🔥 OPORTUNIDAD: ${t.currency_pair} | Caída: ${change.toFixed(1)}% | ${baseCoin}: ${mainCoinChange > 0 ? '+' : ''}${mainCoinChange.toFixed(1)}% | Vol: $${(volume/1e6).toFixed(1)}M`);
                    }
                    
                    else if (change < -70 && correlationScore >= 40) {
                        isGoldenOpportunity = true;
                        score = 100;
                        console.log(`🔥 OPORTUNIDAD (alt): ${t.currency_pair} | Caída: ${change.toFixed(1)}% | Correlación perfecta`);
                    }
                    
                    // ===========================================
                    // CLASIFICACIÓN POR ZONAS
                    // ===========================================
                    if (isGoldenOpportunity) {
                        zone = 'GOLD';
                    } else if (score >= 80) {
                        zone = 'HOT';
                    } else if (score >= 60) {
                        zone = 'WARM';
                    } else {
                        zone = 'COOL'; // Nueva zona para oportunidades menores
                    }
                    
                    return { 
                        ...t, 
                        score: Math.min(score, 100), 
                        zone: zone,
                        isGolden: isGoldenOpportunity,
                        btcCorrelation: isShort ? mainCoinChange : -mainCoinChange,
                        mainCoin: baseCoin,
                        mainCoinChange: mainCoinChange,
                        volatilityRange: volatilityRange,
                        rsiSimulated: rsiSimulated,
                        // Factores de análisis para debugging
                        factors: {
                            drop: dropScore,
                            volume: volumeScore,
                            correlation: correlationScore,
                            volatility: volatilityScore,
                            leverage: leverageScore,
                            momentum: momentumScore,
                            context: marketContextScore
                        }
                    }; 
                }); 
                
                // FILTRAR SOLO CAÍDAS
                const allCaiders = allGateETFs.filter(t => { 
                    const change = parseFloat(t.change_percentage); 
                    return change < 0; // Todas las caídas
                }); 
                
                // ORDENAR POR MAYOR CAÍDA (más negativo primero)
                allCaiders.sort((a, b) => {
                    const changeA = parseFloat(a.change_percentage);
                    const changeB = parseFloat(b.change_percentage);
                    return changeA - changeB; // Menor valor (más negativo) primero
                });
                
                // TOMAR LOS 6 QUE MÁS HAN CAÍDO (últimas 6 oportunidades en 24h)
                topDroppers = allCaiders.slice(0, 6);
                // Cache BTC5L price for renderLevels default
                const _b5l = allGateETFs.find(t => t.currency_pair === 'BTC5L_USDT');
                if (_b5l && parseFloat(_b5l.last) > 0) {
                    localStorage.setItem('c5x_btc5l_cache', _b5l.last);
                    if (typeof currentPanel !== 'undefined' && currentPanel === 2 && slots[activeIdx] && !slots[activeIdx].name) renderLevels();
                }
                
                // LOGGING DETALLADO
                console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
                console.log(`📊 RADAR ACTUALIZADO - ${_fmtTime(new Date())}`);
                console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
                console.log(`Total oportunidades: ${topDroppers.length}`);
                console.log(`🔥 OPORTUNIDADES: ${topDroppers.filter(t => t.isGolden).length}`);
                console.log(`🟡 HOT: ${topDroppers.filter(t => t.zone === 'HOT' && !t.isGolden).length}`);
                console.log(`⚪ WARM: ${topDroppers.filter(t => t.zone === 'WARM').length}`);
                
                // Mostrar top 3 con detalles
                topDroppers.slice(0, 3).forEach((t, i) => {
                    const emoji = t.zone === 'GOLD' ? '🔥' : t.zone === 'HOT' ? '🟡' : '⚪';
                    console.log(`${emoji} #${i+1}: ${t.currency_pair} | Score: ${t.score} | ${parseFloat(t.change_percentage).toFixed(1)}% | $${(parseFloat(t.quote_volume)/1e6).toFixed(1)}M`);
                });
                console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
                
                radarQueue = [...topDroppers]; 
                dropperIdx = 0; 
                startRadarRotation(); 
                
                if(window.innerWidth > 768) filterETFs(""); 
            } catch(e) { 
                console.error("❌ Radar Error:", e); 
                elStatus.className = 'radar-status-dot offline'; 
                // Si hay datos previos en caché, seguir mostrando sin borrar
                if (topDroppers && topDroppers.length > 0) {
                    elStatus.className = 'radar-status-dot online';
                    console.warn("⚠️ Usando datos de radar en caché");
                } else {
                    elVal.innerHTML = '<div style="font-size:10px; color:var(--danger); cursor:pointer; padding:5px;" onclick="fetchAndCalcTopDroppers()">⚠️ SIN CONEXIÓN — TOCAR</div>';
                }
                // Reintentar automáticamente en 15s
                setTimeout(() => { if (!allGateETFs.length) fetchAndCalcTopDroppers().catch(()=>{}); }, 15000);
            } 
        }
        let currentRadarObj = null; let radarPressTimer = null; let radarLongPressTriggered = false; let radarTouchStartX = 0; let radarTouchStartY = 0; let isRadarSwipe = false;
        function quickInstallCurrentRadar() { 
            triggerHaptic(); 
            if(!currentRadarObj) return showToast("⚠️ Radar vacío"); 
            const list = (radarQueue.length > 0) ? radarQueue : topDroppers;
            const currentItem = list[dropperIdx];
            const isGolden = currentItem && (currentItem.zone === 'GOLD' || currentItem.isGolden);
            smartSelectETF(currentRadarObj.pair, currentRadarObj.price, isGolden); 
        }
        function startRadarRotation() { 
            if(radarIntervalId) clearTimeout(radarIntervalId);
            updateRadarUI();
            // El avance del radar lo maneja el masterClock cada 10s
        }
        
        function tickRadar() {
            const list = (radarQueue.length > 0) ? radarQueue : topDroppers;
            if(list.length === 0) return;
            dropperIdx = (dropperIdx + 1) % list.length;
            updateRadarUI();
        }
        
        function updateRadarUI() { 
            const list = (radarQueue.length > 0) ? radarQueue : topDroppers; 
            if(list.length === 0) return; 
            
            const elVal = document.getElementById('radarValue'); 
            const radarContainer = document.getElementById('radarTickerContainer'); 
            const item = list[dropperIdx]; 
            if(!item) return; 
            
            currentRadarObj = { 
                pair: item.currency_pair.replace('_USDT', ''), 
                price: parseFloat(item.last) 
            }; 
            
            // Aplicar animación según la zona
            radarContainer.classList.remove('gold-mode-active', 'flash-gold');
            if (item.zone === 'GOLD' || item.isGolden) { 
                radarContainer.classList.add('gold-mode-active'); 
                radarContainer.classList.add('flash-gold'); 
            } 
            
            // Fade out
            elVal.style.opacity = 0; 
            
            setTimeout(() => { 
                const pairName = item.currency_pair.replace('_USDT', ''); 
                const change = parseFloat(item.change_percentage).toFixed(2); 
                const price = parseFloat(item.last); 
                const displayPrice = price < 1 ? price.toFixed(4) : price.toFixed(2); 
                const volume = (parseFloat(item.quote_volume) / 1000000).toFixed(1); 
                
                // Determinar emoji y texto según la zona
                let zoneEmoji, zoneText, zoneClass;
                if (item.zone === 'GOLD' || item.isGolden) {
                    zoneEmoji = '🔥';
                    zoneText = 'OPORTUNIDAD';
                    zoneClass = 'gold';
                } else if (item.zone === 'HOT') {
                    zoneEmoji = '🟡';
                    zoneText = 'ZONA CALIENTE';
                    zoneClass = 'hot';
                } else {
                    zoneEmoji = '⚪';
                    zoneText = 'ZONA TEMPLADA';
                    zoneClass = 'warm';
                }
                
                const nameColor = getCoinColor(pairName); 
                
                
                let detailedInfo = '';
                if (item.isGolden && item.mainCoin) {
                    const direction = item.mainCoinChange > 0 ? '↑' : '↓';
                    detailedInfo = `<div style="font-size:13px; font-family:'JetBrains Mono', monospace; color:#FFD700; font-weight:700; margin-top:6px; display:flex; gap:12px; justify-content:center;">
                        <span>✨ ${item.mainCoin} ${direction}${Math.abs(item.mainCoinChange).toFixed(1)}%</span>
                        <span>Vol: $${volume}M</span>
                    </div>`;
                } else {
                    
                    detailedInfo = '';
                }
                
                elVal.innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:6px; align-items:center; position:relative; z-index:1;">
                        <div class="radar-zone-badge ${zoneClass}" style="font-family:'JetBrains Mono', monospace; letter-spacing:1px;">
                            ${zoneEmoji} ${zoneText} • ${item.score}
                        </div>
                        <div id="radarCoinName" style="color:${nameColor}; font-size:28px; line-height:1.1; font-weight:800; cursor:pointer; text-decoration:underline dotted; text-underline-offset:6px; margin: 4px 0;" onclick="quickInstallCurrentRadar(); event.stopPropagation();">
                            ${pairName}
                        </div>
                        <div style="display:flex; gap:15px; font-size:15px; color:var(--text-secondary); align-items:center; font-family:'JetBrains Mono', monospace;">
                            <span style="color:var(--short); font-weight:900; font-size:18px;">${change}%</span>
                            <span style="font-weight:700; font-size:16px;">$${displayPrice}</span>
                        </div>
                        ${detailedInfo}
                    </div>
                `; 
                
                // Fade in
                elVal.style.opacity = 1;
                
                // ── SINCRONIZAR CHART CON RADAR ──
                // Cuando el radar muestra un nuevo ETF, ambos charts lo reflejan
                if (pairName && pairName !== chartSymbol) {
                    chartSymbol = pairName;
                    loadChart(pairName);
                }
            }, 200); 
        }
        function updateSlotStatus(symbol, currentPrice) { try { let needsDashRefresh = false; slots.forEach((s, idx) => { if(s.name === symbol) { if (s.buys.length === 0 && s.price > 0) { smartPriceAdjustment(s, idx, currentPrice); } if(s.buys.length > 0) { // Verificar alerta de objetivo (para cualquier nivel comprado)
                let avg = calculateAvgPriceForSlotData(s, idx); if(avg > 0) { if(currentPrice > avg) { const tp1Target = avg * (1 + (botConfig.tp1Pct || 50) / 100); if(currentPrice >= tp1Target && !s.alerted) { triggerAlert(s.name); s.alerted = true; save(); } } else { s.alerted = false; } } if(s.buys.includes(0) && (slotModes[idx]||'manual') === 'auto') { checkAndSendNextAutoLevel(s, idx, currentPrice); } } // Actualizar dashboard de este slot con precio en tiempo real
            updateDashboardStatsForSlot(idx, currentPrice); needsDashRefresh = true; } if(idx === activeIdx && s.name === symbol && s.price > 0) { updateLevelStatesRealTime(s, currentPrice, idx); } }); } catch(e) { console.warn("Heatmap/Auto Error", e); } }
        function updateLevelStatesRealTime(slot, currentPrice, slotIdx) {
            const _idx = (slotIdx !== undefined) ? slotIdx : activeIdx;
            const limit = customMultipliers ? customMultipliers.length : 12; 
            let priceAtLevel = slot.price; 
            
            for (let i = 0; i < limit; i++) { 
                if (i > 0) { 
                    const step = getStepForLevel(slot.strat, i); 
                    priceAtLevel = priceAtLevel * (1 - (step / 100)); 
                } 
                
                const key = getOrderKey(_idx, i); 
                const cardEl = document.querySelector(`[data-level-index="${i}"]`); 
                if (!cardEl) continue; 
                
                // Si el precio actual llegó o pasó el nivel y no está en órdenes activas
                if (currentPrice <= priceAtLevel) {
                    // Marcar automáticamente como alcanzado si no tiene orden activa
                    if (!activeOrders[key]) {
                        // Solo para niveles 1-5, marcar automáticamente como comprado
                        if (i >= 0 && i <= 4) {
                            if (!slot.buys.includes(i)) {
                                slot.buys.push(i);
                                save();
                                showToast(`✅ N${i+1} Alcanzado: $${priceAtLevel.toFixed(6)}`, 2000, false, true);
                                // Notificación nativa nivel comprado automáticamente
                                sendNativeNotif(
                                    `📥 N${i+1} Ejecutado — ${slots[_idx] ? slots[_idx].name : ''}`,
                                    `Precio: $${priceAtLevel.toFixed(6)} alcanzado y marcado como comprado.`,
                                    { tag: 'c5x-level-' + i, requireInteraction: false }
                                );
                                
                                // Marcar visualmente como ejecutado
                                cardEl.classList.remove('is-sent', 'is-pending');
                                cardEl.classList.add('is-filled');
                                
                                let badge = cardEl.querySelector('.order-status-badge');
                                if (!badge) { 
                                    badge = document.createElement('div'); 
                                    badge.className = 'order-status-badge'; 
                                    cardEl.appendChild(badge); 
                                } 
                                badge.className = 'order-status-badge filled'; 
                                badge.textContent = 'ALCANZADO ✓';
                            }
                        } 
                        // Para niveles 6-12, solo marcar visualmente como "listo para comprar"
                        else {
                            cardEl.classList.remove('is-filled', 'is-pending');
                            cardEl.classList.add('is-sent');
                            
                            let badge = cardEl.querySelector('.order-status-badge');
                            if (!badge) { 
                                badge = document.createElement('div'); 
                                badge.className = 'order-status-badge'; 
                                cardEl.appendChild(badge); 
                            } 
                            badge.className = 'order-status-badge sent'; 
                            badge.textContent = 'DISPONIBLE';
                        }
                    } 
                    else if (activeOrders[key] && activeOrders[key].status === 'filled') { 
                        cardEl.classList.remove('is-sent', 'is-pending'); 
                        cardEl.classList.add('is-filled'); 
                        
                        let badge = cardEl.querySelector('.order-status-badge');
                        if (badge) {
                            badge.className = 'order-status-badge filled'; 
                            badge.textContent = 'EJECUTADA ✓';
                        }
                    } 
                    else if (activeOrders[key] && activeOrders[key].status === 'open') { 
                        cardEl.classList.remove('is-sent', 'is-filled'); 
                        cardEl.classList.add('is-pending'); 
                    } 
                }
                // Si el precio no ha llegado al nivel, limpiar estados
                else {
                    if (!activeOrders[key] && !slot.buys.includes(i)) {
                        cardEl.classList.remove('is-sent', 'is-pending', 'is-filled');
                        const badge = cardEl.querySelector('.order-status-badge');
                        if (badge) badge.remove();
                    }
                }
            } 
        }
        function calculateAvgPriceForSlot(s, slotIdx) {
            // slotIdx opcional — si no se pasa usa activeIdx (compatibilidad hacia atrás)
            const idx = (slotIdx !== undefined) ? slotIdx : activeIdx;
            if(!s.price) return 0;
            let totalSpent = 0, totalQty = 0, lastPrice = s.price;
            const limit = (customMultipliers && customMultipliers.length) ? customMultipliers.length : 12; 
            const params = getStrategyParams(s.strat || 'normal'); // FIX #3: usar estrategia real del slot
            
            for(let i=0; i<limit; i++){ 
                let pLevel; 
                let mUSD; 
                
                if(i===0) {
                    pLevel = s.price;
                } else { 
                    const step = getStepForLevel(s.strat || 'normal', i); // FIX #3: estrategia real
                    pLevel = lastPrice*(1-(step/100)); 
                } 
                
                const m = customMultipliers[i]||1; 
                mUSD = m*params.capital; 
                
                const key = getOrderKey(idx, i); 
                if(activeOrders[key] && activeOrders[key].status === 'filled') { 
                    totalSpent += activeOrders[key].price * activeOrders[key].amount; 
                    totalQty += activeOrders[key].amount; 
                } else if(s.buys && s.buys.includes(i) && !activeOrders[key]) { 
                    totalSpent += mUSD; 
                    totalQty += mUSD/pLevel; 
                }
                // Compras múltiples (niveles 7-10)
                if (i >= 4 && i <= 9 && s.multipleBuys && s.multipleBuys[i]) {
                    for (let buy of s.multipleBuys[i]) {
                        totalSpent += buy.usd;
                        totalQty += buy.qty;
                    }
                }
                lastPrice = pLevel; 
            } 
            return totalQty > 0 ? totalSpent/totalQty : 0; 
        }
        function triggerAlert(coin) {
            const audio = document.getElementById('alertSound');
            if (audio) audio.play().catch(() => {});
            if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 200]);
            showToast('🎯 OBJETIVO ALCANZADO: ' + coin, 4000, false, true);
            // Notificación nativa (funciona aunque la app esté en background)
            sendNativeNotif(
                '🎯 OBJETIVO ALCANZADO — ' + coin,
                '5X: Tu posición de ' + coin + ' ha alcanzado el precio objetivo. Revisa para vender.',
                { tag: 'c5x-objetivo-' + coin, requireInteraction: true, vibrate: [300, 100, 300, 100, 300] }
            );
        }
        // 3 temas: 0=T11Dark 1=T11Light 2=VolcanicLight
        let themeIdx = parseInt(localStorage.getItem('c5x_theme_idx') ?? '2'); if (isNaN(themeIdx)) themeIdx = 2;
        function applyTheme(idx) {
            themeIdx = ((idx % 3) + 3) % 3;
            document.body.classList.remove('light-mode', 'volcanic-light');
            if (themeIdx === 1) document.body.classList.add('light-mode');
            if (themeIdx === 2) document.body.classList.add('volcanic-light');
            isLight = (themeIdx === 1 || themeIdx === 2); // para charts claros
            localStorage.setItem('c5x_theme_idx', themeIdx);
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            updateThemeIcon();
            if(chartSymbol) loadChart(chartSymbol);
        }
        function toggleTheme() { applyTheme(themeIdx + 1); }
        
        // Función para ir al Monitor ETF
        function goToETFMonitor() {
            triggerHaptic();
            switchView('etf');
        }
        
        // Función para mostrar/ocultar el botón flotante ETF según la sección activa
        function updateETFFloatButtonVisibility() {
            const fab = document.getElementById('etfFloatBtn');
            if (!fab) return;
            if (currentSection === 'operate') {
                // Forzar TODOS los estilos via JS para Android WebView
                fab.style.setProperty('display',       'flex',    'important');
                fab.style.setProperty('position',      'fixed',   'important');
                fab.style.setProperty('bottom',        '84px',    'important');
                fab.style.setProperty('right',         '16px',    'important');
                fab.style.setProperty('top',           'auto',    'important');
                fab.style.setProperty('left',          'auto',    'important');
                fab.style.setProperty('z-index',       '9997',    'important');
                fab.style.setProperty('opacity',       '1',       'important');
                fab.style.setProperty('visibility',    'visible', 'important');
                fab.style.setProperty('pointer-events','auto',    'important');
            } else {
                fab.style.setProperty('display', 'none', 'important');
            }
        }
        
        // ================================================================================
        // FUNCIONES DEL BOT (IMPLEMENTADAS)
        // ================================================================================
        
        function toggleBot() {
            const checkbox = document.getElementById('botEnabled');
            botConfig.enabled = checkbox.checked;
            localStorage.setItem('c5x_bot_config', JSON.stringify(botConfig));
            
            const statusEl = document.getElementById('botStatus');
            const statusText = document.getElementById('botStatusText');
            
            if (botConfig.enabled) {
                statusEl.classList.remove('inactive');
                statusEl.classList.add('active');
                statusText.textContent = 'Bot activado';
                showToast('🤖 Bot activado', 2000);
            } else {
                statusEl.classList.remove('active');
                statusEl.classList.add('inactive');
                statusText.textContent = 'Bot desactivado';
                showToast('🤖 Bot desactivado', 2000);
            }
        }
        
        function saveBotConfig() {
            if (!isSuperAdmin) { showToast('⛔ Acceso denegado — modo admin requerido'); return; }
            const g = id => { const e = document.getElementById(id); return e ? e.value : null; };
            const n = (id, def) => parseFloat(g(id)) || def;
            const i = (id, def) => parseInt(g(id)) || def;
            const b = (id, def) => g(id) !== null ? g(id) === '1' : def;
            botConfig.crashDrop       = n('botCrashDrop',    8);
            botConfig.crashFast       = n('botCrashFast',    3);
            botConfig.crashWindow     = n('botCrashWindow',  3);
            botConfig.maxLevels       = i('botMaxLevels',   12);
            botConfig.restartDelay    = i('botRestartDelay',  0);
            botConfig.circuitBreaker  = 70;
            botConfig.velBoost        = b('botVelBoost',   true);
            botConfig.contextAware    = b('botContextAware',true);
            botConfig.crashEnabled    = false;
            botConfig.circuitEnabled  = false;
            botConfig.tp1Pct          = n('botTp1Pct',       50);
            botConfig.trailActivePct  = n('botTrailActivePct',100);
            botConfig.trailDropPct    = n('botTrailDropPct',   15);
            botConfig.rebuyDropPct    = n('botRebuyDropPct',   16);
            botConfig.rebalPause      = b('botRebalPause',  true);
            // Sync computed values for legacy callers
            botConfig.normalProfit    = Math.round(((1 + botConfig.tp1Pct/100) * (1 + botConfig.trailActivePct/100) - 1) * 100);
            botConfig.autoRoi         = botConfig.normalProfit;
            // Limpiar campos obsoletos
            delete botConfig.tp2BaseMulti;
            delete botConfig.tp2FallbackPct;
            localStorage.setItem('c5x_bot_config', JSON.stringify(botConfig));
            updateStratExitSummary();
            updateTrailVisual();
            showToast('✅ Bot configurado', 1500);
        }

        function loadBotConfigUI() {
            const sv = (id, val) => { const e = document.getElementById(id); if (e) e.value = val; };
            sv('botCrashDrop',      botConfig.crashDrop      || 8);
            sv('botCrashFast',      botConfig.crashFast      || 3);
            sv('botCrashWindow',    botConfig.crashWindow    || 3);
            sv('botMaxLevels',      botConfig.maxLevels      || 12);
            sv('botRestartDelay',   botConfig.restartDelay   || 0);
            sv('botVelBoost',       botConfig.velBoost !== false ? '1' : '0');
            sv('botContextAware',   botConfig.contextAware   !== false ? '1' : '0');
            sv('botTp1Pct',         botConfig.tp1Pct         || 50);
            sv('botTrailActivePct', botConfig.trailActivePct || 100);
            sv('botTrailDropPct',   botConfig.trailDropPct   || 15);
            sv('botRebuyDropPct',   botConfig.rebuyDropPct   || 16);
            sv('botRebalPause',     botConfig.rebalPause ? '1' : '0');
            // Sync live preview spans
            const _ps = (id, v) => { const e = document.getElementById(id); if (e) e.textContent = v; };
            _ps('settTp1Preview',   botConfig.tp1Pct         || 50);
            _ps('settTrailPreview', botConfig.trailActivePct || 100);
            _ps('settDropPreview',  botConfig.trailDropPct   || 15);
            updateTrailVisual();
            updateRebalStatus();
        }

        function switchBotTab(tab) {
            ['basic','smart','exit','log'].forEach(t => {
                document.getElementById('botTab-'+t)?.classList.toggle('active', t===tab);
                document.getElementById('botPanel-'+t)?.classList.toggle('active', t===tab);
            });
            if (tab === 'log') renderBotLog();
            if (tab === 'exit') updateTrailVisual();
            if (tab === 'smart') updateRebalStatus();
        }

        // Visual explicativo del trailing en el tab de salida
        function updateTrailVisual() {
            const el = document.getElementById('trailVisualText');
            if (!el) return;
            const tp1Pct    = botConfig.tp1Pct         || 50;
            const trailAct  = botConfig.trailActivePct || 100;
            const trailDrop = botConfig.trailDropPct   || 15;
            const rebuyPct  = botConfig.rebuyDropPct   || 16;
            const s   = slots[activeIdx];
            const avg = s ? calculateAvgPriceForSlotData(s, activeIdx) : 0;
            const fP  = p => p > 0 ? (p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : '$'+p.toFixed(2)) : '';
            const tp1px    = avg > 0 ? ' &nbsp;<b>→ '+fP(avg*(1+tp1Pct/100))+'</b>' : '';
            const tp1PxVal = avg > 0 ? avg*(1+tp1Pct/100) : 0;
            const trailpx  = tp1PxVal > 0 ? ' &nbsp;<b>→ '+fP(tp1PxVal*(1+trailAct/100))+'</b>' : '';
            const info     = avg > 0 ? `<br><span style="color:var(--text-tertiary)">Promedio actual: ${fP(avg)} · TP1 estimado: ${fP(tp1PxVal)} · TRAIL activa: ${fP(tp1PxVal*(1+trailAct/100))}</span>` : '';
            el.innerHTML =
                `🟢 <b>TP1</b>: avg +<b style="color:var(--long)">${tp1Pct}%</b> → precio = avg×${(1+tp1Pct/100).toFixed(2)}${tp1px} → vende <b>50%</b> MARKET<br>` +
                `📈 <b>TRAILING</b>: activa a <b style="color:var(--brand)">precio TP1 +${trailAct}%</b>${trailpx} · <b style="color:var(--brand)">sin tope al alza</b><br>` +
                `🔴 <b>STOP</b>: cae <b style="color:var(--short)">${trailDrop}%</b> desde el máximo → vende <b>50% restante</b> MARKET<br>` +
                `🔄 <b>REBUY</b>: si cae <b style="color:var(--warning)">−${rebuyPct}%</b> desde precio TP1 → 12 niveles nuevos · acumula 50% restante al promedio · <b style="color:var(--warning)">hasta 3 ciclos</b>${info}`;
        }

        // Estado ventana rebalanceo
        function updateRebalStatus() {
            const dot  = document.getElementById('botRebalDot');
            const txt  = document.getElementById('botRebalText');
            if (!dot || !txt) return;
            const near = isNearRebalanceWindow();
            dot.style.background = near ? 'var(--warning)' : 'var(--long)';
            const now  = new Date();
            const mUTC = now.getUTCHours() * 60 + now.getUTCMinutes();
            const remain = mUTC <= 35 ? 35 - mUTC : mUTC >= 24*60-35 ? (24*60 - mUTC) + 35 : 0;
            txt.textContent = near
                ? `⚠️ Ventana rebalanceo activa (${remain}min restantes) — bot pausado`
                : `✅ Ventana rebalanceo: OK · Próxima en ~${(24*60 - mUTC + 35) % (24*60)}min`;
        }

        // ── BOT LOG ──────────────────────────────────────────────────
        let botLog = JSON.parse(localStorage.getItem('c5x_bot_log') || '[]');

        function addBotLog(type, msg) {
            const entry = {
                type, msg,
                time: _fmtTime(new Date()),
                date: _fmtDate(new Date())
            };
            botLog = [entry, ...botLog].slice(0, 50);
            localStorage.setItem('c5x_bot_log', JSON.stringify(botLog));
        }

        function renderBotLog() {
            const el = document.getElementById('botLogEntries');
            if (!el) return;
            if (!botLog.length) {
                el.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">Sin actividad registrada</div>';
                return;
            }
            const typeColor = { buy:'var(--long)', sell:'var(--short)', trail:'var(--brand)', pause:'var(--warning)', circuit:'var(--short)', info:'var(--text-tertiary)' };
            el.innerHTML = botLog.map(e => `
                <div style="display:flex;gap:6px;align-items:flex-start;padding:5px 6px;background:var(--surface);border-radius:8px;border:1px solid var(--border);">
                    <span style="font-family:var(--font-num);font-size:9px;color:var(--text-tertiary);flex-shrink:0;margin-top:1px;">${e.time}</span>
                    <span style="font-family:var(--font-head);font-size:9px;color:${typeColor[e.type]||'var(--text-primary)'};">${e.msg}</span>
                </div>`).join('');
        }

        function clearBotLog() {
            botLog = [];
            localStorage.removeItem('c5x_bot_log');
            renderBotLog();
        }
        
        // ================================================================================
        // FUNCIONES DE PANELES LATERALES
        // ================================================================================
        
        
        // SISTEMA DE 3 PANELES DESLIZABLES
        let currentPanel = 0;
        let panelTouchStartX = 0;
        let panelTouchStartY = 0;
        
        function switchPanel(panelIndex) {
            if (panelIndex < 0 || panelIndex > 2) return;
            const prevPanel = currentPanel;
            currentPanel = panelIndex;
            const container = document.getElementById('panelsContainer');
            if (container) {
                container.classList.remove('is-dragging');
                // En PC (1024px+) no se necesita transform — paneles siempre visibles
                if (window.innerWidth < 1024) {
                    container.style.transform = `translateX(${-(panelIndex * 33.3333)}%)`;
                }
            }
            updateHeaderForPanel(panelIndex);
            updateETFFloatButtonVisibility();
            _updatePanelNavUI(panelIndex);
            if (panelIndex === 0) { setTimeout(() => loadChart(chartSymbol), 100); initGateDashboard(); }
            if (panelIndex === 2) { forceRenderLevels(activeIdx); }
            // Al volver al Panel 1 (dashboards) desde Panel 3, siempre reconstruir
            if (panelIndex === 1 && prevPanel === 2) {
                setTimeout(renderAllDashboards, 30);
            }
            triggerHaptic();
        }
        
        // Actualizar dots indicadores y flechas de panel
        function _updatePanelNavUI(idx) {
            const PANELS = 3;
            for (let i = 0; i < PANELS; i++) {
                const dot = document.getElementById('pnd' + i);
                if (dot) dot.classList.toggle('active', i === idx);
            }
            // Flechas tablet
            const arrowL = document.getElementById('panelArrowLeft');
            const arrowR = document.getElementById('panelArrowRight');
            if (arrowL) arrowL.classList.toggle('hidden', idx === 0);
            if (arrowR) arrowR.classList.toggle('hidden', idx === PANELS - 1);
            // Resaltado de panel activo en PC
            if (window.innerWidth >= 1024) {
                document.querySelectorAll('.panel').forEach((p, i) => p.classList.toggle('pc-active', i === idx));
            }
        }
        
        // Actualizar header (ticker vs USDT display)
        function updateHeaderForPanel(panelIndex) {
            const tickerContainer = document.getElementById('tickerContainer');
            const usdtContainer = document.getElementById('usdtContainer');
            // Siempre mostrar el ticker en todos los paneles
            if (tickerContainer) tickerContainer.style.display = '';
            if (usdtContainer) usdtContainer.style.display = 'none';
            // En panel 1 (Dashboards): sincronizar ticker con la moneda activa del slot
            if (panelIndex === 1) {
                const slot = (typeof slots !== 'undefined' && slots[activeIdx]) ? slots[activeIdx] : null;
                if (slot && slot.name) {
                    const sym = slot.name.replace(/_USDT$/i, '');
                    const symEl = document.getElementById('t-sym');
                    if (symEl) symEl.textContent = sym;
                    const dot = document.getElementById('t-dot');
                    if (dot) dot.style.background = slot.buys && slot.buys.length > 0 ? 'var(--long)' : 'var(--text-secondary)';
                }
            }
        }
        
        // Actualizar el valor de USDT disponible
        function updateUSDTDisplay() {
            const usdtElement = document.getElementById('usdtAvailable');
            if (usdtElement) {
                usdtElement.textContent = availableUSDT.toLocaleString('en-US', { 
                    minimumFractionDigits: 0, 
                    maximumFractionDigits: 0 
                });
            }
        }
        
        // Cancela TODOS los timers de pulsación larga activos (evita activación accidental al deslizar)
        function cancelAllLongPresses() {
            if (typeof coinPressTimer !== 'undefined' && coinPressTimer) { clearTimeout(coinPressTimer); coinPressTimer = null; }
            if (typeof basePricePressTimer !== 'undefined' && basePricePressTimer) { clearTimeout(basePricePressTimer); basePricePressTimer = null; }
            if (typeof clearSlotPressTimer !== 'undefined' && clearSlotPressTimer) { clearTimeout(clearSlotPressTimer); clearSlotPressTimer = null; }
            if (typeof sellPressTimer !== 'undefined' && sellPressTimer) { clearTimeout(sellPressTimer); sellPressTimer = null; }
            if (typeof tradingPressTimer !== 'undefined' && tradingPressTimer) { clearTimeout(tradingPressTimer); tradingPressTimer = null; }
            if (typeof strategyPressTimer !== 'undefined' && strategyPressTimer) { clearTimeout(strategyPressTimer); strategyPressTimer = null; }
            if (typeof levelPressTimer !== 'undefined' && levelPressTimer) { clearTimeout(levelPressTimer); levelPressTimer = null; }
            if (typeof tickerPressTimer !== 'undefined' && tickerPressTimer) { clearTimeout(tickerPressTimer); tickerPressTimer = null; }
            // Limpiar estados visuales de presión
            document.querySelectorAll('.pressing').forEach(el => el.classList.remove('pressing'));
            if (typeof longPressTriggered !== 'undefined') longPressTriggered = false;
            if (typeof levelLongPressTriggered !== 'undefined') levelLongPressTriggered = false;
            if (typeof clearSlotLongPressTriggered !== 'undefined') clearSlotLongPressTriggered = false;
            if (typeof isSellScrolling !== 'undefined') isSellScrolling = true;
            if (typeof isScrolling !== 'undefined') isScrolling = true;
        }
        
        function setupPanelSwipe() {
            const wrapper   = document.querySelector('.panels-wrapper');
            const container = document.getElementById('panelsContainer');
            if (!wrapper || !container) return;

            const PANELS   = 3;
            const SNAP     = 0.18;   // 18% de pantalla para hacer snap (menos = más sensible)
            const MIN_VEL  = 0.30;   // velocidad mínima para snap (px/ms)

            let _sx=0,_sy=0,_px=0,_pt=0,_vel=0,_dir=null,_live=false;

            function baseOffset(idx){ return -(idx*33.3333); }
            
            function applyDrag(tgt) {
                if (window.innerWidth >= 1024) return; // En PC los paneles son siempre visibles
                container.style.transform = `translateX(${tgt}%)`;
            }

            // ── TOUCH ──────────────────────────────────────────────────
            wrapper.addEventListener('touchstart',(e)=>{
                const t=e.touches[0];
                _sx=_px=t.clientX; _sy=t.clientY;
                _pt=e.timeStamp; _vel=0; _dir=null; _live=false;
                panelTouchStartX=_sx; panelTouchStartY=_sy;
            },{passive:true});

            wrapper.addEventListener('touchmove',(e)=>{
                if(_dir===false) return;
                const t=e.touches[0];
                const dx=t.clientX-_sx, dy=t.clientY-_sy;
                if(_dir===null&&(Math.abs(dx)>6||Math.abs(dy)>6)){
                    _dir=Math.abs(dx)>=Math.abs(dy)*1.1; // ligeramente más estricto para evitar conflicto vertical
                    if(_dir){ _live=true; container.classList.add('is-dragging'); cancelAllLongPresses(); }
                }
                if(!_dir) return;
                const dt=e.timeStamp-_pt;
                if(dt>0) _vel=(t.clientX-_px)/dt;
                _px=t.clientX; _pt=e.timeStamp;
                const W=window.innerWidth||375;
                const min=baseOffset(PANELS-1), max=0;
                let tgt=baseOffset(currentPanel)+(dx/(W*PANELS))*100;
                // Resistencia en bordes más suave
                if(tgt>max) tgt=max+(tgt-max)*0.30;
                if(tgt<min) tgt=min+(tgt-min)*0.30;
                applyDrag(tgt);
            },{passive:true});

            function snap(cx){
                if(!_live){ container.classList.remove('is-dragging'); return; }
                _live=false;
                container.classList.remove('is-dragging');
                const dx=cx-_sx, W=window.innerWidth||375;
                let dest=currentPanel;
                if(Math.abs(dx)>14&&(Math.abs(dx)/W>=SNAP||Math.abs(_vel)>MIN_VEL)){
                    if(dx<0&&currentPanel<PANELS-1) dest=currentPanel+1;
                    if(dx>0&&currentPanel>0)        dest=currentPanel-1;
                }
                // ── Panel 3 SOLO accesible por doble tap (no por swipe desde Panel 1)
                if (dest===2 && currentPanel===1) dest=1;
                closeUserMenu(); switchPanel(dest);
            }

            wrapper.addEventListener('touchend',   (e)=>snap(e.changedTouches[0].clientX),{passive:true});
            wrapper.addEventListener('touchcancel',()=>{ _live=false; container.classList.remove('is-dragging'); switchPanel(currentPanel); },{passive:true});

            // ── MOUSE DRAG (tablet/PC) ──────────────────────────────────
            let _mDown=false, _mSx=0, _mPx=0, _mPt=0, _mVel=0, _mLive=false;
            
            wrapper.addEventListener('mousedown',(e)=>{
                if(window.innerWidth >= 1024) return; // En PC no hay drag — paneles siempre visibles
                if(e.button !== 0) return;
                _mDown=true; _mSx=_mPx=e.clientX; _mPt=Date.now(); _mVel=0; _mLive=false;
            });
            window.addEventListener('mousemove',(e)=>{
                if(!_mDown) return;
                const dx=e.clientX-_mSx;
                if(!_mLive && Math.abs(dx)>6) { _mLive=true; container.classList.add('is-dragging'); cancelAllLongPresses(); }
                if(!_mLive) return;
                const dt=Date.now()-_mPt;
                if(dt>0) _mVel=(e.clientX-_mPx)/dt;
                _mPx=e.clientX; _mPt=Date.now();
                const W=window.innerWidth||1200;
                const min=baseOffset(PANELS-1), max=0;
                let tgt=baseOffset(currentPanel)+(dx/(W*PANELS))*100;
                if(tgt>max) tgt=max+(tgt-max)*0.30;
                if(tgt<min) tgt=min+(tgt-min)*0.30;
                applyDrag(tgt);
            });
            function msnap(cx) {
                if(!_mDown) return;
                _mDown=false;
                if(!_mLive) { container.classList.remove('is-dragging'); return; }
                _mLive=false;
                container.classList.remove('is-dragging');
                const dx=cx-_mSx, W=window.innerWidth||1200;
                let dest=currentPanel;
                if(Math.abs(dx)>14&&(Math.abs(dx)/W>=SNAP||Math.abs(_mVel)>MIN_VEL)){
                    if(dx<0&&currentPanel<PANELS-1) dest=currentPanel+1;
                    if(dx>0&&currentPanel>0)        dest=currentPanel-1;
                }
                // ── Panel 3 SOLO accesible por doble tap (no por swipe desde Panel 1)
                if (dest===2 && currentPanel===1) dest=1;
                closeUserMenu(); switchPanel(dest);
            }
            window.addEventListener('mouseup', (e)=>msnap(e.clientX));
            window.addEventListener('mouseleave',()=>{ if(_mDown){ _mDown=false; _mLive=false; container.classList.remove('is-dragging'); switchPanel(currentPanel); } });

            // ── TECLADO (PC) — ← → para cambiar panel ──────────────────
            document.addEventListener('keydown',(e)=>{
                if(currentSection !== 'operate') return;
                if(['INPUT','TEXTAREA','SELECT'].includes(document.activeElement?.tagName)) return;
                if(e.key === 'ArrowLeft' && currentPanel > 0)           { e.preventDefault(); switchPanel(currentPanel-1); }
                if(e.key === 'ArrowRight' && currentPanel < PANELS-1)  { e.preventDefault(); switchPanel(currentPanel+1); }
            });
            
            // ── RESIZE: recalcular en cambio de viewport ────────────────
            window.addEventListener('resize', ()=>{
                _mDown=false; _mLive=false; _live=false;
                container.classList.remove('is-dragging');
                if(window.innerWidth >= 1024) {
                    container.style.transform = ''; // Sin transform en PC
                    document.querySelectorAll('.panel').forEach((p,i)=>p.classList.toggle('pc-active', i===currentPanel));
                } else {
                    container.style.transform = `translateX(${baseOffset(currentPanel)}%)`;
                }
                _updatePanelNavUI(currentPanel);
            });
        }
        

        // Cloud sync local — sin servicios externos
        function getLocalConfig() { return null; }

        // ── Guardar config ingresada en el formulario de Ajustes ─────
        function saveApiConfig() { showToast('⚠️ Sync en la nube no disponible'); }

        // ── Borrar config ────────────────────────────────────────────
        function clearApiConfig() { showToast('⚠️ Sync en la nube no disponible'); }

        // ── CONTROL DEL MURO DE AUTENTICACIÓN ────────────────────────
        const AUTH_REQUIRED = true;
        function lockApp(reason) { showLoginWall(); }

        function showLoginWall() {
            const wall = document.getElementById('authWall');
            if (!wall) return;
            wall.classList.remove('hiding', 'hidden');
            wall.style.display = '';
        }

        // ── SISTEMA DE LOGIN CON USUARIO + CONTRASEÑA ────────────
        async function loginApp() {
            const user = document.getElementById('loginUser')?.value?.trim();
            const pass = document.getElementById('loginPass')?.value?.trim();
            const errEl = document.getElementById('loginError');
            const statusEl = document.getElementById('authWallStatus');
            if (!user || !pass) {
                if(errEl) { errEl.textContent='Completa usuario y contraseña'; errEl.style.display='block'; }
                return;
            }
            if(errEl) errEl.style.display='none';
            if(statusEl) { statusEl.style.display='block'; statusEl.textContent='Verificando...'; }

            try {
                // Obtener config Supabase
                const sbUrl = localStorage.getItem('c5x_sb_url');
                const sbKey = localStorage.getItem('c5x_sb_key');

                // Usar credenciales hardcodeadas si no hay en localStorage
                const finalUrl = sbUrl || SB_URL_DEFAULT;
                const finalKey = sbKey || SB_KEY_DEFAULT;

                // Verificar contra tabla whitelist en Supabase
                const resp = await fetch(
                    `${finalUrl}/rest/v1/whitelist?username=eq.${encodeURIComponent(user)}&select=*`,
                    { headers: { 'apikey': finalKey, 'Authorization': 'Bearer ' + finalKey } }
                );
                const rows = await resp.json();

                console.log('[Login] Supabase response:', JSON.stringify(rows));
                if (rows && rows.length > 0) {
                    const u = rows[0];
                    // Verificar contraseña (active puede ser true, null o undefined — solo bloquear si es false explícito)
                    const passOk = u.password === pass;
                    const activeOk = u.active !== false;
                    console.log('[Login] passOk:', passOk, 'activeOk:', activeOk, 'role:', u.role);
                    if (passOk && activeOk) {
                        const isAdmin = u.role === 'admin';
                        if (isAdmin) setAdminMode(true);
                        localStorage.setItem('c5x_my_name', u.name || user);
                        localStorage.setItem('c5x_my_user', user);
                        localStorage.setItem('c5x_session', isAdmin ? 'admin' : 'user');
                        // Inicializar Supabase con sus credenciales
                        if (!sb.active) { sb.url=finalUrl; sb.key=finalKey; sb.init(); }
                        _doUnlock();
                        if(statusEl) statusEl.style.display='none';
                        return;
                    }
                }

                // Fallback: admin con PIN local si no está en whitelist
                const adminHash = localStorage.getItem('c5x_pin_hash') || _DEFAULT_PIN_HASH;
                if (user.toLowerCase() === 'admin' && _hashPin(pass) === adminHash) {
                    setAdminMode(true);
                    localStorage.setItem('c5x_my_name', 'Admin');
                    localStorage.setItem('c5x_session', 'admin');
                    if (!sb.active) { sb.url=finalUrl; sb.key=finalKey; sb.init(); }
                    _doUnlock();
                    if(statusEl) statusEl.style.display='none';
                    return;
                }

                if(statusEl) statusEl.style.display='none';
                const errMsg = (rows && rows.length > 0) ? 'Contraseña incorrecta' : 'Usuario no encontrado en el sistema';
                if(errEl) { errEl.textContent=errMsg; errEl.style.display='block'; }

            } catch(e) {
                console.error('Login error:', e);
                if(statusEl) statusEl.style.display='none';
                if(errEl) { errEl.textContent='Error de conexión — intenta de nuevo'; errEl.style.display='block'; }
            }
        }

        function _doUnlock() {
            const wall = document.getElementById('authWall');
            if (!wall) return;
            wall.classList.add('hiding');
            setTimeout(async () => {
                wall.classList.add('hidden');
                // Inicializar Supabase siempre (usa hardcoded si no hay en localStorage)
                if (!sb.active) {
                    sb.url = localStorage.getItem('c5x_sb_url') || SB_URL_DEFAULT;
                    sb.key = localStorage.getItem('c5x_sb_key') || SB_KEY_DEFAULT;
                    const ok = await sb.init();
                    if (ok) syncUsersFromCloud();
                }
            }, 420);
        }

        function unlockApp() { _doUnlock(); }
        // ── FIX ADMIN-CLIENT-SIDE: rol NUNCA persiste en localStorage ──
        // Antes: localStorage.getItem('c5x_is_admin') === '1'
        // Ahora: variable de sesión pura — se resetea en cada carga de página.
        // Un atacante que escriba 'c5x_is_admin=1' en DevTools no obtiene nada
        // porque esa clave ya no se lee jamás. El acceso requiere el PIN.
        let isSuperAdmin = false; // siempre empieza en false; se activa sólo con PIN válido

        // ── INICIALIZAR AUTH ──────────────────────────────────────────
        function initAuth() { return false; } // reservado para futura autenticación

        // ════════════════════════════════════════════════════════════════
        //  🔒  LISTA BLANCA — Control de acceso por usuario
        // ════════════════════════════════════════════════════════════════

        async function checkWhitelist() { return true; }

        // Mostrar pantalla de acceso denegado
        function showAccessDenied(email) {
            // Mostrar modal de acceso denegado
            const existing = document.getElementById('accessDeniedModal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.id = 'accessDeniedModal';
            modal.style.cssText = `
                position:fixed; inset:0; z-index:9999;
                background:rgba(0,0,0,0.85); backdrop-filter:blur(8px);
                display:flex; align-items:center; justify-content:center; padding:20px;
            `;
            modal.innerHTML = `
                <div style="
                    background:var(--surface); border:1px solid rgba(239,68,68,0.4);
                    border-radius:20px; padding:28px 20px; max-width:320px; width:100%;
                    text-align:center;
                ">
                    <div style="font-size:48px; margin-bottom:12px;">🔒</div>
                    <div style="font-family:var(--font-head); font-size:16px; font-weight:900;
                        color:var(--short); letter-spacing:1px; margin-bottom:8px;">
                        ACCESO RESTRINGIDO
                    </div>
                    <div style="font-family:var(--font-head); font-size:11px;
                        color:var(--text-secondary); line-height:1.7; margin-bottom:16px;">
                        La cuenta <strong style="color:var(--text-primary)">${email}</strong>
                        no tiene acceso a 5X.<br><br>
                        Contacta al administrador para solicitar acceso.
                    </div>
                    <button onclick="document.getElementById('accessDeniedModal').remove()"
                        style="width:100%; padding:12px; border-radius:12px;
                        background:var(--brand); color:#fff; border:none;
                        font-family:var(--font-head); font-size:12px; font-weight:700;
                        cursor:pointer; letter-spacing:0.5px;">
                        ENTENDIDO
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // ── GESTIÓN DE LISTA BLANCA (solo Super Admin) ───────────────

        // ── Lista blanca guardada en subcol privada del admin ──────────
        // Ruta: users/{adminUID}/admin/whitelist  (solo el admin puede leer/escribir)
        // Whitelist en whitelist/approved — donde están los datos reales
        function getWLRef() { return null; }
        async function getWLData() { return []; }

        // Helper para limpiar inputs después de agregar
        function wlAddAndClear() { showToast("⚠️ Cloud no disponible"); }

        // Agregar usuario a la lista blanca
        async function addToWhitelist() { showToast("⚠️ Cloud no disponible"); }

        // Quitar usuario por índice
        async function removeFromWhitelistByIndex() { showToast("⚠️ Cloud no disponible"); }

        // Cargar y mostrar la lista blanca — usa /whitelist/approved
        async function renderWhitelist() {}

        // ════════════════════════════════════════════════════════════════
        //  BACKUP LOCAL — Guardar y restaurar datos localmente
        // ════════════════════════════════════════════════════════════════

        // Construir el objeto completo de datos del usuario
        function buildCloudPayload() { return {}; }

        // ── GUARDAR (reservado para futuro sync) ──────────────────────
        async function saveToCloud(manual=false) { if(manual) showToast("💾 Datos guardados localmente"); }

        // ── CARGAR (reservado para futuro sync) ───────────────────────
        async function loadFromCloud(manual=false) { if(manual) showToast("💾 Usando datos locales"); }

        // ── APLICAR DATOS DE LA NUBE AL ESTADO LOCAL ─────────────────
        function applyCloudData(cloud) {
            try {
                if (cloud.slots && Array.isArray(cloud.slots)) {
                    slots = cloud.slots;
                    localStorage.setItem('c5x_slots', JSON.stringify(slots));
                    localStorage.setItem('c5x_slots_real', JSON.stringify(slots));
                }
                if (cloud.history && Array.isArray(cloud.history)) {
                    history = cloud.history;
                    localStorage.setItem('c5x_history', JSON.stringify(history));
                }
                if (cloud.activeOrders) {
                    activeOrders = cloud.activeOrders;
                    localStorage.setItem('c5x_active_orders', JSON.stringify(activeOrders));
                }
                if (typeof cloud.activeIdx === 'number') {
                    activeIdx = cloud.activeIdx;
                    localStorage.setItem('c5x_last_slot', activeIdx);
                }
                if (cloud.strategyParams) {
                    strategyParams = cloud.strategyParams;
                    localStorage.setItem('c5x_strategy_params', JSON.stringify(strategyParams));
                }
                if (cloud.globalCapital) {
                    globalCapital = cloud.globalCapital;
                    localStorage.setItem('c5x_global_capital', globalCapital);
                }
                if (cloud.customMultipliers && cloud.customMultipliers.length) {
                    customMultipliers = cloud.customMultipliers;
                    localStorage.setItem('c5x_multipliers', JSON.stringify(customMultipliers));
                }
                if (cloud.tickerAssets && cloud.tickerAssets.length) {
                    tickerAssets = cloud.tickerAssets.filter(t => !t.match(/[35][LS]/));
                    localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets));
                }
                if (cloud.slotModes && Array.isArray(cloud.slotModes)) {
                    slotModes = cloud.slotModes;
                    localStorage.setItem('c5x_slot_modes', JSON.stringify(slotModes));
                } else if (cloud.tradingMode) {
                    // Compatibilidad con versión anterior
                    slotModes = ['manual','manual','manual','manual','manual','manual','manual','manual','manual','manual'];
                    localStorage.setItem('c5x_slot_modes', JSON.stringify(slotModes));
                }
                // Guardar timestamp del último sync aplicado
                localStorage.setItem('c5x_last_cloud_save', String(cloud.savedAt || Date.now()));
                // Refrescar UI — NO llamar calculate() para no sobreescribir precios
                updateDashUI();
                // Actualizar inputs del slot activo manualmente SIN pasar por calculate()
                const s = slots[activeIdx];
                const cIn = document.getElementById('coinInput');
                if (cIn && s) { cIn.value = s.name || ''; }
                const bIn = document.getElementById('baseInput');
                if (bIn && s && s.price > 0) { bIn.value = s.price; }
                renderAllDashboards();
                renderLevels();
                renderHistory();
                updateDashboardStats();
            } catch(e) {
                console.error('applyCloudData error:', e);
            }
        }

        // ── SINCRONIZAR API KEYS DE GATE.IO A LA NUBE (cifradas) ─────
        async function syncApiKeysSecureToCloud() { showToast("☁️ Cloud no disponible"); }

        // ── CARGAR API KEYS CIFRADAS DE LA NUBE ──────────────────────
        async function loadApiKeysFromCloud() {}

        // ── INICIALIZAR SECCIÓN CHAT ──────────────────────────────────
        function initChatSection() {}

        // ── LOGIN CHAT ────────────────────────────────────────────────
        function loginChat() {}

        // ── ESCUCHAR MENSAJES EN TIEMPO REAL ─────────────────────────
        function escucharMensajes() {}

        // ── CONSTRUIR BURBUJA ─────────────────────────────────────────
        function buildBubble() { return ""; }

        // ── ENVIAR MENSAJE ────────────────────────────────────────────
        async function enviarMensajeChat() {}

        // ── MARCAR MENSAJES COMO LEÍDOS ───────────────────────────────
        function marcarLeidos() {}

        // ── BADGE DE MENSAJES NO LEÍDOS ───────────────────────────────
        function escucharBadgeChat() {}

        function actualizarBadgeChat() {}

        // ── UI DE ESTADO DE CONEXIÓN ──────────────────────────────────
        function actualizarUIConexion() {}

        // ── AVISO CHAT ────────────────────────────────────────────────
        function mostrarAvisoChatNoConfig() {}

        // ── HELPERS ───────────────────────────────────────────────────
        function escapeHtml(t) {
            return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
                    .replace(/\n/g,'<br>');
        }

        // ── ACTUALIZAR ÍCONO DE TEMA ───────────────────────────────────
        function updateThemeIcon() {
            const hint  = document.getElementById('themeHint');
            const label = document.getElementById('themeLabel');
            const icons  = ['🌑', '☀️', '🌋'];
            const labels = ['OSCURO', 'CLARO', 'VOLCANIC'];
            if (hint)  hint.textContent  = icons[themeIdx]  || '🌙';
            if (label) label.textContent = labels[themeIdx] || 'TEMA';
        }
        function toggleUserMenu() {
            const dd = document.getElementById('userDropdown');
            if (dd) dd.classList.toggle('open');
        }
        function closeUserMenu() {
            const dd = document.getElementById('userDropdown');
            if (dd) dd.classList.remove('open');
        }
        document.addEventListener('click', function(e) {
            const wrapper = document.getElementById('userMenuWrapper');
            if (wrapper && !wrapper.contains(e.target)) closeUserMenu();
        });

        // ─── CUENTA ────────────────────────────────────────────────────
        function handleAccount() { closeUserMenu(); switchView('settings'); }
        function updateAccountUI() {}

        // ── SISTEMA DE ROLES — isSuperAdmin declarado arriba ──

        function logoutApp() {
            localStorage.removeItem('c5x_session');
            localStorage.removeItem('c5x_my_name');
            localStorage.removeItem('c5x_my_pin');
            setAdminMode(false);
            showLoginWall();
            showToast('👋 Sesión cerrada');
        }

        function applyRoleVisibility() {
            const adminEls     = document.querySelectorAll('.admin-only');
            const adminGrids   = document.querySelectorAll('.admin-only-grid');
            const adminWrap    = document.querySelectorAll('.admin-section-wrapper');
            const adminBotTabs = document.querySelectorAll('.admin-bot-tab');
            const pinCard    = document.getElementById('adminPinCard');
            const activeCard = document.getElementById('adminActiveCard');
            if (isSuperAdmin) {
                adminEls.forEach(el   => el.style.display = 'block');
                adminGrids.forEach(el => el.style.display = 'grid');
                adminWrap.forEach(el  => el.style.display = 'contents');
                adminBotTabs.forEach(el => el.style.display = '');
                if (pinCard)    pinCard.style.display    = 'none';
                if (activeCard) activeCard.style.display = 'flex';
            } else {
                adminEls.forEach(el   => el.style.display = 'none');
                adminGrids.forEach(el => el.style.display = 'none');
                adminWrap.forEach(el  => el.style.display = 'none');
                adminBotTabs.forEach(el => el.style.display = 'none');
                if (pinCard)    pinCard.style.display    = 'flex';
                if (activeCard) activeCard.style.display = 'none';
            }
        }

        function setAdminMode(on) {
            isSuperAdmin = on;
            // ── FIX: NUNCA guardar el estado admin en localStorage ──
            // Antes: localStorage.setItem('c5x_is_admin', on ? '1' : '0');
            // Eliminar cualquier clave residual de versiones anteriores
            localStorage.removeItem('c5x_is_admin');
            applyRoleVisibility();
            showToast(on ? '👑 Modo Admin activado' : '👤 Modo Usuario activado');
        }

        // ── Actualizar sección CUENTA en Ajustes ─────────────────────
        function updateCloudUI() {}

        // ── Actualizar estadísticas de sync ───────────────────────────
        function updateCloudStats() {}

        // ── Cambiar estado del pill de sync ──────────────────────────
        function setCloudSyncPill() {}

        // ── Copiar UID ──────────────────────────────────────────────────
        function copyAdminUID() { showToast('Sin sesión activa'); }

        // ── Hacerse Super Admin con un toque ─────────────────────────
        async function setMeAsAdmin() { showToast('⚠️ Cloud no disponible'); }

        // ── Quitar rol Admin ─────────────────────────────────────────
        function confirmRemoveAdmin() { showToast('⚠️ Sin cloud'); }
        function removeAdminRole() { isSuperAdmin=false; applyRoleVisibility(); showToast("Rol admin eliminado"); }

        function triggerHaptic() { if (navigator.vibrate) navigator.vibrate(10); }
        function forceCaps(el) { const start = el.selectionStart; const end = el.selectionEnd; el.value = el.value.toUpperCase(); el.setSelectionRange(start, end); }
        function handleEnter(e) { if(e.key === 'Enter') verifyAndAddCoin(); }
        let _mbLiveInterval = null;
        function startMultiBuyLive() {
            if (_mbLiveInterval) clearInterval(_mbLiveInterval);
            _mbLiveInterval = setInterval(()=>{
                if (currentSection==='operate') updateMultiBuyLiveStrips();
            }, 2500);
        }
        function startTickerSystem() { 
            if(tickerIntervalId) clearInterval(tickerIntervalId);
            if(!tickerAssets || tickerAssets.length === 0) {
                tickerAssets = ["BTC", "ETH", "SUI", "AVAX", "BNB"];
                localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets));
            }
            // Filtrar tokens ETF del ticker
            tickerAssets = tickerAssets.filter(t => !t.match(/[35][LS]/));
            if(assetIdx < 0 || assetIdx >= tickerAssets.length) {
                assetIdx = 0;
                localStorage.setItem('c5x_ticker_index', assetIdx);
            }
            updateTicker();
            // El avance del ticker lo maneja el masterClock cada 10s
        }
        async function updateTicker() {
            if (!tickerAssets || tickerAssets.length === 0) return;
            let sym = tickerAssets[assetIdx];
            if (!sym) { assetIdx = 0; sym = tickerAssets[0]; }
            let apiSym = sym.includes('USDT') ? sym : sym + "USDT";
            let displaySym = sym.replace("USDT","");
            const el = document.getElementById('t-sym');
            if (el) el.textContent = displaySym;
            // Siempre cerrar WS anterior — nunca reutilizar (bug: ETH se congelaba si el WS seguía abierto)
            if (currentWs) {
                try {
                    currentWs.onmessage = null; currentWs.onerror = null;
                    currentWs.onclose = null; currentWs.close();
                } catch(e) {}
                currentWs = null;
            }
            // Obtener precio REST inmediatamente mientras el WS abre
            fetchTickerRest(apiSym, displaySym);
            // WSS Binance puerto 443 (evita bloqueos de red)
            try {
                const ws = new WebSocket(`wss://stream.binance.com:443/ws/${apiSym.toLowerCase()}@trade`);
                currentWs = ws;
                const wsTimeout = setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close(); if (currentWs === ws) currentWs = null;
                        fetchTickerRest(apiSym, displaySym);
                    }
                }, 5000);
                ws.onopen = () => clearTimeout(wsTimeout);
                ws.onmessage = (event) => {
                    try {
                        const d = JSON.parse(event.data); const price = parseFloat(d.p);
                        if (price > 0) { updateTickerUI(displaySym, price, true); updateSlotStatus(displaySym, price); const dot = document.getElementById('t-dot'); if(dot) dot.classList.add('pulse'); }
                    } catch(e) {}
                };
                ws.onerror = () => { clearTimeout(wsTimeout); if(currentWs===ws) currentWs=null; const dot=document.getElementById('t-dot'); if(dot) dot.classList.remove('pulse'); fetchTickerRest(apiSym, displaySym); };
                ws.onclose  = () => { if(currentWs===ws) currentWs=null; };
            } catch(e) { currentWs=null; fetchTickerRest(apiSym, displaySym); }
        }
        async function fetchTickerRest(apiSym, displaySym) {
            try {
                // Intentar Binance REST primero (más confiable sin CORS)
                const bnUrl = `https://api.binance.com/api/v3/ticker/24hr?symbol=${apiSym.toUpperCase()}`;
                const bnRes = await fetch(bnUrl, { signal: AbortSignal.timeout(6000) });
                if (bnRes.ok) {
                    const bnData = await bnRes.json();
                    const price = parseFloat(bnData.lastPrice);
                    const change = parseFloat(bnData.priceChangePercent);
                    if (price > 0) { updateTickerUI(displaySym, price, true, change); updateSlotStatus(displaySym, price); return; }
                }
            } catch(e) {}
            // Fallback: Gate.io REST
            try {
                const gateSym = displaySym + "_USDT";
                const data = await callGatePublic("/spot/tickers", {currency_pair: gateSym});
                let row = Array.isArray(data) ? data[0] : null;
                if (row) {
                    const price = parseFloat(row.last);
                    const change = parseFloat(row.change_percentage);
                    if (price > 0) { updateTickerUI(displaySym, price, true, change); updateSlotStatus(displaySym, price); }
                }
            } catch(e) {}
        }
        function updateTickerUI(sym, price, isUp, change = null) { if (isHeaderPinnedByScroll && sym !== slots[activeIdx].name) return; currentTickerSymbol = sym; let displayPrice = (price < 1) ? price.toFixed(8) : price.toLocaleString(); document.getElementById('t-price').textContent = displayPrice; document.getElementById('t-sym').textContent = sym; document.getElementById('t-dot').style.background = isUp ? 'var(--long)' : 'var(--short)'; const pctEl = document.getElementById('t-pct'); if(change !== null) { pctEl.textContent = (change >= 0 ? '+' : '') + change.toFixed(2) + '%'; pctEl.className = change >= 0 ? 'ticker-pct up' : 'ticker-pct down'; pctEl.style.display = 'inline-block'; } else { const found = allGateETFs.find(t => t.currency_pair === sym + "_USDT"); if(found) { const c = parseFloat(found.change_percentage); pctEl.textContent = (c >= 0 ? '+' : '') + c.toFixed(2) + '%'; pctEl.className = c >= 0 ? 'ticker-pct up' : 'ticker-pct down'; pctEl.style.display = 'inline-block'; } } }
        function toggleFullscreenChart(e) { if(e) e.stopPropagation(); const wrapper = document.getElementById('tv_chart'); wrapper.classList.toggle('fullscreen'); setTimeout(() => loadChart(chartSymbol), 100); }
        function toggleFullscreenChart2(e) { if(e) e.stopPropagation(); const wrapper = document.getElementById('tv_chart2'); wrapper.classList.toggle('fullscreen'); setTimeout(() => loadChart2(getChart2Symbol()), 100); }
        
        
        async function loadGateETFs() { const grid = document.getElementById('etfGrid'); const desktopList = document.getElementById('desktop-etf-list'); if(allGateETFs.length > 0) { filterETFs(""); return; } try { await fetchAndCalcTopDroppers(); filterETFs(""); } catch(e) { grid.innerHTML = '<div style="text-align:center; padding:20px; color:var(--danger)">Error al cargar datos.<br>Revisa tu conexión.</div>'; } }
        function toggleEtfFavorite(symbol, e) { e.stopPropagation(); if(etfFavorites.includes(symbol)) etfFavorites = etfFavorites.filter(s => s !== symbol); else etfFavorites.push(symbol); localStorage.setItem('c5x_etf_favorites', JSON.stringify(etfFavorites)); filterETFs(document.querySelector('.etf-search-input').value); }
        function filterETFs_base(query) { const grid = document.getElementById('etfGrid'); const desktopList = document.getElementById('desktop-etf-list'); const term = query.toUpperCase().trim(); 
            let sorted = [...allGateETFs];
            let filtered;
            if(term) {
                // Si hay búsqueda, mostrar resultados del filtro
                filtered = sorted.filter(t => t.currency_pair.includes(term)).slice(0, 10);
            } else {
                // Sin búsqueda: top 10 entre más caídos + más oportunidades
                // Ordenar por score descendente y cambio ascendente (más negativos primero)
                const byScore = [...sorted].sort((a, b) => (b.score||0) - (a.score||0));
                const byDrop  = [...sorted].sort((a, b) => parseFloat(a.change_percentage) - parseFloat(b.change_percentage));
                // Mezclar: 5 mayores caídas + 5 mayores oportunidades (score), sin duplicados
                const topDrops = byDrop.slice(0, 5);
                const topOpps  = byScore.filter(t => !topDrops.includes(t)).slice(0, 5);
                const combined = [...topDrops, ...topOpps];
                // Re-ordenar combinado: primero por score DESC para que las oportunidades sean primeras cuando hay empate
                filtered = combined.sort((a, b) => {
                    const aFav = etfFavorites.includes(a.currency_pair.replace('_', ''));
                    const bFav = etfFavorites.includes(b.currency_pair.replace('_', ''));
                    if(aFav && !bFav) return -1; if(!aFav && bFav) return 1;
                    return parseFloat(a.change_percentage) - parseFloat(b.change_percentage);
                });
            }
            let htmlContent = '';
            if(filtered.length === 0) { htmlContent = '<div style="text-align:center; padding:20px; color:var(--text-tertiary)">Sin resultados</div>'; }
            else { filtered.forEach((t, index) => { const price = parseFloat(t.last); const change = parseFloat(t.change_percentage); const displayPrice = (price < 1) ? price.toFixed(6) : price.toFixed(4); const pairName = t.currency_pair.replace('_USDT', '').replace('USDT', ''); const nameColor = getCoinColor(pairName); const volume = parseFloat(t.quote_volume) || 0; const volumeFormatted = volume >= 1000000 ? (volume / 1000000).toFixed(2) + 'M' : volume >= 1000 ? (volume / 1000).toFixed(2) + 'K' : volume.toFixed(0); const score = t.score || 0; const zone = t.zone || 'WARM'; const zoneColor = zone === 'GOLD' ? 'var(--zone-gold)' : zone === 'HOT' ? 'var(--zone-hot)' : 'var(--zone-warm)'; const flashClass = zone === 'GOLD' ? 'flash-gold-card' : ''; htmlContent += `<div class="unified-card ${flashClass}" onclick="smartSelectETF('${pairName}', ${price})"><div class="u-index">${index+1}</div><div class="u-center"><div class="u-title" style="font-size:22px; color:${nameColor}; font-weight:900;">${pairName}</div><div style="font-family:'JetBrains Mono'; font-size:15px; color:var(--text-primary); font-weight:700;">$${displayPrice}</div><div style="font-size:11px; color:var(--text-tertiary); font-weight:600; margin-top:4px;">VOL: $${volumeFormatted}</div></div><div class="u-right"><div class="etf-change-badge ${change >= 0 ? 'etf-up' : 'etf-down'}">${change >= 0 ? '+' : ''}${change.toFixed(2)}%</div><div class="etf-score-display" style="margin-top:6px;"><span style="font-size:10px; color:var(--text-tertiary); font-family:var(--font-head); letter-spacing:1px;">SCORE</span><span style="color:${zoneColor}; font-size:24px;">${score}</span></div></div></div>`; }); }
            if(grid) grid.innerHTML = htmlContent; if(desktopList) desktopList.innerHTML = htmlContent; }
        function smartSelectETF(symbol, price, isGoldenFromRadar = false) { 
            triggerHaptic(); 
            let cleanName = symbol.replace('_USDT','').replace('USDT',''); 

            // Si ya existe en algún slot, activarlo y navegar al panel
            const dupSlot = slots.findIndex(s => s.name === cleanName); 
            if (dupSlot !== -1) { 
                switchView('operate', false);
                goToSlotLevels(dupSlot);   // activa slot + Panel 3 + niveles
                return showToast("⚡ " + cleanName + " → SLOT " + (dupSlot + 1)); 
            } 

            // Siempre agregar en el PRIMER slot vacío (orden 1→5)
            let targetIdx = slots.findIndex(s => !s.name || s.name === ''); 
            if (targetIdx === -1) { 
                return showToast("⚠️ No hay slots disponibles (5/5 ocupados)"); 
            } 
            slots[targetIdx] = {
                name: cleanName,
                price: price,
                initialPrice: price,
                buys: [],
                locked: true,
                note: '',
                alerted: false,
                priceAdjusted: false,
                strat: 'normal',
                capital: strategyParams.normal.capital || 5,
                multipleBuys: {},
                rebuyCount: 0, rebuyOldSpent: 0, rebuyOldQty: 0
            };
            
            save(); 
            updateBodyMode(cleanName);
            renderAllDashboards();
            switchView('operate', false);
            goToSlotLevels(targetIdx);   // activa slot + Panel 3 + niveles
            showToast(`✅ ${cleanName} → SLOT ${targetIdx + 1}`);
        }
        // Variables para el modal de confirmación
        let confirmCallback = null;
        let pendingLevelData = null;
        
        function showConfirmModal(title, message, callback, opts) {
            // opts: { amount, price, isMarket } — también acepta window._modalOpts
            opts = opts || window._modalOpts;
            window._modalOpts = null;
            const modal    = document.getElementById('customConfirmModal');
            const elTitle  = document.getElementById('confirmTitle');
            const elAmount = document.getElementById('confirmAmount');
            const elPrice  = document.getElementById('confirmPrice');
            const elBadge  = document.getElementById('confirmBadge');
            if (!elTitle) { confirmCallback = callback; modal.classList.add('show'); return; }

            if (opts && opts.amount !== undefined) {
                // Nuevo formato estructurado
                elTitle.textContent  = title;
                elAmount.textContent = `$${opts.amount.toFixed(2)} USDT`;
                elPrice.textContent  = `@ $${opts.price < 1 ? opts.price.toFixed(6) : opts.price.toFixed(4)}`;
                if (opts.isMarket && opts.customSub) {
                    // Compra acumulada
                    elBadge.textContent = '⚡ MERCADO ACUMULADO';
                    elBadge.style.background = 'rgba(251,191,36,0.18)';
                    elBadge.style.color = 'var(--warning)';
                    elBadge.style.fontSize = '9px';
                    // Subtítulo extra si existe
                    let subEl = document.getElementById('confirmSubBadge');
                    if (!subEl) {
                        subEl = document.createElement('div');
                        subEl.id = 'confirmSubBadge';
                        subEl.style.cssText = 'font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);margin-top:4px;letter-spacing:.5px;';
                        elBadge.parentNode.insertBefore(subEl, elBadge.nextSibling);
                    }
                    subEl.textContent = opts.customSub;
                    subEl.style.display = '';
                } else if (opts.isMarket) {
                    elBadge.textContent = '⚡ MERCADO';
                    elBadge.style.background = 'rgba(251,191,36,0.15)';
                    elBadge.style.color = 'var(--warning)';
                    elBadge.style.fontSize = '';
                    const subEl = document.getElementById('confirmSubBadge');
                    if (subEl) subEl.style.display = 'none';
                } else {
                    elBadge.textContent = '📍 LÍMITE';
                    elBadge.style.background = 'rgba(52,211,153,0.12)';
                    elBadge.style.color = 'var(--long)';
                    elBadge.style.fontSize = '';
                    const subEl = document.getElementById('confirmSubBadge');
                    if (subEl) subEl.style.display = 'none';
                }
                elAmount.style.display = '';
                elPrice.style.display  = '';
                elBadge.style.display  = '';
            } else {
                // Formato legacy: usa message como texto
                elTitle.textContent  = title;
                elAmount.textContent = message;
                elPrice.textContent  = '';
                elBadge.style.display = 'none';
                elAmount.style.display = '';
                elPrice.style.display  = 'none';
            }
            confirmCallback = callback;
            modal.classList.add('show');
        }
        
        function closeConfirmModal(accepted) {
            const modal = document.getElementById('customConfirmModal');
            modal.classList.remove('show');
            if (confirmCallback) {
                confirmCallback(accepted);
                confirmCallback = null;
            }
        }
        
        function getMaxBuysForLevel(levelIndex) {
            // 1 compra normal (bot/usuario) + adicionales manuales del usuario
            if (levelIndex === 4 || levelIndex === 5) return 4; // N5-N6: 1 normal + 3 x $10
            if (levelIndex === 6 || levelIndex === 7) return 3; // N7-N8: 1 normal + 2 x $25
            if (levelIndex === 8 || levelIndex === 9) return 2; // N9-N10: 1 normal + 1 x $40
            return 1; // N1-N4, N11-N12: solo 1 compra
        }
        function getFixedAdditionalAmount(levelIndex) {
            // Monto fijo USDT para cada compra adicional de promedio (usuario manual)
            if (levelIndex === 4 || levelIndex === 5) return 10;
            if (levelIndex === 6 || levelIndex === 7) return 25;
            if (levelIndex === 8 || levelIndex === 9) return 40;
            return 0;
        }

        function handleLevelClick(levelIndex) {
            const isAutoMode = (slotModes[activeIdx] || 'manual') === 'auto';
            const canBuyMultiple = (levelIndex >= 4 && levelIndex <= 9); // N5-N10 multi-buy nativo
            const s = slots[activeIdx];
            if (!s.multipleBuys) s.multipleBuys = {};
            if (!s.multipleBuys[levelIndex]) s.multipleBuys[levelIndex] = [];
            const currentBuys = s.multipleBuys[levelIndex].length;

            // En AUTO: el bot maneja la 1ª compra de TODOS los niveles automáticamente.
            // El usuario PUEDE hacer compras manuales adicionales en CUALQUIER nivel
            // para promediar cuando el precio esté ahí.
            const levelKey   = getOrderKey(activeIdx, levelIndex);
            const isFilledByBot = (activeOrders[levelKey] && activeOrders[levelKey].status === 'filled') ||
                                  (s.buys && s.buys.includes(levelIndex) && !activeOrders[levelKey]);
            const isAdditionalBuy = canBuyMultiple
                ? (currentBuys >= 1)           // N5-N10: adicional si ya hay ≥1 compra
                : isFilledByBot;                // N1-N4, N11-N12: adicional si el bot ya compró

            if (isAutoMode && !isFilledByBot && !canBuyMultiple) {
                // Nivel no comprado aún por el bot y no es multi-buy nativo → adelantar compra manual
                // Se permite: el usuario puede promediar anticipadamente en cualquier nivel
            }
            if (!s.name || !s.price) return;
            triggerHaptic();

            // ══ COMPRA ACUMULADA: precio base > precio real ══════════════
            const triggered = detectTriggeredLevels(s, activeIdx);
            if (triggered && triggered.levels.length > 0) {
                const isTriggedLevel = triggered.levels.some(l => l.idx === levelIndex);
                const isDeepest = levelIndex === triggered.deepestLevel;
                if (isTriggedLevel || isDeepest) {
                    showAccumulatedBuyModal(s, activeIdx, triggered);
                    return;
                }
            }
            // ════════════════════════════════════════════════════════════

            // Verificar órdenes activas SOLO para niveles simples (sin adicionales)
            if (!canBuyMultiple) {
                const key = getOrderKey(activeIdx, levelIndex); 
                if (activeOrders[key]) { 
                    const order = activeOrders[key]; 
                    if (order.status === 'filled') return showToast(`✅ Nivel ${levelIndex + 1} ya EJECUTADO`); 
                    if (order.status === 'open') return showToast(`⏳ Nivel ${levelIndex + 1} tiene orden PENDIENTE`); 
                } 
                
                // Verificar si ya fue comprado (niveles 1-6)
                if (s.buys && s.buys.includes(levelIndex)) { 
                    return showToast(`✅ Nivel ${levelIndex + 1} ya comprado`); 
                }
            }
            
            // Para niveles múltiples (7-12), verificar máximo de compras
            if (canBuyMultiple && currentBuys >= getMaxBuysForLevel(levelIndex)) { 
                return showToast(`⚠️ Máximo ${getMaxBuysForLevel(levelIndex)} compras en nivel ${levelIndex + 1}`); 
            } 
            
            const data = getLevelData(s, levelIndex);
            // Obtener precio live para compras manuales en AUTO o multi-buy
            const liveTkr2 = (isAutoMode || canBuyMultiple) ? (allGateETFs && allGateETFs.find(t => t.currency_pair === s.name + '_USDT')) : null;
            const livePrice2 = liveTkr2 ? parseFloat(liveTkr2.last) : 0;
            let capUsd, buyPrice, isMarketBuy = false;
            if (isAdditionalBuy) {
                // Compra adicional de promedio: monto fijo en N5-N10, monto de nivel en otros
                capUsd = canBuyMultiple ? getFixedAdditionalAmount(levelIndex) : (() => {
                    const p2 = getStrategyParams(s.strat);
                    const m2 = customMultipliers ? (customMultipliers[levelIndex] || 1) : 1;
                    return p2.capital * m2;
                })();
                buyPrice = livePrice2 > 0 ? livePrice2 : data.price;
                isMarketBuy = true;
            } else if (isAutoMode) {
                // AUTO + 1ª compra manual en nivel no ejecutado aún: precio de nivel o mercado
                const params2 = getStrategyParams(s.strat);
                const mult2 = customMultipliers ? (customMultipliers[levelIndex] || 1) : 1;
                capUsd = params2.capital * mult2;
                buyPrice = (livePrice2 > 0 && livePrice2 < data.price * 1.002) ? livePrice2 : data.price;
                isMarketBuy = livePrice2 > 0 && livePrice2 < data.price * 0.9995;
            } else {
                // Manual normal: monto de estrategia, precio del nivel (o mercado si ya cayó)
                const params2 = getStrategyParams(s.strat);
                const mult2 = customMultipliers ? (customMultipliers[levelIndex] || 1) : 1;
                capUsd = params2.capital * mult2;
                buyPrice = data.price;
                if (canBuyMultiple && livePrice2 > 0 && livePrice2 < data.price * 0.9995) {
                    buyPrice = livePrice2; isMarketBuy = true;
                }
            }
            const buyQty = capUsd / buyPrice;
            const buyNumber = canBuyMultiple ? currentBuys + 1 : 1;
            const additionalLeft = getMaxBuysForLevel(levelIndex) - 1;
            const title = isAdditionalBuy
                ? `🤝 PROMEDIAR N${levelIndex+1}  #${currentBuys}/${additionalLeft}`
                : isAutoMode
                    ? `⚡ MANUAL N${levelIndex+1} (AUTO activo)`
                    : (additionalLeft > 0 ? `NIVEL ${levelIndex+1} (+${additionalLeft} prom)` : `NIVEL ${levelIndex + 1}`);
            window._modalOpts = { amount: capUsd, price: buyPrice, isMarket: isMarketBuy };
            showConfirmModal(title, `$${capUsd.toFixed(2)} USDT`, (accepted) => {
                if (accepted) {
                    if (canBuyMultiple) {
                        s.multipleBuys[levelIndex].push({ price: buyPrice, qty: buyQty, usd: capUsd, isMarket: isMarketBuy, timestamp: Date.now() });
                    } else {
                        if (!s.buys.includes(levelIndex)) s.buys.push(levelIndex);
                    } 
                    
                    // GUARDADO INMEDIATO Y AGRESIVO - MÚLTIPLES CAPAS
                    console.log(`💾 Iniciando guardado de slot ${activeIdx + 1}...`);
                    save();
                    saveActiveOrders();
                    saveSlotsLevels();
                    localStorage.setItem('c5x_slots', JSON.stringify(slots));
                    localStorage.setItem('c5x_slots_real', JSON.stringify(slots));
                    console.log(`✅ Guardado completado para slot ${activeIdx + 1}`);
                    
                    // Forzar actualización visual COMPLETA
                    renderLevels(); 
                    // Actualizar TODOS los dashboards (slot activo + restantes + dashboard general)
                    for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
                    refreshAllDashboardData();
                    
                    // Enviar orden si modo real — pasar datos reales de la compra (precio mercado si aplica)
                    sendManualOrder(levelIndex, { ...data, price: buyPrice, qty: buyQty, isMarket: isMarketBuy }); 
                    
                    // Toast de confirmación
                    if (canBuyMultiple) {
                        showToast(`✅ Nivel ${levelIndex + 1} compra #${buyNumber} guardada`);
                    } else {
                        showToast(`✅ Nivel ${levelIndex + 1} comprado`);
                    }
                    
                    // Segundo refresco tras 800ms (por si monitorOrder actualiza estado)
                    setTimeout(() => {
                        save();
                        for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
                        refreshAllDashboardData();
                    }, 800);
                }
            });
        }
        async function sendManualOrder(levelIndex, data) {
            const isMarket = !!(data && data.isMarket);
            const slot = slots[activeIdx];
            const symbol = slot.name.toUpperCase();
            const price = data.price.toFixed(8);
            const amount = data.qty.toFixed(4);
            const key = getOrderKey(activeIdx, levelIndex);
            try {
                updateLevelStatus(levelIndex, 'pending', isMarket ? 'MARKET...' : 'ENVIANDO...');
                if (!apiConfig.key || !apiConfig.secret) {
                    activeOrders[key] = { orderId: 'SIM_'+Date.now(), status: 'filled', price: parseFloat(price), amount: parseFloat(amount), symbol, timestamp: Date.now(), simulated: true, isMarket, mode: 'manual' };
                    updateLevelStatus(levelIndex, 'filled', isMarket ? 'MARKET ✓ (SIM)' : 'EJECUTADA ✓ (SIM)');
                    saveActiveOrders(); renderLevels();
                    for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
                    refreshAllDashboardData();
                    showToast(`✅ N${levelIndex+1} ${isMarket?'MARKET ':''}(SIM)`);
                    return true;
                }
                const orderParams = isMarket
                    ? { currency_pair: symbol+'_USDT', side: 'buy', amount, type: 'market', time_in_force: 'ioc' }
                    : { currency_pair: symbol+'_USDT', side: 'buy', amount, price, type: 'limit', time_in_force: 'gtc' }; const response = await callGateApi("POST", "/spot/orders", orderParams, true); if (response && response.id) { activeOrders[key] = { orderId: response.id, status: 'open', price: parseFloat(price), amount: parseFloat(amount), symbol: symbol, timestamp: Date.now(), simulated: false, mode: 'manual' }; updateLevelStatus(levelIndex, 'pending', 'PENDIENTE'); saveActiveOrders(); monitorOrder(levelIndex, response.id, activeIdx); return true; } else { throw new Error("Respuesta inválida de Gate.io"); } } catch (error) { updateLevelStatus(levelIndex, 'error', 'ERROR'); showToast(`❌ Error en N${levelIndex + 1}: ${error.message}`); return false; } }
        const orderMonitors = {}; // FIX #5: Map para rastrear intervals activos de monitorOrder
        async function monitorOrder(levelIndex, orderId, capturedSlotIdx) {
            // capturedSlotIdx fija el slot en el momento de la llamada — evita bug si usuario cambia slot
            const slotIdx = (capturedSlotIdx !== undefined) ? capturedSlotIdx : activeIdx;
            const key = getOrderKey(slotIdx, levelIndex);
            // FIX #5: Cancelar monitor anterior si existía para esta key
            if (orderMonitors[key]) { clearInterval(orderMonitors[key]); delete orderMonitors[key]; }
            const checkInterval = setInterval(async () => {
                try {
                    const slot = slots[slotIdx];
                    if (!slot || !slot.name) { clearInterval(checkInterval); delete orderMonitors[key]; return; }
                    const symbol = slot.name.toUpperCase() + '_USDT';
                    // BUG FIX #11: currency_pair necesita sufijo _USDT para Gate.io
                    const _cpair = symbol.includes('_USDT') ? symbol : symbol + '_USDT';
                    const orderStatus = await callGateApi("GET", `/spot/orders/${orderId}`, { currency_pair: _cpair }, true);
                    if (!orderStatus) { clearInterval(checkInterval); delete orderMonitors[key]; return; }
                    if (orderStatus.status === 'closed' || orderStatus.status === 'filled') {
                        clearInterval(checkInterval); delete orderMonitors[key];
                        if (activeOrders[key]) {
                            activeOrders[key].status = 'filled';
                            activeOrders[key].filledTime = Date.now();
                        }
                        if (slotIdx === activeIdx) updateLevelStatus(levelIndex, 'filled', 'EJECUTADA ✓');
                        saveActiveOrders();
                        if (slotIdx === activeIdx) renderLevels();
                        for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
                        refreshAllDashboardData();
                        if ((slotModes[slotIdx] || 'manual') === 'auto') {
                            setTimeout(() => { sendNextAutoLevel(); }, 2000);
                        }
                    } else if (orderStatus.status === 'cancelled') {
                        clearInterval(checkInterval); delete orderMonitors[key];
                        delete activeOrders[key];
                        if (slotIdx === activeIdx) updateLevelStatus(levelIndex, 'error', 'CANCELADA');
                        showToast(`⚠️ Orden N${levelIndex + 1} cancelada`);
                        for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
                        refreshAllDashboardData();
                    }
                } catch (error) { clearInterval(checkInterval); delete orderMonitors[key]; }
            }, 5000);
            orderMonitors[key] = checkInterval; // FIX #5: registrar interval
        }
        function updateLevelStatus(levelIndex, status, badgeText) { const levelCard = document.querySelector(`[data-level-index="${levelIndex}"]`); if (!levelCard) return; levelCard.classList.remove('order-selected', 'order-pending', 'order-filled', 'order-error'); switch(status) { case 'pending': levelCard.classList.add('order-pending'); break; case 'filled': levelCard.classList.add('order-filled'); break; case 'error': levelCard.classList.add('order-error'); break; default: levelCard.classList.add('order-selected'); } let badge = levelCard.querySelector('.order-status-badge'); if (!badge) { badge = document.createElement('div'); badge.className = 'order-status-badge'; levelCard.appendChild(badge); } badge.className = `order-status-badge ${status}`; badge.textContent = badgeText; }
        async function sendAutoLevelOrder(levelIndex, customData) { const slot = slots[activeIdx]; if (!slot.name || !slot.price) return false; const data = customData || getLevelData(slot, levelIndex); const symbol = slot.name.toUpperCase(); const price = data.price.toFixed(8); const amount = data.qty.toFixed(4); const key = getOrderKey(activeIdx, levelIndex); try { if (!slot.buys.includes(levelIndex)) { slot.buys.push(levelIndex); save(); } renderLevels(); updateLevelStatus(levelIndex, 'pending', 'ENVIANDO...'); if (!apiConfig.key || !apiConfig.secret) { 
            // MODO SIMULACIÓN AUTO
            activeOrders[key] = { 
                orderId: 'SIM_AUTO_' + Date.now(), 
                status: 'filled', 
                price: parseFloat(price), 
                amount: parseFloat(amount), 
                symbol: symbol, 
                timestamp: Date.now(), 
                simulated: true, 
                mode: 'auto' 
            }; 
            updateLevelStatus(levelIndex, 'filled', 'EJECUTADA ✓ (SIM)'); 
            saveActiveOrders(); 
            updateDashboardStats(); 
            renderLevels(); 
            return true; 
        }
                const isMarketAuto = !!(data && data.isMarket);
                const orderParams = isMarketAuto
                    ? { currency_pair: symbol+'_USDT', side:'buy', amount, type:'market', time_in_force:'ioc' }
                    : { currency_pair: symbol+'_USDT', side:'buy', amount, price, type:'limit', time_in_force:'gtc' };
                const response = await callGateApi("POST", "/spot/orders", orderParams, true);
                if (response && response.id) {
                    activeOrders[key] = { orderId: response.id, status:'open', price:parseFloat(price), amount:parseFloat(amount), symbol, timestamp:Date.now(), simulated:false, mode:'auto', isMarket:isMarketAuto };
                    updateLevelStatus(levelIndex, 'pending', isMarketAuto?'MARKET⏳':'PENDIENTE');
                    saveActiveOrders(); monitorOrder(levelIndex, response.id, activeIdx);
                    return true;
                } else { throw new Error("Respuesta inválida de Gate.io"); }
            } catch (error) {
                // Sin toast — el bot cycle maneja el cooldown y el pill
                console.warn(`[AutoOrder] N${levelIndex+1}:`, error.message);
                addBotLog && addBotLog('error', `N${levelIndex+1}: ${(error.message||'').slice(0,60)}`);
                updateLevelStatus(levelIndex,'error','ERR');
                return false;
            }
        }
        let priceMonitorInterval = null;
        // sellMonitorInterval already declared at top
        let currentAutoLevel = 0; let trailingStopData = {};
        const autoBuyErrorCooldown = {};

        // Fix #7: estado de notificaciones manuales por nivel
        const _manualLvlNotified = {};

        function _checkManualLevelAlerts(slot, slotIdx, currentPrice) {
            if (!slot || !slot.name || slot.price <= 0) return;
            const limit = customMultipliers ? customMultipliers.length : 12;
            let calcPrice = slot.price;
            for (let lvl = 0; lvl < limit; lvl++) {
                if (lvl > 0) {
                    const step = getStepForLevel(slot.strat || 'normal', lvl);
                    calcPrice = calcPrice * (1 - step / 100);
                }
                const key = getOrderKey(slotIdx, lvl);
                const bought = (slot.buys && slot.buys.includes(lvl))
                    || (activeOrders[key] && (activeOrders[key].status === 'open' || activeOrders[key].status === 'filled'));
                if (bought) continue;
                const nk = slotIdx + '_' + lvl;
                const last = _manualLvlNotified[nk] || 0;
                if (currentPrice <= calcPrice && Date.now() - last > 10 * 60 * 1000) {
                    _manualLvlNotified[nk] = Date.now();
                    const fp = p => p < 1 ? p.toFixed(6) : p.toFixed(4);
                    sendNativeNotif(
                        `📍 ${slot.name} — N${lvl+1} DISPONIBLE`,
                        `N${lvl+1} alcanzado @${fp(currentPrice)} (nivel ${fp(calcPrice)}) · Modo manual`,
                        { tag: `c5x-m-${slotIdx}-${lvl}`, requireInteraction: true }
                    );
                    if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                    addBotLog('info', `S${slotIdx+1} [MANUAL] ${slot.name}: N${lvl+1} @${fp(currentPrice)}`);
                } else if (currentPrice > calcPrice * 1.015) {
                    delete _manualLvlNotified[nk];
                }
            }
        }

        // Fix #9: actualizar ROI live sin re-render del DOM
        function _updateManualSlotLiveROI(slot, slotIdx, currentPrice) {
            // BUG FIX: no actualizar si el slot ya fue cerrado/limpiado
            if (!slot || !slot.name || slot.price <= 0) return;
            const avgPrice = calculateAvgPriceForSlotData(slot, slotIdx);
            if (avgPrice <= 0) return;
            const roiEl = document.getElementById('dashLiveRoi-' + slotIdx);
            if (!roiEl) return;
            const roiPct = ((currentPrice - avgPrice) / avgPrice * 100);
            roiEl.textContent = (roiPct >= 0 ? '+' : '') + roiPct.toFixed(2) + '%';
            roiEl.style.color = roiPct >= 0 ? 'var(--long)' : 'var(--short)';
            // Calcular PNL en dólares
            let totalQty = 0;
            for (let i = 0; i < 12; i++) {
                const key = getOrderKey(slotIdx, i);
                if (activeOrders[key] && activeOrders[key].status === 'filled') totalQty += activeOrders[key].amount;
                else if (slot.buys && slot.buys.includes(i) && !activeOrders[key]) totalQty += getLevelData(slot, i).qty;
            }
            const dolEl = document.getElementById('dashLivePnlDol-' + slotIdx);
            if (dolEl && totalQty > 0) {
                const pnlDol = (currentPrice - avgPrice) * totalQty;
                dolEl.textContent = (pnlDol >= 0 ? '+' : '') + '$' + pnlDol.toFixed(2);
                dolEl.style.color = pnlDol >= 0 ? 'var(--long)' : 'var(--short)';
            }
            const cell = document.getElementById('dashPnlCell-' + slotIdx);
            if (cell) { cell.style.borderColor = roiPct >= 0 ? 'rgba(16,185,129,.35)' : 'rgba(239,68,68,.35)'; cell.style.background = roiPct >= 0 ? 'rgba(16,185,129,.05)' : 'rgba(239,68,68,.05)'; }
            // ── Sincronizar PNL vivo en barra superior del Panel 3 ──
            if (slotIdx === activeIdx) {
                const p3Pct = document.getElementById('levelsPanelPnlPct');
                const p3Dol = document.getElementById('levelsPanelPnlDol');
                if (p3Pct) { p3Pct.textContent = (roiPct >= 0 ? '+' : '') + roiPct.toFixed(2) + '%'; p3Pct.style.color = roiPct >= 0 ? 'var(--long)' : 'var(--short)'; }
                if (p3Dol && dolEl) {
                    // Copiar el valor de $ ya calculado por dolEl
                    p3Dol.textContent = dolEl.textContent;
                    p3Dol.style.color = roiPct >= 0 ? 'var(--long)' : 'var(--short)';
                } else if (p3Dol) {
                    // Calcular manualmente si dolEl no existe
                    let _qty = 0;
                    for (let _i = 0; _i < 12; _i++) {
                        const _k = getOrderKey(slotIdx, _i);
                        if (activeOrders[_k] && activeOrders[_k].status === 'filled') _qty += activeOrders[_k].amount;
                        else if (slot.buys && slot.buys.includes(_i) && !activeOrders[_k]) _qty += getLevelData(slot, _i).qty;
                    }
                    if (_qty > 0) {
                        const pnlD = (currentPrice - avgPrice) * _qty;
                        p3Dol.textContent = (pnlD >= 0 ? '+' : '') + '$' + pnlD.toFixed(2);
                        p3Dol.style.color = pnlD >= 0 ? 'var(--long)' : 'var(--short)';
                    } else { p3Dol.textContent = '—'; p3Dol.style.color = ''; }
                }
            }
        }

        // Fix #13: actualización inline liviana (no re-renderiza el DOM de niveles)
        function _updateLevelPricesInline(currentPrice) {
            const s = slots[activeIdx];
            // BUG FIX: verificar que el slot tenga nombre Y precio antes de actualizar
            if (!s || !s.name || s.price <= 0) return;
            if (s.buys && s.buys.length > 0) {
                const avgPrice = calculateAvgPriceForSlotData(s, activeIdx);
                if (avgPrice > 0) {
                    const roiPct = ((currentPrice - avgPrice) / avgPrice * 100);
                    const el = document.getElementById('dashLiveRoi-' + activeIdx);
                    if (el) {
                        el.textContent = (roiPct >= 0 ? '+' : '') + roiPct.toFixed(2) + '%';
                        el.style.color = roiPct >= 0 ? 'var(--long)' : 'var(--short)';
                    }
                    // PNL en dólares
                    let totalQty = 0;
                    for (let i = 0; i < 12; i++) {
                        const key = getOrderKey(activeIdx, i);
                        if (activeOrders[key] && activeOrders[key].status === 'filled') totalQty += activeOrders[key].amount;
                        else if (s.buys && s.buys.includes(i) && !activeOrders[key]) totalQty += getLevelData(s, i).qty;
                    }
                    const dolEl = document.getElementById('dashLivePnlDol-' + activeIdx);
                    if (dolEl && totalQty > 0) {
                        const pnlDol = (currentPrice - avgPrice) * totalQty;
                        dolEl.textContent = (pnlDol >= 0 ? '+' : '') + '$' + pnlDol.toFixed(2);
                        dolEl.style.color = pnlDol >= 0 ? 'var(--long)' : 'var(--short)';
                    }
                    const cell = document.getElementById('dashPnlCell-' + activeIdx);
                    if (cell) { cell.style.borderColor = roiPct >= 0 ? 'rgba(16,185,129,.35)' : 'rgba(239,68,68,.35)'; cell.style.background = roiPct >= 0 ? 'rgba(16,185,129,.05)' : 'rgba(239,68,68,.05)'; }
                    // ── Sincronizar PNL vivo en barra superior del Panel 3 ──
                    const p3Pct2 = document.getElementById('levelsPanelPnlPct');
                    const p3Dol2 = document.getElementById('levelsPanelPnlDol');
                    if (p3Pct2) { p3Pct2.textContent = (roiPct >= 0 ? '+' : '') + roiPct.toFixed(2) + '%'; p3Pct2.style.color = roiPct >= 0 ? 'var(--long)' : 'var(--short)'; }
                    if (p3Dol2 && dolEl) { p3Dol2.textContent = dolEl.textContent; p3Dol2.style.color = dolEl.style.color; }
                }
            }
        }

        // Fix #8: funciones de banner de precio de entrada
        function _showEntryPriceBanner(slotIdx, basePrice, livePrice, deepest, diffPct) {
            const id = 'c5x-entry-warn-' + slotIdx;
            let el = document.getElementById(id);
            if (!el) {
                el = document.createElement('div');
                el.id = id;
                el.style.cssText = 'margin:6px 4px;padding:10px 14px;background:rgba(245,158,11,0.1);border:1.5px solid rgba(245,158,11,0.5);border-radius:12px;font-family:var(--font-head);font-size:10px;color:var(--warning);line-height:1.7;display:flex;align-items:flex-start;gap:8px;';
                const grid = document.getElementById('levelsGrid');
                if (grid && grid.parentNode) grid.parentNode.insertBefore(el, grid);
            }
            const fp = p => p < 1 ? p.toFixed(6) : p.toFixed(4);
            el.innerHTML = `<span style="font-size:16px;flex-shrink:0;">⚠️</span><div><strong>Base ${diffPct}% sobre mercado</strong><br>Base: ${fp(basePrice)} · Real: ${fp(livePrice)} · ETF en N${deepest}<br><span style="color:var(--text-secondary);">Toca N${deepest} → compra acumulada al precio real</span></div>`;
            el.style.display = 'flex';
        }
        function _hideEntryPriceBanner(slotIdx) {
            const el = document.getElementById('c5x-entry-warn-' + slotIdx);
            if (el) el.style.display = 'none';
        }

        function startAutoTrading() {
            const slot = slots[activeIdx];
            if (!slot || !slot.name || !slot.price) {
                setSlotMode(activeIdx, 'manual');
                updateTradingModeUI();
                return;
            }
            // Detectar desde qué nivel continuar (buys consecutivos confirmados)
            let startLevel = 0;
            for (let i = 0; i < 12; i++) {
                const key = getOrderKey(activeIdx, i);
                const isBought = (activeOrders[key] && activeOrders[key].status === 'filled') ||
                                 (slot.buys && slot.buys.includes(i));
                if (isBought) { startLevel = i + 1; } else { break; }
            }
            if (startLevel >= 12) {
                showToast('✅ Todos los niveles ya ejecutados');
                setSlotMode(activeIdx, 'manual');
                updateTradingModeUI();
                return;
            }
            currentAutoLevel = startLevel;
            // NO resetear trailingStopData global — cada slot tiene su estado por índice
            showToast(`🤖 Slot ${activeIdx + 1} AUTO — buscando entrada en nivel ${currentAutoLevel + 1}`);
            // Lanzar ciclo global si no está ya corriendo (sirve para todos los slots en auto)
            if (!priceMonitorInterval) {
                priceMonitorInterval = setInterval(() => { runBotCycle(); }, 5000);
            }
            // Ejecutar ciclo inmediato para comprar si el precio YA está en el nivel
            setTimeout(() => { runBotCycle(); }, 1500);
        }
        // ══════════════════════════════════════════════════════════════
        //  SMART BOT v2 — DISEÑADO PARA ETFs 3S/5S MUY VOLÁTILES
        //  Lógica adaptada a la realidad: 60% daily range, rebalanceos,
        //  anti-crash invertido para shorts, ROI dual manual/auto
        // ══════════════════════════════════════════════════════════════

        // Helpers de contexto
        function isShortETF(name) { return name && (name.includes('3S') || name.includes('5S')); }
        function isLongETF(name)  { return name && (name.includes('3L') || name.includes('5L')); }
        function getETFLeverage(name) {
            if (!name) return 3;
            return name.includes('5') ? 5 : 3;
        }

        // Obtener ROI objetivo según modo del slot
        // MEJORA 1: ROI DINÁMICO basado en volatilidad 24h del ETF
        // Si el ETF movió mucho hoy → target más alto (hay margen real para lograrlo)
        // Si movió poco → target conservador para que cierre
        function getDynamicTargetRoi(name, slotIdx) {
            // En AUTO: el target real es el ROI efectivo desde avg hasta la activación del trailing
            //   Trailing activa en: precio_TP1 × (1 + trailActivePct/100)
            //   precio_TP1 = avg × (1 + tp1Pct/100)
            //   Trailing activa = avg × (1 + tp1Pct/100) × (1 + trailActivePct/100)
            //   ROI efectivo desde avg = (1 + tp1Pct/100) × (1 + trailActivePct/100) − 1 × 100
            const tp1    = (botConfig.tp1Pct         || 50) / 100;
            const trail  = (botConfig.trailActivePct || 100) / 100;
            const base   = (slotModes[slotIdx] || 'manual') === 'auto'
                ? Math.round(((1 + tp1) * (1 + trail) - 1) * 100) // ROI efectivo desde avg hasta trail activa
                : (botConfig.tp1Pct || 50);

            const etf = allGateETFs && allGateETFs.find(t => t.currency_pair === name + '_USDT');
            if (!etf) return base;

            const high = parseFloat(etf.high_24h) || 0;
            const low  = parseFloat(etf.low_24h)  || 0;
            if (!high || !low || low === 0) return base;

            const range24h = ((high - low) / low) * 100;

            let multiplier = 1.0;
            if      (range24h > 150) multiplier = 1.35;
            else if (range24h > 100) multiplier = 1.20;
            else if (range24h >  60) multiplier = 1.10;
            else if (range24h >  30) multiplier = 1.00;
            else if (range24h >  15) multiplier = 0.85;
            else                     multiplier = 0.70;

            const dynTarget = Math.round(base * multiplier);
            return Math.max(50, Math.min(500, dynTarget));
        }

        function getTargetRoi(slotIdx) {
            const s = slots[slotIdx];
            if (s && s.name && (slotModes[slotIdx] || 'manual') === 'auto') {
                return getDynamicTargetRoi(s.name, slotIdx);
            }
            return (slotModes[slotIdx] || 'manual') === 'auto'
                ? (botConfig.autoRoi || 120)
                : (botConfig.tp1Pct || 50);
        }

        // MEJORA 5: Buffer de confirmación N1 — precio debe estar 2 ciclos bajo el nivel
        const _n1ConfirmBuffer = {}; // { 'slotIdx_lvl': { count, lastPrice } }

        function confirmN1Entry(slotIdx, lvl, currentPrice, levelPrice) {
            if (lvl > 0) return true; // solo aplica a N1
            const key = `${slotIdx}_${lvl}`;
            if (!_n1ConfirmBuffer[key]) _n1ConfirmBuffer[key] = { count: 0, lastSeen: 0 };
            const buf = _n1ConfirmBuffer[key];
            const now = Date.now();
            // Fix #10: 1 ciclo de confirmación (antes 2 = ~10s perdidos en ETFs volátiles)
            if (currentPrice <= levelPrice) {
                buf.count = 1;
                buf.lastSeen = now;
                return true; // ✅ confirmado en 1 ciclo
            } else {
                buf.count = 0;
                return false;
            }
        }

        // Velocidad de caída: % por minuto en los últimos N segundos
        function getPriceVelocity(sym, windowSec = 60) {
            const hist = priceHistory[sym];
            if (!hist || hist.length < 2) return 0;
            const now  = Date.now();
            const old  = hist.find(p => now - p.time >= windowSec * 1000);
            if (!old)  return 0;
            const curr = hist[hist.length - 1].price;
            return ((curr - old.price) / old.price) * 100; // positivo = subió, negativo = cayó
        }

        // Score de contexto de mercado para un ETF
        // Fix #11: context score ponderado por volumen
        function getMarketContextScore(name) {
            if (!window._allTickers || !window._allTickers.length) return 0;
            const lm = name.match(/([35])([LS])/);
            if (!lm) return 0;
            const base = name.replace(/[35][LS]$/, '');
            const isS  = lm[2] === 'S';
            const spotT = window._allTickers.find(t => t.currency_pair === base + '_USDT');
            if (!spotT) return 0;
            const spotChg = parseFloat(spotT.change_percentage);
            const spotVol = parseFloat(spotT.quote_volume) || 0;
            const favorable = isS ? spotChg > 0 : spotChg < 0;
            const magnitude = Math.abs(spotChg);
            if (!favorable) return -1;
            // Factor de confianza según volumen 24h
            const volFactor = spotVol > 5e9 ? 1.3 : spotVol > 1e9 ? 1.1 :
                              spotVol > 2e8 ? 1.0 : spotVol > 5e7 ? 0.7 : 0.4;
            const eff = magnitude * volFactor;
            if (eff > 20) return 3;
            if (eff > 10) return 2;
            if (eff > 5)  return 1;
            return 0;
        }

        // Detectar zona horaria de rebalanceo de Gate.io (00:00 UTC, ±30min)
        function isNearRebalanceWindow() {
            const now    = new Date();
            const utcH   = now.getUTCHours();
            const utcM   = now.getUTCMinutes();
            const minsSinceMidnight = utcH * 60 + utcM;
            return minsSinceMidnight <= 35 || minsSinceMidnight >= (24 * 60 - 35);
        }

        // ── CICLO PRINCIPAL DEL BOT ───────────────────────────────────
        // ── DISEÑADO PARA ETFs QUE CAEN 60% EN UN DÍA ───────────────
        // Estrategia: COMPRAR en caídas agresivamente. El crash es la
        // oportunidad. El bot ACELERA cuando detecta caída rápida y
        // ejecuta múltiples niveles si el precio pasó varios de un salto.
        // Fix #14: wrapper paralelo — cada slot tiene timeout independiente
        async function runBotCycle() {
            const now           = Date.now();
            const maxLevels     = botConfig.maxLevels    || 12;
            const crashWindowMs = (botConfig.crashWindow || 5) * 60 * 1000;
            await Promise.allSettled(slots.map((_, i) =>
                Promise.race([
                    _runBotSlot(i, now, maxLevels, crashWindowMs),
                    new Promise(r => setTimeout(r, 9000)) // timeout 9s por slot
                ]).catch(e => addBotLog && addBotLog('error', `S${i+1} err: ${(e?.message||'').slice(0,40)}`))
            ));
        }
        async function _runBotSlot(i, now, maxLevels, crashWindowMs) {
            const s = slots[i];
            if (!s || !s.name || !s.price) return;

                // ── PRECIO EN TIEMPO REAL ─────────────────────────────
                const liveData = allGateETFs.find(t => t.currency_pair === s.name + "_USDT");
                if (!liveData) return; // Fix #14: continue→return
                const currentPrice = parseFloat(liveData.last);
                if (!currentPrice || currentPrice <= 0) return; // Fix #14: continue→return

                // ── HISTORIAL DE PRECIOS ──────────────────────────────
                if (!priceHistory[s.name]) priceHistory[s.name] = [];
                priceHistory[s.name].push({ price: currentPrice, time: now });
                // Mantener últimos 15 minutos de historia
                // Fix #2: ventana 4h (era 15min)
                priceHistory[s.name] = priceHistory[s.name].filter(p => now - p.time < 4 * 60 * 60 * 1000);

                updateSlotStatus(s.name, currentPrice);
                if (i === activeIdx) {
                    if (!runBotCycle._lastPrices) runBotCycle._lastPrices = {};
                    const lastR = runBotCycle._lastPrices[i] || 0;
                    const chgPct = Math.abs(currentPrice - lastR) / (lastR || 1);
                    if (chgPct > 0.001) {
                        runBotCycle._lastPrices[i] = currentPrice;
                        // Fix #13: re-render completo solo si cambio >1% (nuevo nivel ALCANZADO)
                        // para cambios pequeños solo actualizar ROI/ticker inline
                        if (chgPct > 0.01) { renderLevels(); }
                        else { _updateLevelPricesInline(currentPrice); }
                    }
                    updateMultiBuyLiveStrips();
                }

                if ((slotModes[i] || 'manual') !== 'auto') {
                    updateBotSlotPill(i, 'manual', '—');
                    // Fix #7: notificar niveles alcanzados aunque el slot sea manual
                    _checkManualLevelAlerts(s, i, currentPrice);
                    // Fix #9: actualizar ROI live sin re-render
                    if (s.buys && s.buys.length > 0) _updateManualSlotLiveROI(s, i, currentPrice);
                    return; // Fix #14: continue→return
                }

                const isShort  = isShortETF(s.name);
                const leverage = getETFLeverage(s.name);
                const vel2m    = getPriceVelocity(s.name, 120);  // %/2min
                const vel10m   = getPriceVelocity(s.name, 600);  // %/10min
                const ctxScore = botConfig.contextAware ? getMarketContextScore(s.name) : 0;

                // ── VELOCIDAD DE CAÍDA ─────────────────────────────────
                // Para comprar en crash: queremos que el ETF esté CAYENDO
                // "cayendo" = precio actual < precio histórico → vel negativa
                const crashThreshold = botConfig.crashDrop || 8;   // % caída en 2min → crash
                const fastThreshold  = botConfig.crashFast || 3;   // % caída en 2min → rápida
                const isCrashing    = vel2m < -crashThreshold;   // cayó >8% en 2min → crash activo
                const isFallingFast = vel2m < -fastThreshold;    // cayó >3% en 2min → caída rápida
                const isRisingFast  = vel2m >  crashThreshold;   // subió >8% en 2min → rally

                // ── CIRCUIT BREAKER DESACTIVADO ──────────────────────────
                // Los ETFs apalancados son volátiles por naturaleza.
                // El bot NUNCA se detiene por caída — sigue comprando niveles siempre.
                // circuitEnabled se ignora completamente.

                // ── ACELERACIÓN EN CRASH ─────────────────────────────────
                if (!runBotCycle._fastSlots) runBotCycle._fastSlots = {};
                if (!runBotCycle._fastSince) runBotCycle._fastSince = {};
                if (isCrashing && priceMonitorInterval) {
                    if (!runBotCycle._fastSlots[i]) {
                        runBotCycle._fastSlots[i] = true;
                        runBotCycle._fastSince[i] = now;
                        const anyFastBefore = Object.keys(runBotCycle._fastSlots).length > 1;
                        if (!anyFastBefore) {
                            clearInterval(priceMonitorInterval);
                            priceMonitorInterval = setInterval(() => { runBotCycle(); }, 2000);
                        }
                        addBotLog('info', `S${i+1} ${s.name}: ⚡ MODO CRASH — ciclo 2s`);
                    }
                } else if (runBotCycle._fastSlots && runBotCycle._fastSlots[i] && !isFallingFast) {
                    if (now - (runBotCycle._fastSince[i] || 0) > 60000) {
                        delete runBotCycle._fastSlots[i];
                        delete runBotCycle._fastSince[i];
                        const stillFast = Object.keys(runBotCycle._fastSlots).length > 0;
                        if (!stillFast) {
                            clearInterval(priceMonitorInterval);
                            priceMonitorInterval = setInterval(() => { runBotCycle(); }, 5000);
                        }
                    }
                }

                // ══════════════════════════════════════════════════════
                // ── ESTRATEGIA DE SALIDAS AUTO ────────────────────────
                // TP1:       avg + 50%  → vende 50% del activo
                // TRAILING:  cuando el 50% restante llega a avg + 100%
                //            se activa trailing stop a -15% desde el máximo.
                //            El activo SIGUE CORRIENDO hasta que retrocede.
                // REBUY:     si sólo se vendió el 50% (TP1) y el activo cae
                //            16% desde el precio de venta → 12 niveles nuevos.
                // ══════════════════════════════════════════════════════
                const realAvg = calculateAvgPriceForSlotData(s, i);

                if (realAvg > 0) {
                    const tp1Pct         = botConfig.tp1Pct         || 50;
                    const trailActivePct = botConfig.trailActivePct || 100;
                    const trailDropPct   = botConfig.trailDropPct   || 15;
                    const currentRoiPct  = ((currentPrice - realAvg) / realAvg * 100);

                    if (!trailingStopData[i]) trailingStopData[i] = { maxPrice: 0, trailMax: 0, trailActivated: false, exits: {} };

                    // ── TP1: avg + 50% → vender 50% ──────────────────
                    if (!trailingStopData[i].exits.tp1 && currentRoiPct >= tp1Pct) {
                        trailingStopData[i].exits.tp1    = true;
                        trailingStopData[i].tp1SellPrice = currentPrice;
                        trailingStopData[i].trailMax     = currentPrice;
                        trailingStopData[i].maxPrice     = currentPrice;
                        const tp1SellPxFmt = currentPrice < 1 ? currentPrice.toFixed(6) : currentPrice.toFixed(4);
                        const trailActivatePxEst = currentPrice * (1 + trailActivePct / 100);
                        const trailActivateFmt = trailActivatePxEst < 1 ? trailActivatePxEst.toFixed(6) : trailActivatePxEst.toFixed(4);
                        const notifMsg = `TP1 +${currentRoiPct.toFixed(1)}% @$${tp1SellPxFmt} → vendido 50% | trailing activa a TP1+${trailActivePct}% ($${trailActivateFmt})`;
                        showToast(`🎯 S${i+1} ${s.name}: TP1 +${currentRoiPct.toFixed(1)}%`, 4000, false, true);
                        sendNativeNotif(`🎯 TP1 — ${s.name}`, notifMsg);
                        addBotLog('tp', `S${i+1} ${s.name} TP1 @$${tp1SellPxFmt} +${currentRoiPct.toFixed(1)}% | 50% vendido | trailing arranca a TP1+${trailActivePct}% ($${trailActivateFmt})`);
                        if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
                        await executePartialSell(s, i, currentPrice, 0.50, 'TP1');
                    }

                    // ── POST TP1: vigilar trailing del 50% restante ───
                    if (trailingStopData[i].exits.tp1 && !trailingStopData[i].exits.tp2) {
                        // Actualizar máximo histórico siempre
                        if (currentPrice > trailingStopData[i].maxPrice) trailingStopData[i].maxPrice = currentPrice;

                        // Activar trailing cuando el precio supera TP1_precio + trailActivePct (100%)
                        // ── TP2 SE CALCULA DESDE EL PRECIO DE VENTA TP1, NO DESDE AVG ──────────
                        const tp1SellPxBot = trailingStopData[i].tp1SellPrice || 0;
                        const trailActivatePrice = tp1SellPxBot > 0
                            ? tp1SellPxBot * (1 + trailActivePct / 100)
                            : realAvg * (1 + trailActivePct / 100); // fallback si aún no hay tp1
                        if (!trailingStopData[i].trailActivated && currentPrice >= trailActivatePrice) {
                            trailingStopData[i].trailActivated = true;
                            trailingStopData[i].trailMax       = currentPrice;
                            const notifMsg = `TRAILING activado @$${currentPrice.toFixed(6)} +${currentRoiPct.toFixed(1)}% — retroceso de -${trailDropPct}% desde el máximo cerrará`;
                            showToast(`📈 S${i+1} ${s.name}: TRAILING ACTIVO`, 3500, false, true);
                            sendNativeNotif(`📈 Trailing Activado — ${s.name}`, notifMsg);
                            addBotLog('trail', `S${i+1} ${s.name} TRAILING ACTIVADO @$${currentPrice.toFixed(6)} +${currentRoiPct.toFixed(1)}% | -${trailDropPct}% desde máximo → vende`);
                            if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
                        }

                        if (trailingStopData[i].trailActivated) {
                            // Actualizar máximo del trailing
                            if (currentPrice > trailingStopData[i].trailMax) trailingStopData[i].trailMax = currentPrice;

                            const trailStopPrice = trailingStopData[i].trailMax * (1 - trailDropPct / 100);
                            const pctFromMax     = ((currentPrice - trailingStopData[i].trailMax) / trailingStopData[i].trailMax * 100).toFixed(1);
                            const roiNow         = currentRoiPct.toFixed(1);
                            updateBotSlotPill(i, 'trailing', `📈 +${roiNow}% | máx$${trailingStopData[i].trailMax.toFixed(4)} | stop${pctFromMax}%`);

                            // ¿Retrocedió trailDropPct% desde el máximo? → vender el resto
                            if (currentPrice <= trailStopPrice) {
                                trailingStopData[i].exits.tp2 = true;
                                const notifMsg = `TRAILING STOP -${trailDropPct}% desde máx $${trailingStopData[i].trailMax.toFixed(6)} → vendiendo 50% restante @$${currentPrice.toFixed(6)} (+${roiNow}%)`;
                                showToast(`🔔 S${i+1} ${s.name}: TRAILING STOP`, 5000, false, true);
                                sendNativeNotif(`🔔 Trailing Stop — ${s.name}`, notifMsg);
                                addBotLog('sell', `S${i+1} ${s.name} TRAILING STOP @$${currentPrice.toFixed(6)} +${roiNow}% | máx $${trailingStopData[i].trailMax.toFixed(6)} | 50% restante vendido`);
                                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                                await executeAutoSell(s, i, currentPrice, roiNow);
                                localStorage.removeItem('c5x_trl_' + i + '_' + s.name);
                                delete trailingStopData[i];
                                return;
                            }
                        } else {
                            // Trailing aún no activa → esperando TP1_precio + trailActivePct%
                            const tp1Px = trailingStopData[i].tp1SellPrice || 0;
                            const waitTarget = tp1Px > 0 ? tp1Px * (1 + trailActivePct / 100) : 0;
                            const waitFmt = waitTarget > 0 ? ' ($'+(waitTarget<1?waitTarget.toFixed(6):waitTarget.toFixed(4))+')' : '';
                            updateBotSlotPill(i, 'trailing', `🎯TP1✓ +${currentRoiPct.toFixed(1)}% → TRAIL a TP1+${trailActivePct}%${waitFmt}`);
                        }

                        return; // esperando trailing — no comprar más niveles
                    }

                    // Alerta cuando se acerca a TP1 (80% del camino)
                    if (!trailingStopData[i].exits.tp1 && currentRoiPct >= tp1Pct * 0.80) {
                        const nkClose = 'c5x_close_' + i + '_' + s.name;
                        if (!localStorage.getItem(nkClose)) {
                            sendNativeNotif(`🔔 Cerca de TP1 — ${s.name}`, `+${currentRoiPct.toFixed(1)}% → TP1 objetivo avg+${tp1Pct}%`, { tag:'c5x-near-tp1' });
                            localStorage.setItem(nkClose, Date.now().toString());
                        }
                    } else if (currentRoiPct < tp1Pct * 0.60) {
                        localStorage.removeItem('c5x_close_' + i + '_' + s.name);
                    }
                }

                // ── LÓGICA DE COMPRA — TODOS LOS NIVELES ALCANZADOS ───
                // CLAVE: si el precio cayó PASANDO VARIOS NIVELES de un salto,
                // el bot los EJECUTA TODOS en una sola pasada del ciclo.
                // Así no pierde oportunidades en crashes de 30% en 2 minutos.

                // ══ REBUY POST-TP1 — CAÍDA 16% DESDE PRECIO DE VENTA TP1 — HASTA 3 CICLOS ═══
                // Cada rebuy acumula el 50% restante del ciclo anterior al nuevo promedio.
                const _rebuyNow = s.rebuyCount || 0;
                if (trailingStopData[i]?.tp1SellPrice && _rebuyNow < 3 &&
                    trailingStopData[i].exits.tp1 && !trailingStopData[i].exits.tp2) {

                    const rebuyDropPct = botConfig.rebuyDropPct || 16;
                    const dropFromTP1  = ((trailingStopData[i].tp1SellPrice - currentPrice) / trailingStopData[i].tp1SellPrice) * 100;

                    if (dropFromTP1 >= rebuyDropPct) {
                        s.rebuyCount = _rebuyNow + 1;
                        const cycleNum  = s.rebuyCount;
                        const cycleLeft = 3 - cycleNum;

                        // ── Acumular el 50% restante al blend de promedio ──
                        let _oldSpent = 0, _oldQty = 0, _lp = s.price;
                        const _lim = customMultipliers.length || 12;
                        for (let _k = 0; _k < _lim; _k++) {
                            const _bk = getOrderKey(i, _k);
                            if (activeOrders[_bk] && activeOrders[_bk].status === 'filled') {
                                _oldSpent += activeOrders[_bk].price * activeOrders[_bk].amount;
                                _oldQty   += activeOrders[_bk].amount;
                            } else if (s.buys && s.buys.includes(_k) && !activeOrders[_bk]) {
                                const _ld = getLevelDataData(s, _k);
                                _oldSpent += _ld.usd; _oldQty += _ld.qty;
                            }
                        }
                        // Acumular (no reemplazar) — suma el 50% de este ciclo a lo anterior
                        s.rebuyOldSpent = (s.rebuyOldSpent || 0) + _oldSpent * 0.50;
                        s.rebuyOldQty   = (s.rebuyOldQty   || 0) + _oldQty   * 0.50;

                        s.price = currentPrice; // nueva base para los 12 niveles

                        const filledBuys = (s.buys || []).filter(bi => {
                            const bk = getOrderKey(i, bi);
                            return activeOrders[bk] && activeOrders[bk].status === 'filled';
                        });
                        s.buys = filledBuys;
                        s.multipleBuys = {};

                        // Limpiar órdenes pendientes
                        const pfx = `s${i}_`;
                        Object.keys(activeOrders).forEach(k => {
                            if (k.startsWith(pfx) && activeOrders[k].status !== 'filled') delete activeOrders[k];
                        });
                        saveActiveOrders();

                        // Resetear trailing para recalcular con nuevo promedio
                        trailingStopData[i] = {
                            maxPrice: currentPrice, trailMax: currentPrice,
                            trailActivated: false, exits: {}, tp1SellPrice: 0
                        };

                        save();
                        if (i === activeIdx) { calculate(); renderLevels(); }

                        const dropStr    = dropFromTP1.toFixed(1);
                        const tp1Str     = trailingStopData[i] ? '' : '';
                        const newBaseStr = currentPrice < 1 ? currentPrice.toFixed(6) : currentPrice.toFixed(4);
                        showToast(`🔄 Rebuy ${cycleNum}/3 S${i+1} ${s.name}: −${dropStr}% → 12 niveles · ${cycleLeft} más`, 5000, false, true);
                        sendNativeNotif(`🔄 Rebuy ${cycleNum}/3 — ${s.name}`, `↓${dropStr}% desde TP1 → 12 niveles · Base $${newBaseStr} · ${cycleLeft} ciclo${cycleLeft !== 1 ? 's' : ''} restante${cycleLeft !== 1 ? 's' : ''}`);
                        if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 400]);
                    }
                }

                // ════════════════════════════════════════════════════════
                // ── LÓGICA DE COMPRA ──────────────────────────────────
                // MODO NORMAL: compra un nivel por ciclo, secuencial.
                // MODO CRASH (isCrashing || isFallingFast):
                //   Acumula el capital de TODOS los niveles saltados por el precio
                //   y ejecuta UNA SOLA compra al precio actual del nivel más cercano.
                //   Esto evita comprar caro en múltiples órdenes durante el crash.
                // ════════════════════════════════════════════════════════
                let boughtAny = false;

                // Identificar niveles saltados (precio < levelPrice) y no comprados
                const skippedLevels = [];
                let   nextBuyLevel  = -1;   // primer nivel no comprado que el precio ya cruzó
                let   nextWaitLevel = -1;   // primer nivel no comprado que el precio AÚN no cruzó

                for (let lvl = 0; lvl < Math.min(12, maxLevels); lvl++) {
                    const key       = getOrderKey(i, lvl);
                    const isFilled  = (activeOrders[key] && activeOrders[key].status === 'filled') ||
                                      (s.buys && s.buys.includes(lvl) && !activeOrders[key]);
                    const isPending = activeOrders[key] && activeOrders[key].status === 'open';

                    if (isFilled)  continue;
                    if (isPending) { updateBotSlotPill(i, 'buying', `N${lvl+1}⏳`); boughtAny = true; break; }

                    const levelData  = getLevelDataData(s, lvl);
                    const levelPrice = levelData.price;

                    if (currentPrice <= levelPrice) {
                        // Precio ya cruzó este nivel
                        skippedLevels.push({ lvl, levelData, levelPrice });
                    } else {
                        // Precio aún no llegó a este nivel
                        nextWaitLevel = lvl;
                        break;
                    }
                }

                if (skippedLevels.length === 0) {
                    // Ningún nivel cruzado — mostrar próximo pendiente
                    if (nextWaitLevel >= 0) {
                        const ld  = getLevelDataData(s, nextWaitLevel);
                        const dis = ((ld.price - currentPrice) / currentPrice * 100).toFixed(1);
                        const avgNow = calculateAvgPriceForSlotData(s, i);
                        const roi = avgNow > 0 ? ((currentPrice - avgNow) / avgNow * 100).toFixed(1) : null;
                        const roiStr = roi ? ` · PnL${roi >= 0 ? '+' : ''}${roi}%` : '';
                        updateBotSlotPill(i, 'waiting', `N${nextWaitLevel+1} -${dis}%${roiStr}`);
                    } else {
                        updateBotSlotPill(i, 'waiting', '✅ full');
                    }
                } else if ((isCrashing || isFallingFast) && skippedLevels.length > 1) {
                    // ── CRASH: acumular capital de todos los niveles saltados ──
                    // Verificar que el nivel anterior al primero esté comprado (secuencial)
                    const firstLvl = skippedLevels[0].lvl;
                    if (firstLvl > 0) {
                        const prevKey    = getOrderKey(i, firstLvl - 1);
                        const prevFilled = (activeOrders[prevKey] && activeOrders[prevKey].status === 'filled') ||
                                           (s.buys && s.buys.includes(firstLvl - 1) && !activeOrders[prevKey]);
                        if (!prevFilled) {
                            updateBotSlotPill(i, 'buying', `N${firstLvl}→N${firstLvl+1}`);
                            return;
                        }
                    }

                    // Confirmación N1 en crash no es necesaria — el crash lo confirma
                    const totalUSD = skippedLevels.reduce((sum, l) => sum + l.levelData.usd, 0);
                    const buyQty   = totalUSD / currentPrice;
                    const lvlNums  = skippedLevels.map(l => `N${l.lvl+1}`).join('+');
                    const crashData = { price: currentPrice, qty: buyQty, usd: totalUSD, isMarket: true };

                    addBotLog('buy', `S${i+1} ${s.name} ⚡CRASH ACUM ${lvlNums} @$${currentPrice.toFixed(6)} | $${totalUSD.toFixed(2)} en 1 orden | vel ${vel2m.toFixed(1)}%/2m`);
                    updateBotSlotPill(i, 'buying', `⚡${lvlNums}`);
                    showToast(`⚡ CRASH S${i+1}: ${lvlNums} acumulados → $${totalUSD.toFixed(2)} @$${currentPrice.toFixed(4)}`, 3000, false, true);

                    // Marcar todos los niveles saltados como comprados en la UI
                    skippedLevels.forEach(l => {
                        if (!s.buys.includes(l.lvl)) s.buys.push(l.lvl);
                    });

                    // Ejecutar UNA sola orden con el capital acumulado
                    let sent = false;
                    if (i === activeIdx) { sent = await sendAutoLevelOrder(skippedLevels[0].lvl, crashData); }
                    else                 { sent = await sendBackgroundOrder(i, skippedLevels[0].lvl, crashData); }

                    if (!sent) {
                        // Revertir marcado si falló
                        skippedLevels.forEach(l => {
                            const idx = s.buys.indexOf(l.lvl);
                            if (idx !== -1) s.buys.splice(idx, 1);
                        });
                        autoBuyErrorCooldown[i+'_'+skippedLevels[0].lvl] = Date.now() + 5*60*1000;
                        updateBotSlotPill(i, 'waiting', `⚡crash err·5m`);
                    } else {
                        boughtAny = true;
                    }

                } else {
                    // ── NORMAL: comprar el primer nivel cruzado (secuencial) ──
                    const { lvl, levelData, levelPrice } = skippedLevels[0];

                    // Verificar nivel anterior comprado
                    if (lvl > 0) {
                        const prevKey    = getOrderKey(i, lvl - 1);
                        const prevFilled = (activeOrders[prevKey] && activeOrders[prevKey].status === 'filled') ||
                                           (s.buys && s.buys.includes(lvl - 1) && !activeOrders[prevKey]);
                        if (!prevFilled) {
                            updateBotSlotPill(i, 'buying', `N${lvl}→N${lvl+1}`);
                            return;
                        }
                    }

                    // Confirmación N1 en caída normal
                    if (lvl === 0 && !isFallingFast && !isCrashing) {
                        if (!confirmN1Entry(i, lvl, currentPrice, levelPrice)) {
                            updateBotSlotPill(i, 'waiting', `N1 confirmando…`);
                            return;
                        }
                    }

                    const actualQty = levelData.usd / currentPrice;
                    const adjData   = { price: currentPrice, qty: actualQty, usd: levelData.usd };
                    if (lvl >= 4 && lvl <= 9) adjData.isMarket = true;

                    const _errKey = i+'_'+lvl;
                    if (autoBuyErrorCooldown[_errKey] && Date.now() < autoBuyErrorCooldown[_errKey]) {
                        const _rem = Math.ceil((autoBuyErrorCooldown[_errKey]-Date.now())/60000);
                        updateBotSlotPill(i, 'waiting', `N${lvl+1} err·${_rem}m`);
                        return;
                    }

                    const velStr    = isFallingFast ? `📉${vel2m.toFixed(1)}%/2m` : `📊 ${vel2m.toFixed(1)}%/2m`;
                    const dynRoiStr = ` ROI-obj:${getDynamicTargetRoi(s.name, i).toFixed(0)}%`;
                    addBotLog('buy', `S${i+1} ${s.name} N${lvl+1} @$${currentPrice.toFixed(6)} | ${velStr}${dynRoiStr} | $${levelData.usd.toFixed(2)} invertidos`);
                    updateBotSlotPill(i, 'buying', `N${lvl+1}🔄`);
                    refreshBotDash();

                    let sent = false;
                    if (i === activeIdx) { sent = await sendAutoLevelOrder(lvl, adjData); }
                    else                 { sent = await sendBackgroundOrder(i, lvl, adjData); }

                    if (!sent) {
                        autoBuyErrorCooldown[_errKey] = Date.now() + 5*60*1000;
                        updateBotSlotPill(i, 'waiting', `N${lvl+1} err·5m`);
                    } else {
                        boughtAny = true;
                    }
                }

                if (!boughtAny && nextWaitLevel >= 0) {
                    const ld  = getLevelDataData(s, nextWaitLevel);
                    const dis = ((ld.price - currentPrice) / currentPrice * 100).toFixed(1);
                    const avgNow = calculateAvgPriceForSlotData(s, i);
                    const roi = avgNow > 0 ? ((currentPrice - avgNow) / avgNow * 100).toFixed(1) : null;
                    const roiStr = roi ? ` · PnL${roi >= 0 ? '+' : ''}${roi}%` : '';
                    updateBotSlotPill(i, 'waiting', `N${nextWaitLevel+1} -${dis}%${roiStr}`);
                }
        }
        function updateBotSlotPill(slotIdx, state, label) {
            const pill = document.getElementById('bss-' + slotIdx);
            const lbl = document.getElementById('bss-lbl-' + slotIdx);
            if (!pill || !lbl) return;
            pill.className = 'bot-slot-pill ' + state;
            lbl.textContent = label;
        }
        function calculateAvgPriceForSlotData(s, slotIdx) {
            if(!s.price) return 0; 
            let totalSpent = 0, totalQty = 0, lastPrice = s.price; 
            const limit = (customMultipliers && customMultipliers.length) ? customMultipliers.length : 12; 
            const params = getStrategyParams(s.strat || 'normal');
            
            for(let i=0; i<limit; i++){ 
                let pLevel; 
                if(i===0) {
                    pLevel = s.price;
                } else { 
                    const step = getStepForLevel(s.strat || 'normal', i);
                    pLevel = lastPrice*(1-(step/100)); 
                } 
                
                const m = customMultipliers[i]||1; 
                const mUSD = m*params.capital; 
                
                const key = getOrderKey(slotIdx, i); 
                if(activeOrders[key] && activeOrders[key].status === 'filled') { 
                    totalSpent += activeOrders[key].price * activeOrders[key].amount; 
                    totalQty += activeOrders[key].amount; 
                } else if (s.buys && s.buys.includes(i) && !activeOrders[key]) {
                    // Compra manual legacy (sin orden Gate.io)
                    totalSpent += mUSD;
                    totalQty += mUSD / pLevel;
                }
                // Compras múltiples (niveles 7-10)
                if (i >= 4 && i <= 9 && s.multipleBuys && s.multipleBuys[i]) {
                    for (let buy of s.multipleBuys[i]) {
                        totalSpent += buy.usd;
                        totalQty += buy.qty;
                    }
                }
                lastPrice = pLevel; 
            }

            // ── REBUY BLEND: incluir las compras acumuladas de ciclos anteriores ──
            // Cuando hay rebuy activo, el slot acumula el 50% de inventario de cada
            // ciclo anterior. Esas unidades tienen su propio costo y mejoran el promedio global.
            if ((s.rebuyCount || 0) > 0 && s.rebuyOldQty > 0 && s.rebuyOldSpent > 0) {
                totalSpent += s.rebuyOldSpent;
                totalQty   += s.rebuyOldQty;
            }

            return totalQty > 0 ? totalSpent/totalQty : 0; 
        }
        function getLevelDataData(s, i) {
            // Usa getStepForLevel para consistencia con getLevelData y renderLevels
            let currentPrice = s.price; 
            
            for (let k = 0; k <= i; k++) { 
                if (k === 0) {
                    currentPrice = s.price;
                } else { 
                    const step = getStepForLevel('normal', k); 
                    currentPrice = currentPrice * (1 - (step / 100)); 
                } 
            } 
            
            const params = strategyParams.normal;
            let multiplier = customMultipliers[i] || 1; 
            let levelCapital = params.capital * multiplier; 
            
            return { price: currentPrice, qty: levelCapital / currentPrice, usd: levelCapital }; 
        }
        async function sendBackgroundOrder(slotIdx, levelIndex, data) { const slot = slots[slotIdx]; const symbol = slot.name.toUpperCase(); const key = getOrderKey(slotIdx, levelIndex); if (!isPrivateMode) { activeOrders[key] = { status: 'filled', price: data.price, amount: data.qty, symbol: symbol, timestamp: Date.now() }; saveActiveOrders(); } }
        // MEJORA 2: Venta parcial de un % de la posición (TP1 / TP2)
        async function executePartialSell(slot, slotIdx, exitPrice, fraction, label) {
            let totalSpent = 0, totalQty = 0, lastP = slot.price;
            const limit = customMultipliers.length || 12;
            for (let i = 0; i < limit; i++) {
                let pLevel = i === 0 ? slot.price : lastP * (1 - getStepForLevel('normal', i) / 100);
                lastP = pLevel;
                const key = getOrderKey(slotIdx, i);
                if (activeOrders[key] && activeOrders[key].status === 'filled') {
                    totalSpent += activeOrders[key].price * activeOrders[key].amount;
                    totalQty   += activeOrders[key].amount;
                } else if (slot.buys && slot.buys.includes(i) && !activeOrders[key]) {
                    const m = customMultipliers[i] || 1;
                    const u = m * strategyParams.normal.capital;
                    totalSpent += u; totalQty += u / pLevel;
                }
            }
            if (totalQty <= 0) return;
            const sellQty    = totalQty * fraction;
            const avgCost    = totalQty > 0 ? totalSpent / totalQty : 0;
            const partialRevenue = sellQty * exitPrice;
            const partialCost    = sellQty * avgCost;
            const partialProfit  = partialRevenue - partialCost;

            const log = {
                date: _fmtDate(new Date()),
                time: _fmtTime(new Date()),
                coin: slot.name + ' [' + label + ']',
                profit: partialProfit.toFixed(2),
                netProfit: partialProfit,
                roi: (((exitPrice - avgCost) / avgCost) * 100).toFixed(1) + '%',
                exitPrice, avgPrice: avgCost, totalSpent: partialCost,
                isPartial: true, fraction, label
            };
            history.push(log);
            localStorage.setItem('c5x_history', JSON.stringify(history));
            renderHistory && renderHistory();

            const pStr = partialProfit >= 0 ? `+$${partialProfit.toFixed(2)}` : `-$${Math.abs(partialProfit).toFixed(2)}`;
            showToast(`💰 ${label} S${slotIdx+1} ${slot.name}: ${pStr} (${(fraction*100).toFixed(0)}% vendido)`);

            // Si hay modo real, enviar orden a Gate.io
            if (isPrivateMode && apiConfig.key) {
                try {
                    await callGateApi('POST', '/spot/orders', {
                        currency_pair: slot.name + '_USDT', side: 'sell',
                        amount: sellQty.toFixed(4), type: 'market', account: 'spot', time_in_force: 'ioc'
                    }, true);
                } catch(e) { console.warn('[PartialSell] Gate.io error:', e.message); }
            }
        }

        async function executeAutoSell(slot, slotIdx, exitPrice, roiActual) {
            // Calcular PnL REAL antes de limpiar
            let totalSpent = 0, totalQty = 0, lastPrice = slot.price;
            const limit = customMultipliers.length || 12;
            for (let i = 0; i < limit; i++) {
                let pLevel = (i === 0) ? slot.price : lastPrice * (1 - (getStepForLevel('normal', i) / 100));
                lastPrice = pLevel;
                const key = getOrderKey(slotIdx, i);
                if (activeOrders[key] && activeOrders[key].status === 'filled') {
                    totalSpent += activeOrders[key].price * activeOrders[key].amount;
                    totalQty += activeOrders[key].amount;
                } else if (slot.buys && slot.buys.includes(i) && !activeOrders[key]) {
                    const m = customMultipliers[i] || 1;
                    const mUSD = m * strategyParams.normal.capital;
                    totalSpent += mUSD;
                    totalQty += mUSD / pLevel;
                }
                if (i >= 4 && i <= 9 && slot.multipleBuys && slot.multipleBuys[i]) {
                    for (let buy of slot.multipleBuys[i]) { totalSpent += buy.usd; totalQty += buy.qty; }
                }
            }
            const saleValue = totalQty * exitPrice;
            const netProfit = saleValue - totalSpent;
            const avgPrice = totalQty > 0 ? totalSpent / totalQty : 0;

            // Limpiar órdenes activas
            const keyPrefix = `s${slotIdx}_`;
            Object.keys(activeOrders).forEach(k => { if (k.startsWith(keyPrefix)) delete activeOrders[k]; });

            // Limpiar flags de rebuy para próximo trade
            if (slot.rebuyCount !== undefined) { 
                slot.rebuyCount    = 0; 
                slot.rebuyOldQty   = 0;
                slot.rebuyOldSpent = 0;
            };

            const log = {
                date: _fmtDate(new Date()),
                time: _fmtTime(new Date()),
                coin: slot.name,
                profit: netProfit.toFixed(2),
                netProfit: netProfit,
                roi: roiActual + '%',
                exitPrice: exitPrice,
                avgPrice: avgPrice,
                totalSpent: totalSpent
            };
            history.push(log);
            save();

            const profitStr = netProfit >= 0 ? `+$${netProfit.toFixed(2)}` : `-$${Math.abs(netProfit).toFixed(2)}`;
            showToast(`💰 S${slotIdx+1} VENDIDO: ${profitStr} (${roiActual}%)`);
            addBotLog('sell', `S${slotIdx+1} ${slot.name} VENDIDO ${profitStr} · ROI ${roiActual}% · Precio $${exitPrice.toFixed(4)}`);

            // MEJORA 5: Reinicio automático si está configurado
            const restartDelayMs = (botConfig.restartDelay || 0) * 60 * 1000;
            if (restartDelayMs > 0) {
                // Cancelar timer previo si existe
                if (autoRestartTimers[slotIdx]) clearTimeout(autoRestartTimers[slotIdx]);
                const slotName = slot.name; // guardar antes de resetear
                showToast(`♻️ S${slotIdx+1} reiniciará en ${botConfig.restartDelay}min`, 4000, false, true);
                autoRestartTimers[slotIdx] = setTimeout(() => {
                    // Solo reiniciar si el slot sigue vacío (no fue configurado manualmente)
                    const currentSlot = slots[slotIdx];
                    if (!currentSlot || !currentSlot.name) {
                        // No hay nada que reiniciar, el slot fue limpiado
                        delete autoRestartTimers[slotIdx];
                        return;
                    }
                    setSlotMode(slotIdx, 'auto');
                    const prevActive = activeIdx;
                    activeIdx = slotIdx;
                    startAutoTrading();
                    activeIdx = prevActive;
                    updateTradingModeUI();
                    showToast(`♻️ S${slotIdx+1} ${currentSlot.name} — Auto reiniciado`, 3000, false, true);
                    delete autoRestartTimers[slotIdx];
                }, restartDelayMs);
            }

            // Limpiar estado completo + refrescar UI
            _finalizeSlotSell(slotIdx);
        }
        function stopAutoTrading() { console.log("Modo manual activado"); }
        function sendNextAutoLevel() { if ((slotModes[activeIdx]||'manual') !== 'auto') return; const slot = slots[activeIdx]; if (!slot.name || !slot.price) return; for (let i = 0; i < 12; i++) { const key = getOrderKey(activeIdx, i); const isFilled = (activeOrders[key] && activeOrders[key].status === 'filled') || (slot.buys && slot.buys.includes(i) && !activeOrders[key]); if (!isFilled) { if (i > 0) { const prevKey = getOrderKey(activeIdx, i - 1); const prevFilled = (activeOrders[prevKey] && activeOrders[prevKey].status === 'filled') || (slot.buys && slot.buys.includes(i - 1)); if (!prevFilled) break; } currentAutoLevel = i; break; } } }
        function checkAndSendNextAutoLevel(slot, slotIdx, currentPrice) { if ((slotModes[slotIdx]||'manual') !== 'auto') return; for (let i = 0; i < 12; i++) { const key = getOrderKey(slotIdx, i); if (!activeOrders[key] || activeOrders[key].status !== 'filled') { const levelData = getLevelDataData(slot, i); if (currentPrice <= levelData.price) { if (slotIdx === activeIdx) { sendAutoLevelOrder(i); } } break; } } }
        function smartPriceAdjustment(slot, slotIdx, currentPrice) { if (!slot.buys || slot.buys.length > 0) return false; let hasActiveOrders = false; for (let i = 0; i < 12; i++) { const key = getOrderKey(slotIdx, i); if (activeOrders[key]) { hasActiveOrders = true; break; } } if (hasActiveOrders) return false; const initialPrice = slot.initialPrice || slot.price; const currentBasePrice = slot.price; if (currentPrice < currentBasePrice) { const oldPrice = slot.price; slot.price = currentPrice; if (!slot.initialPrice) { slot.initialPrice = oldPrice; } slot.priceAdjusted = true; save(); const dropPercent = ((oldPrice - currentPrice) / oldPrice * 100).toFixed(1); showToast(`📉 ${slot.name}: Precio base ajustado de $${oldPrice.toFixed(6)} → $${currentPrice.toFixed(6)} (-${dropPercent}%)`, 4000, false, true); if (slotIdx === activeIdx) { document.getElementById('baseInput').value = currentPrice; const indicator = document.getElementById('priceAdjustIndicator'); if (indicator) { indicator.style.display = 'block'; indicator.title = `Ajustado automáticamente desde $${initialPrice.toFixed(6)}`; } calculate(); renderLevels(); } return true; } return false; }
        function toggleLevelsVisibility() { 
            const container = document.getElementById('levelsGrid'); 
            const investmentBox = document.getElementById('investmentBox'); 
            const icon = investmentBox.querySelector('.expand-icon'); 
            
            if (container.classList.contains('collapsed')) { 
                // EXPANDIR - mostrar niveles con scroll
                container.classList.remove('collapsed'); 
                container.style.maxHeight = ''; // Remover estilo inline para usar CSS
                container.style.opacity = ''; 
                container.style.paddingTop = ''; 
                container.style.paddingBottom = ''; 
                container.style.overflow = ''; // Permitir scroll del CSS
                
                if(icon) icon.classList.remove('expanded'); 
            } else { 
                // COLAPSAR - ocultar niveles
                container.classList.add('collapsed'); 
                
                if(icon) icon.classList.add('expanded'); 
            } 
        }
        function toggleLevelsVisibilityExplicit() { toggleLevelsVisibility(); triggerHaptic(); }
        async function executeGateOrder() { closeModals(); if(!apiConfig.key || !apiConfig.secret) { return; } showToast("⏳ Enviando Orden a Gate.io..."); const body = { "currency_pair": document.getElementById('trade-pair').textContent, "side": "buy", "amount": document.getElementById('trade-amount').textContent, "price": document.getElementById('trade-price').textContent, "type": "limit", "account": "spot", "time_in_force": "gtc" }; try { const result = await callGateApi("POST", "/spot/orders", body, true); if (result && result.id) { showToast(`✅ ORDEN EXITOSA ID: ${result.id}`, 4000, false, true); setTimeout(fetchWalletBalance, 1500); } else { throw new Error("Respuesta inválida de Gate.io"); } } catch (e) { console.warn("❌ Error creando orden:", e.message); showToast("⚠️ Error en Orden", 2000); } }
        function openLiquidateConfirm() { triggerHaptic(); const s = slots[activeIdx]; if(!s.name || s.price <= 0) return showToast("⚠️ Slot Vacío"); document.getElementById('confirmModal').style.display = 'flex'; }
        
        // ── Limpia visualmente el dashboard de un slot tras cerrar posición ──
        function _resetSlotDashboardUI(slotIdx) {
            const s = '-' + slotIdx;
            const set = (id, val) => { const el = document.getElementById(id); if (el) { el.textContent = val; el.style.color = ''; } };
            set('dashTradingCoin'  + s, '---');
            set('dashBaseDisplay' + s, '0.0000');
            set('resInv'          + s, '$0.00');
            set('resAvg'          + s, '0.0000');
            set('resTarget'       + s, '0.0000');
            set('dashLiveRoi'     + s, '—');
            set('dashLivePnlDol'  + s, '—');
            // BUG FIX: resetear color del coin correctamente (set() ya lo hace vía style.color='')
            const coinEl = document.getElementById('dashTradingCoin' + s);
            if (coinEl) coinEl.style.color = 'var(--text-tertiary)';
            // Resetear colores de celda PNL
            const pnlCell = document.getElementById('dashPnlCell' + s);
            if (pnlCell) { pnlCell.style.borderColor = ''; pnlCell.style.background = ''; }
            // BUG FIX: ocultar barra de recuperación completa (fill + pct también)
            const recRow = document.getElementById('dashRecRow' + s);
            if (recRow) recRow.style.display = 'none';
            const recFill = document.getElementById('dashRecFill' + s);
            if (recFill) recFill.style.width = '0%';
            const recPct = document.getElementById('dashRecPct' + s);
            if (recPct) recPct.textContent = '—';
            // Resetear barra PNL del Panel 3 si corresponde al slot activo
            if (parseInt(slotIdx) === activeIdx) {
                const p3Pct = document.getElementById('levelsPanelPnlPct');
                const p3Dol = document.getElementById('levelsPanelPnlDol');
                const p3Coin = document.getElementById('levelsPanelCoinLabel');
                if (p3Pct)  { p3Pct.textContent = '—'; p3Pct.style.color = ''; }
                if (p3Dol)  { p3Dol.textContent = '—'; p3Dol.style.color = ''; }
                if (p3Coin) { p3Coin.textContent = '---'; p3Coin.style.color = ''; }
            }
        }

        function executeRelease() { 
            triggerHaptic(); 
            closeModals(); 
            try { 
                const s = slots[activeIdx]; 
                const totalInv = parseFloat(document.getElementById('resInv-' + activeIdx).textContent.replace('$','')) || 0; 
                const avgPrice = parseFloat(document.getElementById('resAvg-' + activeIdx).textContent) || 0;
                const live = allGateETFs ? allGateETFs.find(t => t.currency_pair === s.name + '_USDT') : null;
                const exitPrice = (live && parseFloat(live.last) > 0) ? parseFloat(live.last) : avgPrice * (1 + (botConfig.tp1Pct||50)/100);
                const qty = avgPrice > 0 ? totalInv / avgPrice : 0;
                const grossExitValue = qty * exitPrice;
                const entryFee = totalInv * (exchangeFee / 100); 
                const exitFee = grossExitValue * (exchangeFee / 100); 
                const totalFees = entryFee + exitFee; 
                const grossProfit = grossExitValue - totalInv; 
                const netProfit = grossProfit - totalFees;
                const roiActual = avgPrice > 0 ? (((exitPrice - avgPrice) / avgPrice) * 100).toFixed(1) + '%' : '—';
                const logEntry = { date: _fmtDate(new Date()), time: _fmtTimeShort(new Date()), coin: s.name || 'S/N', strategy: s.strat.toUpperCase(), basePrice: s.price, avgPrice: avgPrice, exitPrice: exitPrice, qty: qty.toFixed(8), totalInv: totalInv.toFixed(2), profit: grossProfit.toFixed(2), netProfit: netProfit.toFixed(2), fees: totalFees.toFixed(2), roi: roiActual, levelsUsed: s.buys ? s.buys.length : 0, isSimulated: false, simulated: false }; 
                if(!history) history = []; 
                history.push(logEntry); 
                localStorage.setItem('c5x_history', JSON.stringify(history)); 
                renderHistory(); 
                const currentStrat = s.strat || 'normal'; 
                const currentCapital = strategyParams.normal.capital; 
                const closedSlotIdx = activeIdx; // guardar antes de sortSlots
                slots[activeIdx] = { name:'', price:0, capital: currentCapital, buys:[], strat: currentStrat, locked: true, note: '', alerted: false, multipleBuys: {}, rebuyCount: 0, rebuyOldSpent: 0, rebuyOldQty: 0 };
                setSlotMode(activeIdx, 'manual');
                updateTradingModeUI();
                delete trailingStopData[activeIdx];
                const releaseKeyPrefix = `s${activeIdx}_`;
                Object.keys(activeOrders).forEach(k => { if (k.startsWith(releaseKeyPrefix)) delete activeOrders[k]; });
                saveActiveOrders();
                // BUG FIX: limpiar objetivo de venta activo si pertenecía al slot cerrado
                if (activeSellTarget && activeSellTarget.slotIndex === closedSlotIdx) {
                    activeSellTarget = null;
                    localStorage.removeItem('c5x_sell_target');
                    const tSection = document.getElementById('targetSection-' + closedSlotIdx);
                    if (tSection) { tSection.style.borderColor = ''; tSection.style.background = ''; }
                }
                sortSlots();
                // BUG FIX: reconstruir el DOM del dashboard DESPUÉS de sortSlots() para que
                // los cards queden sincronizados con el nuevo orden del array slots[].
                // _resetSlotDashboardUI() sobre el índice viejo es insuficiente porque
                // sortSlots() puede mover ese slot a otro índice.
                renderAllDashboards();
                selectSlot(0);
                showToast(`✅ Cerrada. Neta: $${netProfit.toFixed(2)} (${roiActual})`); 
                switchView('log', false); 
                calculateGlobalStats(); 
            } catch(e) { showToast('❌ Error al liquidar'); } 
        }
        function updateBodyMode(n) { const r = document.querySelector(':root'); if(!n) { r.style.setProperty('--brand', '#3b82f6'); return; } if(n.includes('3S') || n.includes('5S') || n.endsWith('S')) { r.style.setProperty('--brand', 'var(--short)'); } else if (n.includes('3L') || n.includes('5L') || n.endsWith('L')) { r.style.setProperty('--brand', 'var(--long)'); } else { r.style.setProperty('--brand', '#3b82f6'); } }
        function renderHistory() { const grid = document.getElementById('logGrid'); if(!history || history.length === 0) { grid.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-secondary)">Sin registros</div>'; return; } grid.innerHTML = history.map(h => { const hasNet = h.netProfit !== undefined; const finalProfit = hasNet ? parseFloat(h.netProfit) : parseFloat(h.profit); const isWin = finalProfit >= 0; const nameColor = getCoinColor(h.coin); return `<div class="unified-card"><div class="u-index" style="color:var(--brand); border-color:var(--brand)">${h.coin.substring(0,3)}</div><div class="u-center"><div class="u-title" style="color:${nameColor}">${h.coin}</div><div class="u-sub">${h.date} - ${h.time}</div></div><div class="u-right"><div class="u-val-primary" style="color:${isWin?'var(--long)':'var(--short)'}">${isWin?'+':''}$${finalProfit.toFixed(2)}</div><div class="u-val-secondary">${hasNet ? 'NETO' : 'BRUTO'} ${h.roi}</div></div></div>`; }).reverse().join(''); }
        function triggerDriveBackup() {
            // ── FIX API KEYS EN BACKUP: sanitizar appConfig antes de exportar ──
            // Nunca incluir PIN (ni raw ni hash) ni API keys en el archivo de backup
            const safeConfig = Object.assign({}, appConfig);
            delete safeConfig.pin; // eliminar pin legacy si existiera
            // apiConfig (Gate.io key/secret) se excluye conscientemente del backup
            const dataStr = JSON.stringify({
                slots, history, tickerAssets, customMultipliers,
                etfFavorites, globalCapital,
                appConfig: safeConfig   // sin PIN
                // apiConfig: EXCLUIDO — credenciales nunca en backup
            });
            const blob = new Blob([dataStr], {type: "application/json"});
            const a = document.createElement('a');
            const date = new Date().toISOString().slice(0,10);
            a.href = URL.createObjectURL(blob);
            a.download = "5X_Backup.json";
            document.body.appendChild(a);
            a.click();
            localStorage.setItem('c5x_last_backup', Date.now());
            showToast("☁️ Archivo generado para Drive");
        }
        function checkAutoBackup() { const last = localStorage.getItem('c5x_last_backup'); const now = Date.now(); if(!last || (now - last > 2592000000)) { if(confirm("⚠️ Han pasado 30 días desde tu último respaldo. ¿Guardar en Drive ahora?")) { triggerDriveBackup(); } } }
        function openSecurity(cb) { secCallback = cb; document.getElementById('secInput').value = ''; document.getElementById('securityModal').style.display = 'flex'; }
        function closeModals() { document.querySelectorAll('.generic-modal').forEach(m => m.style.display = 'none'); }
        function clearAllActiveOrders() { if (confirm("¿Limpiar TODAS las órdenes activas?")) { activeOrders = {}; saveActiveOrders(); updateLevelsUI(); renderLevels(); showToast("✅ Órdenes limpiadas"); } }
        function save() { 
            // Guardar TODOS los slots de forma agresiva en localStorage
            try {
                localStorage.setItem('c5x_slots', JSON.stringify(slots));
                localStorage.setItem('c5x_slots_real', JSON.stringify(slots)); 
                localStorage.setItem('c5x_last_slot', activeIdx);
                
                // Guardar cada componente individual
                saveInvestmentValue();
                saveSlotsLevels();
                
                // Guardar backup adicional de buys y multipleBuys
                const buysBackup = {};
                const multipleBuysBackup = {};
                slots.forEach((s, idx) => {
                    if (s.buys && s.buys.length > 0) {
                        buysBackup[idx] = s.buys;
                    }
                    if (s.multipleBuys && Object.keys(s.multipleBuys).length > 0) {
                        multipleBuysBackup[idx] = s.multipleBuys;
                    }
                });
                localStorage.setItem('c5x_buys_backup', JSON.stringify(buysBackup));
                localStorage.setItem('c5x_multibuys_backup', JSON.stringify(multipleBuysBackup));
                
                console.log('✅ Guardado completo:', slots.map((s, i) => `Slot ${i+1}: ${s.name || 'vacío'}`));


            } catch (e) {
                console.error('❌ Error al guardar:', e);
            }
        }
        
        function saveInvestmentValue() {
            const s = slots[activeIdx];
            if (s && s.capital) {
                const investmentData = { slotIndex: activeIdx, capital: s.capital, timestamp: Date.now() };
                localStorage.setItem('c5x_investment_value', JSON.stringify(investmentData));
            }
        }
        
        function saveSlotsLevels() {
            const slotsData = slots.map((s, idx) => { 
                // Calcular y guardar el promedio actual
                let avgPrice = 0;
                let totalInv = 0;
                let totalQty = 0;
                
                for (let i = 0; i < 12; i++) {
                    const key = getOrderKey(idx, i);
                    if (activeOrders[key] && activeOrders[key].status === 'filled') {
                        totalInv += activeOrders[key].price * activeOrders[key].amount;
                        totalQty += activeOrders[key].amount;
                    } else if (s.buys && s.buys.includes(i)) {
                        const d = getLevelData(s, i);
                        totalInv += d.usd;
                        totalQty += d.qty;
                    }
                    if (s.multipleBuys && s.multipleBuys[i]) {
                        for (let buy of s.multipleBuys[i]) {
                            totalInv += buy.usd;
                            totalQty += buy.qty;
                        }
                    }
                }
                
                avgPrice = totalQty > 0 ? totalInv / totalQty : 0;
                
                return { 
                    index: idx, 
                    name: s.name, 
                    price: s.price, 
                    capital: s.capital, 
                    buys: s.buys || [], 
                    strat: s.strat, 
                    locked: s.locked, 
                    note: s.note || '', 
                    alerted: s.alerted || false,
                    avgPrice: avgPrice,
                    multipleBuys: s.multipleBuys || {},
                    rebuyCount: s.rebuyCount || 0,
                    rebuyOldSpent: s.rebuyOldSpent || 0,
                    rebuyOldQty: s.rebuyOldQty || 0
                }; 
            });
            localStorage.setItem('c5x_slots_levels_data', JSON.stringify(slotsData));
        }
        
        function loadInvestmentValue() {
            const saved = localStorage.getItem('c5x_investment_value');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    const s = slots[data.slotIndex];
                    if (s && data.capital) { s.capital = data.capital; }
                } catch(e) { console.warn("Error cargando valor de inversión:", e); }
            }
        }
        
        function loadSlotsLevels() {
            const saved = localStorage.getItem('c5x_slots_levels_data');
            if (saved) {
                try {
                    const slotsData = JSON.parse(saved);
                    slotsData.forEach(data => {
                        if (data.index >= 0 && data.index < slots.length) {
                            const s = slots[data.index];
                            if (data.buys) s.buys = data.buys;
                            if (data.price) s.price = data.price;
                            if (data.capital) s.capital = data.capital;
                            if (data.strat) s.strat = data.strat;
                            if (data.avgPrice) s.avgPrice = data.avgPrice;
                            if (data.multipleBuys) s.multipleBuys = data.multipleBuys;
                            // Migrar rebuyDone legacy → rebuyCount
                            if (typeof data.rebuyCount === 'number') {
                                s.rebuyCount    = data.rebuyCount;
                                s.rebuyOldSpent = data.rebuyOldSpent || 0;
                                s.rebuyOldQty   = data.rebuyOldQty   || 0;
                            } else if (data.rebuyDone) {
                                s.rebuyCount    = 1;
                                s.rebuyOldSpent = data.rebuyOldSpent || 0;
                                s.rebuyOldQty   = data.rebuyOldQty   || 0;
                            }
                        }
                    });
                } catch(e) { console.warn("Error cargando niveles de slots:", e); }
            }
            
            // Cargar backups adicionales de buys y multipleBuys
            try {
                const buysBackup = localStorage.getItem('c5x_buys_backup');
                if (buysBackup) {
                    const buysData = JSON.parse(buysBackup);
                    Object.keys(buysData).forEach(idx => {
                        const index = parseInt(idx);
                        if (index >= 0 && index < slots.length) {
                            slots[index].buys = buysData[idx];
                        }
                    });
                }
                
                const multipleBuysBackup = localStorage.getItem('c5x_multibuys_backup');
                if (multipleBuysBackup) {
                    const multiData = JSON.parse(multipleBuysBackup);
                    Object.keys(multiData).forEach(idx => {
                        const index = parseInt(idx);
                        if (index >= 0 && index < slots.length) {
                            slots[index].multipleBuys = multiData[idx];
                        }
                    });
                }
                
                console.log('✅ Slots cargados:', slots.map((s, i) => `Slot ${i+1}: ${s.name || 'vacío'} - Buys: ${s.buys?.length || 0}, MultiBuys: ${Object.keys(s.multipleBuys || {}).length}`));
            } catch(e) {
                console.warn("Error cargando backups:", e);
            }
        }
        function clearLogs() { openSecurity(() => { history = []; localStorage.setItem('c5x_history', JSON.stringify(history)); renderHistory(); calculateGlobalStats(); showToast("🗑️ Historial Borrado"); }); }
        function resetApp() { openSecurity(() => { localStorage.clear(); location.reload(); }); }
        function loadSettingsValues() { try { const s = slots[activeIdx]; const elCapNormal = document.getElementById('setCapitalNormal'); if(elCapNormal) elCapNormal.value = strategyParams.normal.capital; const elIncNormal = document.getElementById('setIncNormal'); if(elIncNormal) elIncNormal.value = strategyParams.normal.inc; const elDescNormal = document.getElementById('setDescNormal'); if(elDescNormal) elDescNormal.value = strategyParams.normal.desc; const elDDNormal = document.getElementById('setDDNormal'); if(elDDNormal) elDDNormal.value = strategyParams.normal.dd; const elGlobCap = document.getElementById('setGlobalCapital'); if(elGlobCap) elGlobCap.value = globalCapital; const elFee = document.getElementById('setFee'); if(elFee) elFee.value = exchangeFee; const elRadarLim = document.getElementById('setRadarLimit'); if(elRadarLim) elRadarLim.value = radarLimit; const elRadarSpd = document.getElementById('setRadarSpeed'); if(elRadarSpd) elRadarSpd.value = radarSpeed; const elTickSpd = document.getElementById('setTickerSpeed'); if(elTickSpd) elTickSpd.value = tickerSpeed; const elAutoAdj = document.getElementById('setAutoAdjustThreshold'); if(elAutoAdj) elAutoAdj.value = autoAdjustThreshold; const elMonLim = document.getElementById('setMonitorLimit'); if(elMonLim) elMonLim.value = monitorLimit; const elPass = document.getElementById('setNewPass'); if(elPass) elPass.value = ''; if(apiConfig.key) { const el = document.getElementById('apiKey'); if(el) el.placeholder = '●●●●●●●●' + apiConfig.key.slice(-4); el.value = ''; } if(apiConfig.secret) { const el2 = document.getElementById('apiSecret'); if(el2) el2.placeholder = '●●●●●●●●' + apiConfig.secret.slice(-4); el2.value = ''; } const grid = document.getElementById('multiGrid'); if(grid) { grid.innerHTML = customMultipliers.map((val, i) => `<div class="multi-item"><span class="multi-lbl">N${i+1}</span><input type="number" class="multi-inp" value="${val}" step="0.1"></div>`).join(''); } calcMonthlyPerformance(); loadSupabaseConfigUI(); loadBotConfigUI(); updateStratExitSummary();
                const _pi = document.getElementById('proxyUrlInput');
                if (_pi) _pi.value = localStorage.getItem('c5x_proxy_url') || ''; } catch(e) { console.warn("Error cargando ajustes", e); } }
        function calcMonthlyPerformance() { const now = new Date(); const currentMonth = now.getMonth(); const currentYear = now.getFullYear(); let monthlyProfit = 0; history.forEach(h => { const parts = h.date.split('/'); if(parts.length === 3) { const hDate = new Date(parts[2], parts[1]-1, parts[0]); if(hDate.getMonth() === currentMonth && hDate.getFullYear() === currentYear) { monthlyProfit += (h.netProfit !== undefined ? parseFloat(h.netProfit) : (parseFloat(h.profit) || 0)); } } }); let growth = (globalCapital > 0) ? (monthlyProfit / globalCapital) * 100 : 0; const el = document.getElementById('monthlyProfitDisplay'); el.innerHTML = `$${monthlyProfit.toFixed(2)} <span style="font-size:14px; color:${monthlyProfit>=0?'var(--long)':'var(--short)'}">(${growth.toFixed(2)}%)</span>`; }
        function verifyAndAddCoin() { const input = document.getElementById('newTickerCoin'); let val = input.value.trim().toUpperCase().replace('USDT',''); if(!val) return; tickerAssets.push(val); localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets)); input.value=''; renderTickerSettings(); showToast("✅ Agregada"); }
        function renderTickerSettings() { let html = ''; for(let i=0; i<12; i++) { let coin = tickerAssets[i] || ""; let cls = coin ? "filled" : ""; html += `<div class="multi-item ${cls}"><span class="multi-lbl">SLOT ${i+1}</span><input type="text" class="multi-inp" value="${coin.replace('USDT','')}" placeholder="---" onchange="updateTickerCoin(${i}, this.value)" oninput="forceCaps(this)" style="text-transform: uppercase;"></div>`; } document.getElementById('tickerChipsContainer').innerHTML = html; }
        function updateTickerCoin(index, value) { let val = value.toUpperCase().trim().replace('USDT',''); if (val) { tickerAssets[index] = val; } else { tickerAssets[index] = ""; } localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets)); showToast("✅ Ticker Actualizado"); }
        function removeTickerCoin(i) { tickerAssets.splice(i,1); localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets)); renderTickerSettings(); }
        function exportPDF() { if(history.length === 0) return showToast("⚠️ Sin Datos"); const { jsPDF } = window.jspdf; const doc = new jsPDF('l', 'mm', 'a4'); let totalProfit = 0; let totalInvested = 0; let wins = 0; history.forEach(h => { const inv = parseFloat(h.totalInv) || 0; const prof = (h.netProfit !== undefined ? parseFloat(h.netProfit) : parseFloat(h.profit)) || 0; totalInvested += inv; totalProfit += prof; if(prof > 0) wins++; }); const winRate = history.length > 0 ? ((wins / history.length) * 100).toFixed(1) : 0; doc.setFillColor(11, 14, 17); doc.rect(0, 0, 297, 25, 'F'); doc.setFont("helvetica", "bold"); doc.setFontSize(22); doc.setTextColor(59, 130, 246); doc.text("5X", 14, 16); doc.setFontSize(14); doc.setTextColor(255, 255, 255); doc.text("REPORTE PROFESIONAL", 40, 16); doc.setFillColor(245, 247, 250); doc.rect(14, 30, 270, 20, 'F'); doc.setFontSize(10); doc.setTextColor(80); doc.text("CAPITAL MOVIDO", 20, 38); doc.text("NET PROFIT", 90, 38); doc.text("WIN RATE", 160, 38); doc.text("TOTAL OPS", 230, 38); doc.setFontSize(14); doc.setTextColor(0); doc.text("$" + totalInvested.toFixed(2), 20, 46); doc.setTextColor(totalProfit >= 0 ? 14 : 200, totalProfit >= 0 ? 203 : 50, totalProfit >= 0 ? 129 : 50); doc.text((totalProfit>=0?'+':'') + "$" + totalProfit.toFixed(2), 90, 46); doc.setTextColor(0); doc.text(winRate + "%", 160, 46); doc.text(history.length.toString(), 230, 46); const bodyData = history.map(h => { const inv = parseFloat(h.totalInv) || 0; const prof = (h.netProfit !== undefined ? parseFloat(h.netProfit) : parseFloat(h.profit)) || 0; const avg = parseFloat(h.avgPrice) || 0; const exit = parseFloat(h.exitPrice) || 0; return [ h.date + '\n' + h.time, h.coin, '$' + (avg < 1 ? avg.toFixed(6) : avg.toFixed(2)), '$' + (exit < 1 ? exit.toFixed(6) : exit.toFixed(2)), '$' + inv.toFixed(2), (prof>=0?'+':'') + '$' + prof.toFixed(2), h.roi ]; }); doc.autoTable({ head: [['FECHA / HORA', 'ACTIVO', 'PRECIO ENT.', 'PRECIO SALIDA', 'INVERSIÓN', 'PNL NETO', 'ROI']], body: bodyData, startY: 58, theme: 'grid', styles: { fontSize: 9, cellPadding: 3, valign: 'middle', halign: 'center' }, headStyles: { fillColor: [21, 26, 33], textColor: 255, fontStyle: 'bold', halign: 'center' }, didParseCell: function(data) { if (data.section === 'body' && data.column.index === 5) { const raw = data.cell.raw; if(raw.startsWith('+')) data.cell.styles.textColor = [14, 203, 129]; else data.cell.styles.textColor = [246, 70, 93]; } } }); doc.save("5X_Pro_Report.pdf"); }
        function exportData() { const dataStr = JSON.stringify({ slots, history, tickerAssets, customMultipliers, etfFavorites, globalCapital, appConfig }); const blob = new Blob([dataStr], {type: "application/json"}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "5X_Backup.json"; document.body.appendChild(a); a.click(); }
        function importData(input) { const file = input.files[0]; if(!file) return; const reader = new FileReader(); reader.onload = function(e) { try { const data = JSON.parse(e.target.result); if(data.slots) slots = data.slots; if(data.history) history = data.history; if(data.customMultipliers) { customMultipliers = data.customMultipliers; localStorage.setItem('c5x_multipliers', JSON.stringify(customMultipliers)); } if(data.etfFavorites) { etfFavorites = data.etfFavorites; localStorage.setItem('c5x_etf_favorites', JSON.stringify(etfFavorites)); } if(data.globalCapital) { globalCapital = data.globalCapital; localStorage.setItem('c5x_global_capital', globalCapital); } if(data.appConfig) { appConfig = data.appConfig; localStorage.setItem('c5x_config', JSON.stringify(appConfig)); } save(); localStorage.setItem('c5x_history', JSON.stringify(history)); location.reload(); } catch(err) { showToast("❌ Error al leer archivo"); } }; reader.readAsText(file); }
        let serverTimeOffset = 0;
        
        // --- ⚠️ URL DEL SERVIDOR PROXY (CONFIGURAR AQUÍ) ⚠️ ---
        /* ════════════════════════════════════════════════════════════
           CÓDIGO PROXY — Servidor Node.js para Gate.io
           Si el proxy falla, despliega este código Node.js:

           // const functions = require('your-server-framework');
           const fetch     = require('node-fetch');
           const cors      = require('cors')({ origin: true });

           exports.gateproxy = functions.https.onRequest((req, res) => {
             cors(req, res, async () => {
               if (req.method === 'OPTIONS') {
                 res.set('Access-Control-Allow-Origin', process.env.ALLOWED_ORIGIN || 'https://TU_DOMINIO_AQUI'); // FIX: NO wildcard
                 res.set('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
                 res.set('Access-Control-Allow-Headers',
                   'Content-Type,Accept,KEY,Timestamp,SIGN,X-Client');
                 return res.status(204).send('');
               }
               res.set('Access-Control-Allow-Origin', process.env.ALLOWED_ORIGIN || 'https://TU_DOMINIO_AQUI'); // FIX: NO wildcard
               const endpoint = req.query.endpoint;
               if (!endpoint) return res.status(400).json({error:'missing endpoint'});

               // Separar query params de negocio del param 'endpoint'
               const biz = { ...req.query };
               delete biz.endpoint;
               const qs = new URLSearchParams(biz).toString();
               const target = 'https://api.gateio.ws/api/v4' + endpoint + (qs ? '?' + qs : '');

               const headers = {
                 'Content-Type': 'application/json',
                 'Accept':       'application/json',
               };
               // Reenviar headers de autenticación
               ['KEY','Timestamp','SIGN'].forEach(h => {
                 if (req.headers[h.toLowerCase()]) headers[h] = req.headers[h.toLowerCase()];
               });

               try {
                 const upstream = await fetch(target, {
                   method:  req.method,
                   headers: headers,
                   body:    req.method === 'POST' ? JSON.stringify(req.body) : undefined,
                   timeout: 10000
                 });
                 const data = await upstream.json();
                 return res.status(upstream.status).json(data);
               } catch(e) {
                 return res.status(502).json({ error: e.message });
               }
             });
           });
        ════════════════════════════════════════════════════════════ */

                // Proxy URL: global, lee de localStorage (configurable en Ajustes)
                let GATE_PROXY_URL = localStorage.getItem('c5x_proxy_url') || '';
        // ── Prefijo de ruta requerido por Gate.io en la firma HMAC ──
        const GATE_API_PREFIX = "/api/v4";
        // Timeout para cada request al proxy (ms)
        const PROXY_TIMEOUT_MS = 12000;

        // ── API PÚBLICA Gate.io — llamada directa sin proxy ──────────
        // Gate.io permite CORS en endpoints públicos (tickers, time, currency_pairs)
        // El radar y ETF monitor usan esta función — NO necesitan proxy
        // ── API PÚBLICA Gate.io — siempre via proxy Supabase ──────────
        async function callGatePublic(endpoint, params = {}, _retry = 0) {
            const proxyBase = localStorage.getItem('c5x_proxy_url') || GATE_PROXY_URL || '';
            let url;
            if (proxyBase) {
                url = proxyBase + '?endpoint=' + encodeURIComponent(endpoint);
                if (Object.keys(params).length > 0) url += '&' + new URLSearchParams(params).toString();
            } else {
                url = 'https://api.gateio.ws/api/v4' + endpoint;
                if (Object.keys(params).length > 0) url += '?' + new URLSearchParams(params).toString();
            }
            const ctrl = new AbortController();
            const tid  = setTimeout(() => ctrl.abort(), 12000);
            try {
                const res = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' }, signal: ctrl.signal });
                clearTimeout(tid);
                if (!res.ok) throw new Error('HTTP ' + res.status);
                return await res.json();
            } catch(e) {
                clearTimeout(tid);
                if (_retry < 2) { await new Promise(r => setTimeout(r, 1500 * (_retry + 1))); return callGatePublic(endpoint, params, _retry + 1); }
                throw e;
            }
        }

        // ── FIX RATE LIMIT: contador de requests con throttle automático ──
        const _apiRateLimit = {
            maxPerMin:  60,          // máximo de llamadas por ventana de 60s
            windowMs:   60 * 1000,
            timestamps: [],          // timestamps de las últimas N llamadas
            async throttle() {
                const now = Date.now();
                // Eliminar timestamps fuera de la ventana actual
                this.timestamps = this.timestamps.filter(t => now - t < this.windowMs);
                if (this.timestamps.length >= this.maxPerMin) {
                    // Calcular cuánto esperar hasta que quede hueco en la ventana
                    const oldest  = this.timestamps[0];
                    const waitMs  = this.windowMs - (now - oldest) + 50;
                    console.warn(`[RateLimit] ${this.timestamps.length}/${this.maxPerMin} req/min — esperando ${waitMs}ms`);
                    await new Promise(r => setTimeout(r, waitMs));
                    // Limpiar de nuevo tras la espera
                    this.timestamps = this.timestamps.filter(t => Date.now() - t < this.windowMs);
                }
                this.timestamps.push(Date.now());
            }
        };

        async function callGateApi(method, endpoint, params = {}, requireAuth = false, _retryCount = 0) {
            // ── BUG FIX #1: Pasar el endpoint como param dedicado y
            //    los query-params de negocio como param separado,
            //    para que el proxy Cloud Run los separe correctamente. ──
            // ── FIX RATE LIMIT: aplicar throttle antes de cada llamada ──
            if (_retryCount === 0) await _apiRateLimit.throttle();
            let url = `${GATE_PROXY_URL}?endpoint=${encodeURIComponent(endpoint)}`;
            const headers = {
                'Accept':       'application/json',
                'Content-Type': 'application/json',
                'X-Client':     '5X-App'          // header de identificación
            };

            // Para GET: añadir params de negocio a la URL proxy
            let queryString = '';
            if (method === 'GET' && Object.keys(params).length > 0) {
                queryString = new URLSearchParams(params).toString();
                url += '&' + queryString;
            }

            if (requireAuth) {
                if (!apiConfig.key || !apiConfig.secret) {
                    showToast("❌ Configura API Keys en Ajustes");
                    return null;
                }
                const timestamp   = Math.floor((Date.now() + serverTimeOffset) / 1000);

                // ── BUG FIX #2 CRÍTICO: la firma Gate.io requiere la ruta COMPLETA
                //    incluyendo el prefijo /api/v4. Sin esto Gate.io devuelve 401. ──
                const signPath    = GATE_API_PREFIX + endpoint;

                // Para POST: hashear el body exacto que se enviará
                const bodyPayload = (method === 'POST' && Object.keys(params).length > 0)
                                      ? JSON.stringify(params)
                                      : '';
                const hashedPayload = CryptoJS.SHA512(bodyPayload).toString();

                // queryForSign solo aplica a GET con params
                const queryForSign = (method === 'GET') ? queryString : '';

                const signString = `${method}\n${signPath}\n${queryForSign}\n${hashedPayload}\n${timestamp}`;
                const signature  = CryptoJS.HmacSHA512(signString, apiConfig.secret).toString();

                headers['KEY']       = apiConfig.key;
                headers['Timestamp'] = String(timestamp);
                headers['SIGN']      = signature;

                // Debug de firma (solo en modo desarrollo — quitar en producción)
                if (_retryCount === 0) {
                    console.debug(`[GateSign] ${method} ${signPath} | ts=${timestamp} | qs="${queryForSign}" | body="${bodyPayload.slice(0,60)}"`);
                }
            }

            // ── BUG FIX #3: AbortController para timeout ──
            const controller = new AbortController();
            const timeoutId  = setTimeout(() => controller.abort(), PROXY_TIMEOUT_MS);

            try {
                const response = await fetch(url, {
                    method:  method,
                    headers: headers,
                    body:    (method === 'POST' && Object.keys(params).length > 0)
                               ? JSON.stringify(params)
                               : undefined,
                    signal:  controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    const errText = await response.text().catch(() => response.statusText);
                    // ── BUG FIX #4: log detallado del error HTTP ──
                    console.warn(`[GateAPI] HTTP ${response.status} ${method} ${endpoint}:`, errText);
                    // No reintentar en errores de autenticación/autorización
                    if (response.status === 401 || response.status === 403) {
                        throw new Error(`AUTH_ERROR ${response.status}: ${errText}`);
                    }
                    // No reintentar en errores de cliente (bad request)
                    if (response.status >= 400 && response.status < 500) {
                        throw new Error(`CLIENT_ERROR ${response.status}: ${errText}`);
                    }
                    // Reintentar en errores de servidor (5xx) y cold-start
                    if (_retryCount < 2) {
                        await new Promise(r => setTimeout(r, 2500 * (_retryCount + 1)));
                        return callGateApi(method, endpoint, params, requireAuth, _retryCount + 1);
                    }
                    throw new Error(`SERVER_ERROR ${response.status}: ${errText}`);
                }

                const data = await response.json();
                return data;

            } catch (err) {
                clearTimeout(timeoutId);
                if (err.name === 'AbortError') {
                    console.warn(`[GateAPI] Timeout (${PROXY_TIMEOUT_MS}ms) ${method} ${endpoint}`);
                    if (_retryCount < 1) {
                        // Solo 1 reintento en timeout (el proxy puede estar en cold start)
                        await new Promise(r => setTimeout(r, 3000));
                        return callGateApi(method, endpoint, params, requireAuth, _retryCount + 1);
                    }
                    throw new Error(`TIMEOUT: El proxy no respondió en ${PROXY_TIMEOUT_MS/1000}s`);
                }
                // Retry en errores de red (cold start Cloud Run, CORS preflight)
                if (_retryCount < 2 && (err.name === 'TypeError' || err.message.includes('fetch') || err.message.includes('network'))) {
                    console.warn(`[GateAPI] Network error retry ${_retryCount + 1}:`, err.message);
                    await new Promise(r => setTimeout(r, 2500 * (_retryCount + 1)));
                    return callGateApi(method, endpoint, params, requireAuth, _retryCount + 1);
                }
                console.warn(`[GateAPI] Error final ${method} ${endpoint}:`, err.message);
                // Re-lanzar para que los llamadores puedan ver el error real
                throw err;
            }
        }
        // ── BUG FIX #10: syncTimeAndBalance mejorado
        //    Sincroniza el timestamp con Gate.io para que la firma HMAC no falle
        //    por diferencia de reloj (Gate.io rechaza si diff > 60s). ──
        async function syncTimeAndBalance() {
            try {
                const start   = Date.now();
                const res     = await callGatePublic("/spot/time");
                if (res && res.server_time) {
                    // BUG FIX CRÍTICO: Gate.io server_time ya está en ms — NO multiplicar por 1000
                    const serverMs   = res.server_time; // ya es Unix ms
                    const rtt        = Date.now() - start;
                    serverTimeOffset = serverMs - (start + rtt / 2);
                    console.log(`✅ Hora sincronizada con Gate.io | offset=${serverTimeOffset > 0 ? '+' : ''}${serverTimeOffset}ms`);
                }
            } catch(e) {
                console.warn("⚠️ Time sync fail (usando reloj local):", e.message);
            }
            fetchWalletBalance();
        }

        // ══ SINCRONIZACIÓN COMPLETA CON GATE.IO ══
        // Sincroniza: tiempo, balance USDT, cuentas spot, órdenes abiertas reales vs. locales
        let lastFullSyncTime = 0;
        let fullSyncInterval = null;

        async function fullSyncGateAccount(silent = false) {
            if (!apiConfig.key || !apiConfig.secret) return;
            try {
                if (!silent) showToast("🔄 Sincronizando con Gate.io...", 1500);

                // 1. Sincronizar tiempo con Gate.io
                const start = Date.now();
                const timeRes = await callGatePublic("/spot/time");
                if (timeRes && timeRes.server_time) {
                    // Gate.io server_time ya en ms
                    const serverTime = timeRes.server_time;
                    serverTimeOffset = serverTime - (start + ((Date.now() - start) / 2));
                }

                // 2. Obtener todas las cuentas spot (balance real)
                const allAccounts = await callGateApi("GET", "/spot/accounts", {}, true);
                if (allAccounts && Array.isArray(allAccounts)) {
                    const usdtRow = allAccounts.find(a => a.currency === 'USDT');
                    if (usdtRow) {
                        const usdtAvailable = parseFloat(usdtRow.available);
                        globalCapital = usdtAvailable;
                        availableUSDT = usdtAvailable;
                        localStorage.setItem('c5x_global_capital', globalCapital);
                        const elCap = document.getElementById('setGlobalCapital');
                        if (elCap) elCap.value = usdtAvailable.toFixed(2);
                        const totalBalanceEl = document.getElementById('totalBalanceDisplay');
                        if (totalBalanceEl) totalBalanceEl.textContent = "$" + usdtAvailable.toFixed(2);
                    }
                }

                // 3. Obtener órdenes abiertas reales en Gate.io y reconciliar con activeOrders local
                // Para cada slot activo, verificamos las órdenes
                let anyChange = false;
                for (let slotIdx = 0; slotIdx < slots.length; slotIdx++) {
                    const slot = slots[slotIdx];
                    if (!slot || !slot.name) continue;
                    const symbol = slot.name.toUpperCase() + '_USDT';
                    try {
                        // Obtener órdenes abiertas reales del par
                        const openOrders = await callGateApi("GET", "/spot/orders", { currency_pair: symbol, status: 'open' }, true);
                        if (!openOrders || !Array.isArray(openOrders)) continue;
                        const openOrderIds = new Set(openOrders.map(o => String(o.id)));

                        // Verificar cada orden activa local para este slot
                        const limit = customMultipliers.length || 12;
                        for (let lvl = 0; lvl < limit; lvl++) {
                            const key = getOrderKey(slotIdx, lvl);
                            const localOrder = activeOrders[key];
                            if (!localOrder || localOrder.simulated) continue;
                            if (localOrder.status === 'open' && localOrder.orderId) {
                                const ordId = String(localOrder.orderId);
                                if (!openOrderIds.has(ordId)) {
                                    // La orden ya no está abierta en Gate.io — verificar estado real
                                    const realStatus = await callGateApi("GET", `/spot/orders/${ordId}`, { currency_pair: symbol }, true);
                                    if (realStatus) {
                                        if (realStatus.status === 'closed' || realStatus.filled_total > 0) {
                                            activeOrders[key].status = 'filled';
                                            activeOrders[key].filledTime = Date.now();
                                            if (realStatus.avg_deal_price && parseFloat(realStatus.avg_deal_price) > 0) {
                                                activeOrders[key].price = parseFloat(realStatus.avg_deal_price);
                                            }
                                            if (realStatus.amount) {
                                                activeOrders[key].amount = parseFloat(realStatus.amount);
                                            }
                                            anyChange = true;
                                        } else if (realStatus.status === 'cancelled') {
                                            delete activeOrders[key];
                                            anyChange = true;
                                        }
                                    }
                                }
                            }
                        }
                    } catch(e) { /* Continuar con el siguiente slot */ }
                }

                if (anyChange) {
                    saveActiveOrders();
                    renderLevels();
                    for (let i = 0; i < 10; i++) { updateDashboardStatsForSlot(i); updateDashRecovery(i); }
                    refreshAllDashboardData();
                }

                // 4. Actualizar dashboard Gate.io con datos frescos
                if (typeof refreshGateDashboard === 'function') refreshGateDashboard();
                if (typeof renderAllDashboards === 'function') renderAllDashboards();

                lastFullSyncTime = Date.now();
                updateSyncTimestamp();
                setGdConnection(true);
                if (!silent) showToast("✅ Sincronizado con Gate.io", 2000);
                console.log("✅ fullSyncGateAccount completado");

            } catch(e) {
                console.warn("⚠️ Error en fullSyncGateAccount:", e);
                setGdConnection(false);
            }
        }

        function updateSyncTimestamp() {
            const el = document.getElementById('gdUpdateTime');
            if (el) el.textContent = _fmtTime(new Date());
        }

        function startFullSyncSchedule() {
            if (!apiConfig.key || !apiConfig.secret) return;
            // Sync inmediato al arrancar
            fullSyncGateAccount(true);
            // Sync periódico cada 60s (reconcilia órdenes + balance)
            if (fullSyncInterval) clearInterval(fullSyncInterval);
            fullSyncInterval = setInterval(() => { fullSyncGateAccount(true); }, 60000);
        }
        // ── testApiConnection — diagnóstico completo con raw error bodies ──
        async function testApiConnection() {
            const resultDiv = document.getElementById('apiTestResult');
            if (!resultDiv) return;
            const log = (msg) => { resultDiv.innerHTML += msg + '<br>'; resultDiv.scrollTop = resultDiv.scrollHeight; };

            resultDiv.innerHTML = '';
            log('⏳ Iniciando diagnóstico completo...');
            log(`📌 Proxy: <b>${GATE_PROXY_URL}</b>`);
            log(`📌 Timestamp local: ${Math.floor(Date.now()/1000)} | serverOffset: ${serverTimeOffset}ms`);
            log('');

            // ── TEST 0: Ping al proxy ──
            log('🔌 TEST 0: Alcanzabilidad del proxy Cloud Run');
            try {
                const t0 = Date.now();
                const r = await fetch(GATE_PROXY_URL + '?endpoint=/spot/time', { method: 'GET', signal: AbortSignal.timeout(10000) });
                log(`&nbsp;&nbsp;HTTP ${r.status} en ${Date.now()-t0}ms — ${r.ok ? '✅ Proxy alcanzable' : '⚠️ Proxy con error'}`);
                if (!r.ok) { const txt = await r.text().catch(()=>''); log(`&nbsp;&nbsp;Body: ${txt.slice(0,200)}`); }
            } catch(e) {
                log(`&nbsp;&nbsp;❌ ${e.name === 'AbortError' ? 'TIMEOUT 10s' : e.name + ': ' + e.message}`);
            }
            log('');

            // ── TEST 1: Tiempo Gate.io (público) ──
            log('📡 TEST 1: Tiempo Gate.io (/spot/time)');
            try {
                const t1 = Date.now();
                const r = await fetch(`${GATE_PROXY_URL}?endpoint=/spot/time`, { signal: AbortSignal.timeout(12000) });
                const data = await r.json();
                const ms = Date.now()-t1;
                if (data && data.server_time) {
                    serverTimeOffset = data.server_time - Date.now();
                    log(`&nbsp;&nbsp;✅ OK (${ms}ms) — Hora: ${_fmtTime(new Date(data.server_time))} | offset: ${serverTimeOffset > 0 ? '+' : ''}${serverTimeOffset}ms`);
                } else {
                    log(`&nbsp;&nbsp;❌ Respuesta inesperada: ${JSON.stringify(data).slice(0,100)}`);
                }
            } catch(e) { log(`&nbsp;&nbsp;❌ ${e.message}`); }
            log('');

            // ── TEST 2: Tickers (público) ──
            log('📊 TEST 2: Tickers públicos (/spot/tickers)');
            try {
                const t2 = Date.now();
                const r = await fetch(`${GATE_PROXY_URL}?endpoint=/spot/tickers`, { signal: AbortSignal.timeout(15000) });
                const data = await r.json();
                const ms = Date.now()-t2;
                if (Array.isArray(data)) {
                    const btc = data.find(t => t.currency_pair === 'BTC_USDT');
                    log(`&nbsp;&nbsp;✅ OK (${ms}ms) — ${data.length} pares${btc ? ' | BTC: $' + parseFloat(btc.last).toLocaleString() : ''}`);
                } else {
                    log(`&nbsp;&nbsp;❌ Respuesta: ${JSON.stringify(data).slice(0,100)}`);
                }
            } catch(e) { log(`&nbsp;&nbsp;❌ ${e.message}`); }
            log('');

            if (!apiConfig.key || !apiConfig.secret) {
                log('⚠️ TESTS 3-5 OMITIDOS — No hay API Keys configuradas');
                log('&nbsp;&nbsp;→ Ve a Ajustes → API Keys e ingresa tu Key y Secret de Gate.io');
                log('');
                log('✅ Diagnóstico completo (sin auth)');
                return;
            }

            log(`🔑 API Key cargada: ●●●●●●●●${apiConfig.key.slice(-4)}`);
            log('');

            // Función auxiliar: build auth headers manualmente con cualquier signPath
            async function buildAuthHeaders(method, signPath, queryString, bodyPayload) {
                const timestamp   = Math.floor((Date.now() + serverTimeOffset) / 1000);
                const hashedBody  = CryptoJS.SHA512(bodyPayload || '').toString();
                const signString  = `${method}\n${signPath}\n${queryString || ''}\n${hashedBody}\n${timestamp}`;
                const signature   = CryptoJS.HmacSHA512(signString, apiConfig.secret).toString();
                return {
                    'Accept': 'application/json', 'Content-Type': 'application/json',
                    'KEY': apiConfig.key, 'Timestamp': String(timestamp), 'SIGN': signature,
                    '_signString': signString  // para debug
                };
            }

            // Función auxiliar: raw fetch con auth + muestra el error real
            async function rawAuthTest(label, proxyUrl, signPath, queryString) {
                log(`🔐 ${label}`);
                log(`&nbsp;&nbsp;signPath = <b>${signPath}</b>`);
                try {
                    const h = await buildAuthHeaders('GET', signPath, queryString, '');
                    const signStr = h['_signString'];
                    delete h['_signString'];
                    log(`&nbsp;&nbsp;signString = <code>${signStr.replace(/\n/g,'\\n').slice(0,80)}...</code>`);
                    const t = Date.now();
                    const r = await fetch(proxyUrl, { method: 'GET', headers: h, signal: AbortSignal.timeout(12000) });
                    const ms = Date.now()-t;
                    const body = await r.text();
                    let parsed = null; try { parsed = JSON.parse(body); } catch(e) {}

                    log(`&nbsp;&nbsp;HTTP ${r.status} (${ms}ms)`);

                    if (r.ok && parsed && Array.isArray(parsed)) {
                        const usdt = parsed.find(a => a.currency === 'USDT');
                        log(`&nbsp;&nbsp;✅ ¡ÉXITO! ${parsed.length} cuentas${usdt ? ' | USDT: $' + parseFloat(usdt.available).toFixed(2) : ''}`);
                        return true;
                    } else if (r.ok) {
                        log(`&nbsp;&nbsp;✅ OK — Body: ${body.slice(0,100)}`);
                        return true;
                    } else {
                        // Mostrar el error REAL de Gate.io
                        const errLabel = (parsed && parsed.label) ? parsed.label : '';
                        const errMsg   = (parsed && parsed.message) ? parsed.message : body.slice(0,120);
                        log(`&nbsp;&nbsp;❌ ${r.status} | label: <b>${errLabel || 'N/A'}</b> | msg: ${errMsg}`);
                        if (errLabel === 'INVALID_SIGNATURE' || errLabel === 'SIGN_MISMATCH') {
                            log(`&nbsp;&nbsp;💡 Firma incorrecta — probablemente el signPath tiene que cambiar`);
                        } else if (errLabel === 'INVALID_KEY') {
                            log(`&nbsp;&nbsp;💡 API Key no válida — verifica que copiaste correctamente Key y Secret`);
                        } else if (errLabel === 'IP_FORBIDDEN' || errLabel === 'IP_BANNED') {
                            log(`&nbsp;&nbsp;💡 <b>IP del proxy no autorizada</b> — en Gate.io deshabilita restricción de IP en tu API Key`);
                        } else if (errLabel === 'KEY_EXPIRED') {
                            log(`&nbsp;&nbsp;💡 API Key expirada — crea una nueva en Gate.io`);
                        } else if (!errLabel) {
                            log(`&nbsp;&nbsp;Body raw: ${body.slice(0,150)}`);
                        }
                        return false;
                    }
                } catch(e) {
                    log(`&nbsp;&nbsp;❌ Excepción: ${e.message}`);
                    return false;
                }
            }

            // ── TEST 3a: Con /api/v4 en el signPath (correcto según docs) ──
            const proxyUrl3a = `${GATE_PROXY_URL}?endpoint=/spot/accounts&currency=USDT`;
            const ok3a = await rawAuthTest(
                'TEST 3a: Balance USDT — signPath CON /api/v4',
                proxyUrl3a,
                '/api/v4/spot/accounts',
                'currency=USDT'
            );
            log('');

            // ── TEST 3b: Sin /api/v4 en el signPath (por si el proxy lo espera así) ──
            const ok3b = await rawAuthTest(
                'TEST 3b: Balance USDT — signPath SIN /api/v4',
                proxyUrl3a,
                '/spot/accounts',
                'currency=USDT'
            );
            log('');

            // ── TEST 4: Cuentas completas (con el signPath que funcionó) ──
            if (ok3a || ok3b) {
                const workingPath = ok3a ? '/api/v4/spot/accounts' : '/spot/accounts';
                log(`✅ signPath correcto: <b>${workingPath}</b>`);
                log('');
                const ok4 = await rawAuthTest(
                    'TEST 4: Cuentas Spot completas',
                    `${GATE_PROXY_URL}?endpoint=/spot/accounts`,
                    workingPath,
                    ''
                );
                log('');
            }

            log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            log('✅ Diagnóstico completo');
            if (lastFullSyncTime > 0) log(`Último sync exitoso: ${_fmtTime(new Date(lastFullSyncTime))}`);
            resultDiv.scrollTop = resultDiv.scrollHeight;
        }
        function clearCrashMemory() { localStorage.removeItem('c5x_crash_alerts'); showToast("✅ Memoria de alertas borrada"); }
        let gateCheckInterval = null; let gateConnected = false;
        async function checkGateConnectionStatus() { try { const res = await callGatePublic("/spot/time"); updateGateIndicator(res && res.server_time); } catch(e) { updateGateIndicator(false); } }
        function updateGateIndicator(isConnected) { gateConnected = isConnected; const modeBtn = document.getElementById('modeToggleBtn'); if (modeBtn && modeBtn.classList.contains('real')) { if (isConnected) { modeBtn.classList.remove('disconnected'); } else { modeBtn.classList.add('disconnected'); } } }
        function startGateMonitoring() { checkGateConnectionStatus(); if (gateCheckInterval) clearInterval(gateCheckInterval); gateCheckInterval = setInterval(checkGateConnectionStatus, 15000); }
        
        // ════════════════════════════════════════════════════════
        //  GATE.IO COMMAND DASHBOARD — PANEL 3
        // ════════════════════════════════════════════════════════
        const GD_ASSETS = [
            { sym: 'BTC',  name: 'Bitcoin',  pair: 'BTC_USDT'  },
            { sym: 'ETH',  name: 'Ethereum', pair: 'ETH_USDT'  },
            { sym: 'SUI',  name: 'Sui',      pair: 'SUI_USDT'  },
            { sym: 'AVAX', name: 'Avalanche',pair: 'AVAX_USDT' },
            { sym: 'BNB',  name: 'BNB',      pair: 'BNB_USDT'  },
        ];
        let gdTickerIdx   = 0;
        let gdTickerTimer = null;
        let gdProgressTimer = null;
        let gdMarketData  = {};          // { BTC: { price, change }, ... }
        let gdRefreshInterval = null;
        const GD_TICKER_SECS = 10;      // segundos por asset

        // ── Punto de entrada: se llama al activar panel 2 ──
        async function initGateDashboard() {
            renderGdDualBar();
            calcGdStats();
            await refreshGateDashboard();
            if (!gdRefreshInterval) {
                gdRefreshInterval = setInterval(refreshGateDashboard, 30000);
            }
            // Inicializar progress bar visual (se resetea en cada masterTick)
            startGdProgressBar();
        }

        async function refreshGateDashboard() {
            // 1. Verificar conexión (endpoint público)
            try {
                const timeRes = await callGatePublic('/spot/time');
                const isConn  = !!(timeRes && timeRes.server_time);
                setGdConnection(isConn);

                if (isConn) {
                    // 2. Obtener precios del mercado (público)
                    const tickersRaw = await callGatePublic('/spot/tickers');
                    if (Array.isArray(tickersRaw)) {
                        GD_ASSETS.forEach(a => {
                            const row = tickersRaw.find(t => t.currency_pair === a.pair);
                            if (row) {
                                gdMarketData[a.sym] = {
                                    price:  parseFloat(row.last),
                                    change: parseFloat(row.change_percentage)
                                };
                            }
                        });
                        updateGdEquivalencias();
                        updateGdMarketCard();
                    }

                    // 3. Balance (si hay API keys)
                    if (apiConfig.key && apiConfig.secret) {
                        const allAccounts = await callGateApi('GET', '/spot/accounts', {}, true);
                        if (Array.isArray(allAccounts)) {
                            // USDT disponible
                            const usdtRow = allAccounts.find(a => a.currency === 'USDT');
                            const libre   = usdtRow ? parseFloat(usdtRow.available) : 0;

                            // Calcular valor total en USDT de TODOS los activos
                            // Usa allGateETFs que tiene TODOS los tickers incluyendo ETFs apalancados
                            let totalUSD = libre + (parseFloat(usdtRow?.locked) || 0);
                            allAccounts.forEach(acc => {
                                if (acc.currency === 'USDT') return; // ya contado
                                const qty = parseFloat(acc.available) + parseFloat(acc.locked || 0);
                                if (qty <= 0) return;
                                // Buscar precio: primero en allGateETFs (más completo), luego gdMarketData
                                let price = 0;
                                const etfTicker = allGateETFs && allGateETFs.find(t => t.currency_pair === acc.currency + '_USDT');
                                if (etfTicker) {
                                    price = parseFloat(etfTicker.last);
                                } else if (gdMarketData[acc.currency]) {
                                    price = gdMarketData[acc.currency].price;
                                }
                                if (price > 0) totalUSD += qty * price;
                            });

                            // Guardar caché persistente
                            if (totalUSD > 1) {
                                localStorage.setItem('c5x_cached_total', totalUSD.toFixed(2));
                                localStorage.setItem('c5x_cached_libre', libre.toFixed(2));
                            }
                            updateGdMetrics(totalUSD, libre);
                        }
                    } else {
                        // Sin API keys: usar caché si existe, si no calcular con slots
                        const cachedTotal = parseFloat(localStorage.getItem('c5x_cached_total') || '0');
                        const cachedLibre = parseFloat(localStorage.getItem('c5x_cached_libre') || '0');
                        if (cachedTotal > 1) {
                            updateGdMetrics(cachedTotal, cachedLibre);
                        } else {
                            const libre   = availableUSDT || globalCapital;
                            const enUso   = calcGdEnUso();
                            const total   = libre + enUso;
                            updateGdMetrics(total, libre);
                        }
                    }
                } else {
                    // Sin conexión: mostrar último valor cacheado, no sobreescribir con $1
                    const cachedTotal = parseFloat(localStorage.getItem('c5x_cached_total') || '0');
                    const cachedLibre = parseFloat(localStorage.getItem('c5x_cached_libre') || '0');
                    if (cachedTotal > 1) {
                        updateGdMetrics(cachedTotal, cachedLibre);
                    } else {
                        const libre = globalCapital;
                        updateGdMetrics(libre, libre);
                    }
                }
            } catch(e) {
                setGdConnection(false);
            }

            // Timestamp de última actualización
            const now = new Date();
            const ts  = _fmtTime(now);
            const el  = document.getElementById('gdUpdateTime');
            if (el) el.textContent = ts;

            calcGdStats();
            renderGdDualBar();
        }

        function setGdConnection(isConn) {
            const dot   = document.getElementById('gdConnDot');
            const label = document.getElementById('gdConnLabel');
            if (!dot || !label) return;
            if (isConn) {
                dot.classList.add('connected');
                label.textContent = 'CONECTADO';
                label.classList.add('connected');
            } else {
                dot.classList.remove('connected');
                label.textContent = apiConfig.key ? 'SIN SEÑAL' : 'SIN API KEY';
                label.classList.remove('connected');
            }
        }

        function calcGdEnUso() {
            let enUso = 0;
            slots.forEach(s => {
                if (!s.name) return;
                const params = getStrategyParams ? getStrategyParams(s.strat) : { capital: s.capital || 5 };
                s.buys && s.buys.forEach(lvl => {
                    const data = getLevelData ? getLevelData(s, lvl) : { usd: params.capital };
                    enUso += data.usd || 0;
                });
                if (s.multipleBuys) {
                    Object.values(s.multipleBuys).forEach(arr => {
                        if (Array.isArray(arr)) arr.forEach(b => { enUso += b.usd || 0; });
                    });
                }
            });
            return enUso;
        }

        function updateGdMetrics(total, libre) {
            const enUso    = Math.max(0, total - libre);
            const librePct = total > 0 ? ((libre / total) * 100).toFixed(0) : 0;
            const btcPrice = gdMarketData.BTC ? gdMarketData.BTC.price : 0;

            const fmtUSD = v => '$' + v.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

            const activeSlots = slots.filter(s => s.name).length;

            // Guardar en caché para mostrar inmediatamente al refrescar
            if (total > 0) {
                localStorage.setItem('c5x_cached_total', total.toFixed(2));
                localStorage.setItem('c5x_cached_libre', libre.toFixed(2));
            }

            setGdEl('gdTotal',  fmtUSD(total));
            setGdEl('gdLibre',  fmtUSD(libre));
            setGdEl('gdEnUso',  fmtUSD(enUso));
            setGdEl('gdLibrePct',  librePct + '% disponible');
            setGdEl('gdSlotCount', activeSlots + (activeSlots === 1 ? ' slot activo' : ' slots activos'));
            setGdEl('gdTotalBTC',  btcPrice > 0 ? '≈ ' + (total / btcPrice).toFixed(6) + ' BTC' : '—');

            // Guardar libre para equivalencias
            updateGdEquivalencias(total);
        }

        function updateGdEquivalencias(usdAmount) {
            // Los datos ya están en gdMarketData; renderGdDualBar los consume.
            // Aquí solo actualizamos el sub-texto del TOTAL en BTC.
            const btcPrice = gdMarketData.BTC ? gdMarketData.BTC.price : 0;
            if (usdAmount !== undefined && btcPrice > 0) {
                setGdEl('gdTotalBTC', '≈ ' + (usdAmount / btcPrice).toFixed(6) + ' BTC');
            }
            // Refrescar barra dual con datos actualizados
            renderGdDualBar();
        }

        function calcGdStats() {
            const today   = _fmtDate(new Date());
            let pnlHoy    = 0, pnlTotal = 0, wins = 0;
            history.forEach(h => {
                const p = (h.netProfit !== undefined ? parseFloat(h.netProfit) : parseFloat(h.profit)) || 0;
                pnlTotal += p;
                if (p > 0) wins++;
                const dateParts = (h.date || '').split('/');
                const hDate = dateParts.length === 3
                    ? _fmtDate(new Date(dateParts[2], dateParts[1]-1, dateParts[0]))
                    : '';
                if (hDate === today) pnlHoy += p;
            });
            const fmtPnl = v => (v >= 0 ? '+$' : '-$') + Math.abs(v).toFixed(2);
            const col    = v => v >= 0 ? 'var(--long)' : 'var(--short)';
            const elHoy  = document.getElementById('gdPnlHoy');
            const elTot  = document.getElementById('gdPnlTotal');
            if (elHoy) { elHoy.textContent = fmtPnl(pnlHoy);   elHoy.style.color = col(pnlHoy); }
            if (elTot) { elTot.textContent = fmtPnl(pnlTotal);  elTot.style.color = col(pnlTotal); }

            // PNL ABIERTO — suma PnL en tiempo real de todos los slots activos
            let pnlOpen = 0;
            let openCount = 0;
            slots.forEach((s, i) => {
                if (!s.name || !s.price) return;
                const live = allGateETFs ? allGateETFs.find(t => t.currency_pair === s.name + '_USDT') : null;
                const liveP = live ? parseFloat(live.last) : 0;
                const avg = calculateAvgPriceForSlotData ? calculateAvgPriceForSlotData(s, i) : 0;
                if (avg > 0 && liveP > 0) {
                    let invested = 0;
                    (s.buys || []).forEach(lvl => { try { invested += (getLevelData(s, lvl) || {}).usd || 0; } catch(e){} });
                    if (s.multipleBuys) Object.values(s.multipleBuys).forEach(arr => { if(Array.isArray(arr)) arr.forEach(b => { invested += b.usd||0; }); });
                    if (invested > 0) {
                        pnlOpen += ((liveP - avg) / avg) * invested;
                        openCount++;
                    }
                }
            });
            const elOpen = document.getElementById('gdPnlOpen');
            const elOpenSub = document.getElementById('gdPnlOpenSub');
            if (elOpen) { elOpen.textContent = fmtPnl(pnlOpen); elOpen.style.color = col(pnlOpen); }
            if (elOpenSub) elOpenSub.textContent = openCount + (openCount === 1 ? ' posición' : ' posiciones');
        }

        // ── BARRA DUAL: PORTFOLIO (izq) y EQUIVALENCIAS EN USDT (der) ──
        let gdDualPortfolioIdx = 0;
        let gdDualEqIdx        = 0;
        let gdDualTimer        = null;
        const GD_DUAL_SECS     = 4;   // segundos por slide

        // Datos de equivalencias (price del asset en USDT, el usuario ve cuántos de ese
        // asset puede comprar con su capital en USDT)
        const GD_EQ_ASSETS = [
            { sym: 'BTC',  label: 'Bitcoin',   decimals: 6 },
            { sym: 'ETH',  label: 'Ethereum',  decimals: 4 },
            { sym: 'SUI',  label: 'Sui',       decimals: 2 },
            { sym: 'AVAX', label: 'Avalanche', decimals: 2 },
            { sym: 'BNB',  label: 'BNB',       decimals: 3 },
            { sym: 'SOL',  label: 'Solana',    decimals: 2 },
        ];

        function buildGdPortfolioSlides() {
            // Solo slots ACTIVOS (con posición abierta y al menos una compra)
            const slides = [];
            for (let i = 0; i < 10; i++) {
                const s = slots[i] || {};
                if (!s.name || !s.price) continue; // saltar vacíos
                let invested = 0;
                (s.buys || []).forEach(lvl => {
                    try { invested += (getLevelData(s, lvl) || {}).usd || 0; } catch(e) {}
                });
                if (s.multipleBuys) {
                    Object.values(s.multipleBuys).forEach(arr => {
                        if (Array.isArray(arr)) arr.forEach(b => { invested += b.usd || 0; });
                    });
                }
                const coinColor   = getCoinColor ? getCoinColor(s.name) : 'var(--brand)';
                const basePrice   = s.price > 0 ? (s.price < 1 ? s.price.toFixed(6) : s.price.toFixed(4)) : '—';
                // PnL en tiempo real
                const live   = allGateETFs ? allGateETFs.find(t => t.currency_pair === s.name + '_USDT') : null;
                const liveP  = live ? parseFloat(live.last) : 0;
                const avg    = calculateAvgPriceForSlotData ? calculateAvgPriceForSlotData(s, i) : 0;
                const pnlPct = avg > 0 && liveP > 0 ? ((liveP - avg) / avg * 100) : null;
                const pnlDollar = pnlPct !== null && invested > 0 ? (pnlPct / 100 * invested) : null;
                const pnlStr = pnlDollar !== null ? `${pnlDollar >= 0 ? '+' : ''}$${pnlDollar.toFixed(2)}` : '';
                const pnlColor = pnlPct === null ? 'var(--text-tertiary)' : pnlPct >= 0 ? 'var(--long)' : 'var(--short)';
                const fmtInv  = '$' + (invested > 0 ? invested.toFixed(2) : '0.00');
                const boughtCount = (s.buys || []).length;
                const mode = slotModes ? (slotModes[i] || 'manual') : 'manual';
                const modeBadge = mode === 'auto' ? '🤖' : '✋';
                slides.push({ empty: false, idx: i, name: s.name, coinColor, basePrice, fmtInv, boughtCount, pnlStr, pnlColor, modeBadge, invested });
            }
            // Si no hay ningún slot activo, mostrar un slide de "sin posiciones"
            if (!slides.length) slides.push({ empty: true, idx: -1 });
            return slides;
        }

        function renderGdDualBar() {
            const portSlides = buildGdPortfolioSlides();
            if (gdDualPortfolioIdx >= portSlides.length) gdDualPortfolioIdx = 0;

            renderGdTrack('gdPortfolioTrack', 'gdPortfolioDots', portSlides.map(s => {
                if (s.empty) {
                    return `<div class="gd-dual-slide">
                        <div class="gd-slide-left">
                            <span class="gd-slide-coin" style="color:var(--text-tertiary);font-size:13px;">SIN POSICIONES</span>
                            <span class="gd-slide-detail">Agrega un ETF desde el Monitor</span>
                        </div>
                        <div class="gd-slide-right">
                            <span class="gd-slide-inv" style="color:var(--text-tertiary)">—</span>
                        </div>
                    </div>`;
                }
                return `<div class="gd-dual-slide" style="cursor:pointer;" onclick="activateDashSlot(${s.idx}); switchPanel(1);">
                    <div class="gd-slide-left">
                        <span class="gd-slide-coin" style="color:${s.coinColor}">${s.modeBadge} ${s.name}</span>
                        <span class="gd-slide-detail">BASE $${s.basePrice} · N${s.boughtCount} · ${s.fmtInv}</span>
                    </div>
                    <div class="gd-slide-right">
                        <span class="gd-slide-inv" style="color:${s.pnlColor};font-size:18px;font-weight:900;">${s.pnlStr || '—'}</span>
                        <span class="gd-slide-levels">PnL ACTUAL</span>
                    </div>
                </div>`;
            }), gdDualPortfolioIdx);
        }

        function renderGdTrack(trackId, dotsId, slidesHtml, activeIdx) {
            const track  = document.getElementById(trackId);
            const dotsEl = document.getElementById(dotsId);
            if (!track || !dotsEl) return;
            track.innerHTML = slidesHtml.join('');
            track.style.transform = `translateX(-${activeIdx * 100}%)`;
            dotsEl.innerHTML = slidesHtml.map((_, i) =>
                `<div class="gd-ddot${i === activeIdx ? ' active' : ''}"></div>`
            ).join('');
        }

        function tickGdDual() {
            const portSlides = buildGdPortfolioSlides();
            if (portSlides.length <= 1) return; // sin activos o solo 1 → no rotar
            gdDualPortfolioIdx = (gdDualPortfolioIdx + 1) % portSlides.length;
            renderGdDualBar();
        }

        function startGdDualRotation() { renderGdDualBar(); } // driven by masterClock
        function stopGdDualRotation()  { if (gdDualTimer) { clearInterval(gdDualTimer); gdDualTimer = null; } }
        function startGdTicker()       { updateGdMarketCard(); } // driven by masterClock
        function stopGdTicker()        { if (gdProgressTimer) { clearInterval(gdProgressTimer); gdProgressTimer = null; } }

        // Barra de progreso visual: cuenta 10s y se resetea en cada masterTick
        function startGdProgressBar() {
            if (gdProgressTimer) clearInterval(gdProgressTimer);
            gdProgressMs = 0;
            gdProgressTimer = setInterval(() => {
                gdProgressMs = Math.min(gdProgressMs + 100, MASTER_SECS * 1000);
                const pct = (gdProgressMs / (MASTER_SECS * 1000)) * 100;
                const bar = document.getElementById('gdMcProgress');
                if (bar) bar.style.width = pct + '%';
            }, 100);
        }

        function updateGdMarketCard() {
            const asset = GD_ASSETS[gdTickerIdx];
            const data  = gdMarketData[asset.sym] || { price: 0, change: 0 };
            const isUp  = data.change >= 0;
            const fmtP  = p => p < 1 ? '$' + p.toFixed(6) : '$' + p.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            setGdEl('gdMcSym',   asset.sym);
            setGdEl('gdMcPrice', data.price > 0 ? fmtP(data.price) : '—');
            const chEl = document.getElementById('gdMcChange');
            if (chEl) {
                chEl.textContent = (isUp ? '+' : '') + data.change.toFixed(2) + '%';
                chEl.className   = 'gd-mc-change ' + (isUp ? 'up' : 'down');
            }
        }

        // Utilidad simple
        function setGdEl(id, val) {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        }

        // gdJumpToNext: al tocar la card de mercado, salta al siguiente asset manualmente
        function gdJumpToNext() {
            gdTickerIdx = (gdTickerIdx + 1) % GD_ASSETS.length;
            updateGdMarketCard();
            // Reiniciar barra de progreso
            gdProgressMs = 0;
            const bar = document.getElementById('gdMcProgress');
            if (bar) bar.style.width = '0%';
        }
        let gdProgressMs = 0;

        // ════════════════════════════════════════════════════════
        //  MASTER ROTATION CLOCK — todo rota cada 10 segundos
        // ════════════════════════════════════════════════════════

        // ══════════════════════════════════════════════════════════════
        //  ETF MEJORADO — TABS DETALLE RECOVERY HEATMAP
        // ══════════════════════════════════════════════════════════════

        let currentETFTab = 'scanner';
        let currentDetailETF = null;

        function switchETFTab(tab) {
            currentETFTab = tab;
            const tabs = ['scanner','positions','heatmap','compare'];
            document.querySelectorAll('.etf-tab').forEach((t,i) => t.classList.toggle('active', tabs[i]===tab));
            document.querySelectorAll('.etf-tab-content').forEach(c => c.classList.remove('active'));
            const ac = document.getElementById('etfTab-'+tab);
            if (ac) ac.classList.add('active');
            if (tab==='heatmap')   renderETFHeatmap();
            if (tab==='compare')   renderETFCompare();
            if (tab==='positions') renderETFPositions();
        }

        function updateETFMarketBar() {
            const bar = document.getElementById('etfMarketBar');
            if (!bar || !allGateETFs.length) return;
            const btcT = window._allTickers && window._allTickers.find(t=>t.currency_pair==='BTC_USDT');
            const ethT = window._allTickers && window._allTickers.find(t=>t.currency_pair==='ETH_USDT');
            const goldens = allGateETFs.filter(t=>t.zone==='GOLD').length;
            const hots    = allGateETFs.filter(t=>t.zone==='HOT').length;
            const btcChg  = btcT ? parseFloat(btcT.change_percentage) : 0;
            const ethChg  = ethT ? parseFloat(ethT.change_percentage) : 0;
            const fmt = v => (v>=0?'+':'')+v.toFixed(2)+'%';
            bar.innerHTML = `
                <div class="etf-mkt-pill ${btcChg>=0?'up':'down'}">₿ BTC ${fmt(btcChg)}</div>
                <div class="etf-mkt-pill ${ethChg>=0?'up':'down'}">Ξ ETH ${fmt(ethChg)}</div>
                ${goldens>0?`<div class="etf-mkt-pill warn">🔥 ${goldens} GOLD</div>`:''}
                ${hots>0?`<div class="etf-mkt-pill warn">🟡 ${hots} HOT</div>`:''}
                <div class="etf-mkt-pill">${allGateETFs.length} ETFs</div>`;
        }

        function renderETFHeatmap() {
            const grid = document.getElementById('etfHeatmapGrid');
            if (!grid) return;
            if (!allGateETFs.length) { grid.innerHTML='<div class="etf-empty-pos">Ve a SCANNER primero.</div>'; return; }
            // Ordenar por mayor caída primero (más negativo = más oportunidad de compra)
            const sorted = [...allGateETFs].sort((a,b)=>parseFloat(a.change_percentage)-parseFloat(b.change_percentage));
            grid.innerHTML = sorted.map(t => {
                const sym   = t.currency_pair.replace('_USDT','');
                const chg   = parseFloat(t.change_percentage);
                const isUp  = chg>=0;
                const zone  = isUp?'zone-up':(t.zone==='GOLD'?'zone-gold':t.zone==='HOT'?'zone-hot':t.zone==='WARM'?'zone-warm':'zone-cool');
                const color = isUp?'var(--long)':(t.zone==='GOLD'?'var(--zone-gold)':t.zone==='HOT'?'var(--zone-hot)':'var(--short)');
                const base  = sym.replace(/3[LS]$|5[LS]$/,'');
                const levT  = sym.match(/[35][LS]$/)?.[0]||'';
                const inSlot = slots.some(s => s.name === sym);
                return `<div class="etf-hm-cell ${zone}${inSlot?' hm-in-slot':''}" onclick="showETFDetail('${sym}')" title="${sym}: ${chg>=0?'+':''}${chg.toFixed(2)}% · Toca para operar">
                    <span class="etf-hm-lev">${levT}</span>
                    <span class="etf-hm-sym" style="color:${getCoinColor(base)}">${base}</span>
                    <span class="etf-hm-chg" style="color:${color};font-weight:900;">${chg>=0?'+':''}${chg.toFixed(1)}%</span>
                    ${inSlot ? '<span style="font-size:6px;color:var(--brand);font-weight:800;letter-spacing:.3px;">EN SLOT</span>' : ''}
                </div>`;
            }).join('');
        }

        function renderETFCompare() {
            const grid = document.getElementById('etfCompareGrid');
            if (!grid) return;
            if (!allGateETFs.length) { grid.innerHTML='<div class="etf-empty-pos">Ve a SCANNER primero.</div>'; return; }
            const bases = {};
            allGateETFs.forEach(t => {
                const sym  = t.currency_pair.replace('_USDT','');
                const base = sym.replace(/[35][LS]$/,'');
                const type = sym.match(/([35][LS])$/)?.[1];
                if (!type) return;
                if (!bases[base]) bases[base]={};
                bases[base][type]=t;
            });
            let html = '';
            Object.entries(bases).sort((a,b)=>{
                const aS=Math.max(...Object.values(a[1]).map(t=>t.score||0));
                const bS=Math.max(...Object.values(b[1]).map(t=>t.score||0));
                return bS-aS;
            }).forEach(([base,types]) => {
                const lP = ['3L','5L'].filter(k=>types[k]);
                const sP = ['3S','5S'].filter(k=>types[k]);
                if(lP.length<2 && sP.length<2) return;
                const pairs=lP.length>=2?lP:sP;
                const isL=lP.length>=2;
                const fP=p=>p<0.01?'$'+p.toFixed(6):p<1?'$'+p.toFixed(4):'$'+p.toFixed(2);
                html+=`<div style="padding:4px 10px;font-family:var(--font-head);font-size:10px;font-weight:800;color:var(--text-tertiary);letter-spacing:1px;margin-top:8px;">${base} — ${isL?'LONG':'SHORT'}</div><div class="etf-compare-grid">`;
                pairs.forEach((key,ki) => {
                    const t=types[key], sym=t.currency_pair.replace('_USDT',''), chg=parseFloat(t.change_percentage), pr=parseFloat(t.last);
                    const lev=key.replace(/[LS]/,''), sc=t.score||0;
                    const otherKey=pairs[1-ki], otherChg=otherKey?parseFloat(types[otherKey]?.change_percentage||0):0;
                    const isBest=Math.abs(chg)>Math.abs(otherChg);
                    html+=`<div class="etf-cmp-card" onclick="showETFDetail('${sym}')">
                        <div class="etf-cmp-lev">×${lev}</div>
                        <div class="etf-cmp-sym" style="color:${getCoinColor(base)}">${sym.replace(base,'')}</div>
                        <div class="etf-cmp-price">${fP(pr)}</div>
                        <div class="etf-cmp-chg ${chg>=0?'up':'down'}">${chg>=0?'+':''}${chg.toFixed(2)}%</div>
                        <div style="font-family:var(--font-num);font-size:10px;color:var(--text-tertiary);margin-top:4px;">Score: ${sc}</div>
                        ${isBest&&Math.abs(chg)>10?'<span class="etf-cmp-badge best">MAYOR CAÍDA</span>':''}
                    </div>`;
                });
                html+='</div>';
            });
            grid.innerHTML=html||'<div class="etf-empty-pos">Sin pares comparables.</div>';
        }

        function renderETFPositions() {
            const grid = document.getElementById('etfPositionsGrid');
            if (!grid) return;
            const active = slots.map((s,i)=>({...s,idx:i})).filter(s=>s.name&&s.price>0);
            if (!active.length) { grid.innerHTML='<div class="etf-empty-pos">📭 Sin posiciones activas.<br>Agrega un ETF desde SCANNER.</div>'; return; }
            grid.innerHTML = active.map(s => {
                const live  = allGateETFs.find(t=>t.currency_pair===s.name+'_USDT');
                const lp    = live?parseFloat(live.last):0;
                const avg   = calculateAvgPriceForSlotData(s,s.idx);
                const inv   = getSlotInvested(s.idx);
                const lm    = s.name.match(/([35])([LS])/);
                const lev   = lm?parseInt(lm[1]):3;
                const isL   = lm?lm[2]==='L':true;
                const fP    = p=>p<0.01?'$'+p.toFixed(6):p<1?'$'+p.toFixed(4):'$'+p.toFixed(2);
                const pnlP  = avg>0&&lp>0?((lp-avg)/avg)*100:0;
                const pnlU  = avg>0&&inv>0?(pnlP/100)*inv:0;
                const roi   = (botConfig.tp1Pct||50)/100;
                const tgt   = avg>0?avg*(1+roi):0;
                const recN  = avg>0&&lp>0&&tgt>lp?((tgt-lp)/lp)*100:0;
                const spotM = lev>0?recN/lev:0;
                const vol   = live&&parseFloat(live.high_24h)>0?((parseFloat(live.high_24h)-parseFloat(live.low_24h))/parseFloat(live.low_24h))*100:0;
                const {decayLabel,decayClass} = getDecayInfo(lev,vol);
                const prog  = avg>0&&tgt>avg?Math.min(100,Math.max(0,((lp-avg)/(tgt-avg))*100)):0;
                const fCls  = pnlP>=0?(prog>=100?'profit':'partial'):'loss';
                const cCls  = pnlP>=0?'profit':'recovering';
                return `<div class="etf-pos-card ${cCls}" onclick="goToSlotLevels(${s.idx});switchView('operate',false);">
                    <div class="etf-pos-header">
                        <div>
                            <div class="etf-pos-name" style="color:${getCoinColor(s.name)}">${s.name}</div>
                            <div class="etf-pos-slot">SLOT ${s.idx+1} · ×${lev}${isL?'L':'S'}</div>
                            <span class="etf-decay-badge ${decayClass}">⏱ ${decayLabel}</span>
                        </div>
                        <div class="etf-pos-pnl ${pnlP>=0?'pos':'neg'}">
                            ${pnlU>=0?'+':''}$${pnlU.toFixed(2)}<br>
                            <span style="font-size:12px;">${pnlP>=0?'+':''}${pnlP.toFixed(2)}%</span>
                        </div>
                    </div>
                    <div class="etf-pos-grid">
                        <div><span class="etf-pos-stat-label">ACTUAL</span><span class="etf-pos-stat-val">${lp>0?fP(lp):'—'}</span></div>
                        <div><span class="etf-pos-stat-label">PROMEDIO</span><span class="etf-pos-stat-val">${avg>0?fP(avg):'—'}</span></div>
                        <div><span class="etf-pos-stat-label">INVERTIDO</span><span class="etf-pos-stat-val">$${inv.toFixed(2)}</span></div>
                        <div><span class="etf-pos-stat-label">OBJETIVO</span><span class="etf-pos-stat-val" style="color:var(--long)">${tgt>0?fP(tgt):'—'}</span></div>
                        <div><span class="etf-pos-stat-label">ETF FALTA</span><span class="etf-pos-stat-val" style="color:var(--warning)">${recN>0?'+'+recN.toFixed(1)+'%':'✅'}</span></div>
                        <div><span class="etf-pos-stat-label">SPOT FALTA</span><span class="etf-pos-stat-val">${spotM>0?'+'+spotM.toFixed(1)+'%':'✅'}</span></div>
                    </div>
                    <div class="etf-recovery-bar">
                        <div class="etf-recovery-label"><span>PROGRESO</span><span style="font-weight:800;color:var(--text-primary)">${prog.toFixed(0)}%</span></div>
                        <div class="etf-recovery-track"><div class="etf-recovery-fill ${fCls}" style="width:${prog}%"></div></div>
                    </div>
                </div>`;
            }).join('');
        }

        function showETFDetail(symbol) {
            const sym  = symbol.replace('_USDT','').replace('USDT','');
            const data = allGateETFs.find(t=>t.currency_pair===sym+'_USDT');
            if (!data) { smartSelectETF(sym,0); return; }
            currentDetailETF = {sym,data};
            const price=parseFloat(data.last),change=parseFloat(data.change_percentage);
            const vol=parseFloat(data.quote_volume)||0, h24=parseFloat(data.high_24h)||price, l24=parseFloat(data.low_24h)||price;
            const lm=sym.match(/([35])([LS])/), lev=lm?parseInt(lm[1]):3, isL=lm?lm[2]==='L':true;
            const base=sym.replace(/[35][LS]$/,''), volR=h24>0?((h24-l24)/l24)*100:0;
            const rsi=h24>l24?((price-l24)/(h24-l24))*100:50;
            const vFmt=vol>=1e6?(vol/1e6).toFixed(2)+'M':vol>=1e3?(vol/1e3).toFixed(1)+'K':vol.toFixed(0);
            const fP=p=>p<0.01?'$'+p.toFixed(6):p<1?'$'+p.toFixed(4):'$'+p.toFixed(2);
            const {decayLabel,decayClass}=getDecayInfo(lev,volR);
            const etfTgt=price*(1+1), spotN=100/lev;
            const z1=price, z2=price*0.90, z3=price*0.80;
            document.getElementById('etfDetailSym').textContent=sym;
            document.getElementById('etfDetailSym').style.color=getCoinColor(base);
            document.getElementById('etfDetailType').textContent=`ETF ×${lev} · ${isL?'LONG':'SHORT'} · BASE: ${base}`;
            document.getElementById('etfDetailPrice').textContent=fP(price);
            const cEl=document.getElementById('etfDetailChange');
            cEl.textContent=(change>=0?'+':'')+change.toFixed(2)+'%';
            cEl.className='etf-detail-change '+(change>=0?'etf-up':'etf-down');
            document.getElementById('etfDetailBody').innerHTML=`
                <div class="etf-detail-section">
                    <div class="etf-detail-section-title">SCORE DE OPORTUNIDAD</div>
                    <div class="etf-opp-track"><div class="etf-opp-fill" style="width:${data.score||0}%;background:${(data.score||0)>=80?'var(--zone-gold)':(data.score||0)>=60?'var(--zone-hot)':'var(--brand)'}"></div></div>
                    <div class="etf-opp-labels"><span>0</span><span style="font-weight:800;color:${(data.score||0)>=80?'var(--zone-gold)':'var(--text-primary)'}">${data.score||0}/100 · ${data.zone||'WARM'}</span><span>100</span></div>
                    <div style="margin-top:8px;"><span class="etf-decay-badge ${decayClass}">⏱ DECAY ${decayLabel}</span></div>
                </div>
                <div class="etf-detail-section">
                    <div class="etf-detail-section-title">ANÁLISIS DE MERCADO</div>
                    <div class="etf-detail-kv-grid">
                        <div><span class="etf-detail-key">CAMBIO 24H</span><span class="etf-detail-val ${change>=0?'up':'down'}">${change>=0?'+':''}${change.toFixed(2)}%</span></div>
                        <div><span class="etf-detail-key">VOLUMEN 24H</span><span class="etf-detail-val">$${vFmt}</span></div>
                        <div><span class="etf-detail-key">MÁXIMO 24H</span><span class="etf-detail-val">${fP(h24)}</span></div>
                        <div><span class="etf-detail-key">MÍNIMO 24H</span><span class="etf-detail-val">${fP(l24)}</span></div>
                        <div><span class="etf-detail-key">RSI POSICIÓN</span><span class="etf-detail-val ${rsi<30?'up':rsi>70?'down':'warn'}">${rsi.toFixed(0)}%</span></div>
                        <div><span class="etf-detail-key">RANGO VOLAT.</span><span class="etf-detail-val ${volR>80?'down':volR>40?'warn':'up'}">${volR.toFixed(1)}%</span></div>
                    </div>
                </div>
                <div class="etf-detail-section">
                    <div class="etf-detail-section-title">CALCULADORA DE RECUPERACIÓN (ROI +100%)</div>
                    <div class="etf-detail-kv-grid">
                        <div><span class="etf-detail-key">PRECIO OBJETIVO</span><span class="etf-detail-val up">${fP(etfTgt)}</span></div>
                        <div><span class="etf-detail-key">SPOT NECESITA</span><span class="etf-detail-val warn">${isL?'+':'−'}${spotN.toFixed(1)}%</span></div>
                        <div><span class="etf-detail-key">APALANCAMIENTO</span><span class="etf-detail-val">×${lev}</span></div>
                        <div><span class="etf-detail-key">DIRECCIÓN</span><span class="etf-detail-val ${isL?'up':'down'}">${isL?'↑ LONG':'↓ SHORT'}</span></div>
                    </div>
                    <div style="margin-top:10px;font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);line-height:2;padding:8px;background:rgba(255,255,255,.03);border-radius:8px;">
                        📌 Si ${base} ${isL?'sube':'baja'} ${spotN.toFixed(1)}%, el ETF sube ≈100%.<br>
                        ⚠️ El decay reduce este retorno a mayor tiempo sostenido.
                    </div>
                </div>
                <div class="etf-detail-section">
                    <div class="etf-detail-section-title">ZONAS DE ENTRADA DCA <span style="font-size:8px;color:var(--brand);margin-left:4px;">— TOCA UNA ZONA PARA OPERAR</span></div>
                    <div class="etf-entry-zones" style="gap:8px;display:flex;flex-direction:column;">
                        <div class="etf-entry-zone z1 dca-selectable" onclick="selectDCAZone('${sym}', ${z1}, 1)"
                            style="cursor:pointer;border:1.5px solid rgba(16,185,129,.4);border-radius:14px;padding:14px 16px;transition:all .15s;display:flex;justify-content:space-between;align-items:center;background:rgba(16,185,129,.06);">
                            <div>
                                <span class="etf-zone-label" style="color:var(--long);font-weight:900;">🟢 NIVEL 1 — AHORA</span><br>
                                <span class="etf-zone-pct" style="font-size:9px;color:var(--text-tertiary);">Precio actual · Entra YA</span>
                            </div>
                            <div style="text-align:right;">
                                <span class="etf-zone-price" style="font-size:18px;font-weight:900;">${fP(z1)}</span>
                                <div style="font-family:var(--font-head);font-size:9px;color:var(--long);margin-top:2px;">⚡ ABRIR DASHBOARD →</div>
                            </div>
                        </div>
                        <div class="etf-entry-zone z2 dca-selectable" onclick="selectDCAZone('${sym}', ${z2}, 2)"
                            style="cursor:pointer;border:1.5px solid rgba(245,158,11,.4);border-radius:14px;padding:14px 16px;transition:all .15s;display:flex;justify-content:space-between;align-items:center;background:rgba(245,158,11,.06);">
                            <div>
                                <span class="etf-zone-label" style="color:var(--warning);font-weight:900;">🟡 NIVEL 2 — DCA</span><br>
                                <span class="etf-zone-pct" style="font-size:9px;color:var(--text-tertiary);">–10% desde ahora · Si sigue cayendo</span>
                            </div>
                            <div style="text-align:right;">
                                <span class="etf-zone-price" style="font-size:18px;font-weight:900;">${fP(z2)}</span>
                                <div style="font-family:var(--font-head);font-size:9px;color:var(--warning);margin-top:2px;">⚡ ABRIR DASHBOARD →</div>
                            </div>
                        </div>
                        <div class="etf-entry-zone z3 dca-selectable" onclick="selectDCAZone('${sym}', ${z3}, 3)"
                            style="cursor:pointer;border:1.5px solid rgba(239,68,68,.4);border-radius:14px;padding:14px 16px;transition:all .15s;display:flex;justify-content:space-between;align-items:center;background:rgba(239,68,68,.06);">
                            <div>
                                <span class="etf-zone-label" style="color:var(--short);font-weight:900;">🔴 NIVEL 3 — FONDO</span><br>
                                <span class="etf-zone-pct" style="font-size:9px;color:var(--text-tertiary);">–20% desde ahora · Entrada máxima</span>
                            </div>
                            <div style="text-align:right;">
                                <span class="etf-zone-price" style="font-size:18px;font-weight:900;">${fP(z3)}</span>
                                <div style="font-family:var(--font-head);font-size:9px;color:var(--short);margin-top:2px;">⚡ ABRIR DASHBOARD →</div>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top:8px;font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);text-align:center;line-height:1.8;">
                        Selecciona la zona de entrada → Se abre el dashboard con los 12 niveles calculados desde ese precio
                    </div>
                </div>`;
            const addBtn=document.getElementById('etfDetailAddBtn');
            const exists=slots.findIndex(s=>s.name===sym)!==-1;
            const hasEmpty=slots.findIndex(s=>!s.name||s.name==='')!==-1;
            if (exists) {
                addBtn.textContent = '⚡ IR AL SLOT ACTIVO';
                addBtn.style.background = 'var(--brand)';
                addBtn.style.borderColor = 'var(--brand)';
            } else if (hasEmpty) {
                addBtn.textContent = '⚡ AGREGAR AL DASHBOARD Y OPERAR';
                addBtn.style.background = 'var(--long)';
                addBtn.style.borderColor = 'var(--long)';
            } else {
                addBtn.textContent = '⚠️ SLOTS LLENOS (5/5)';
                addBtn.style.background = 'rgba(239,68,68,.2)';
                addBtn.style.borderColor = 'var(--short)';
            }
            addBtn.style.fontSize = '13px';
            addBtn.style.padding = '14px';
            addBtn.className='etf-action-btn primary';
            document.getElementById('etfDetailModal').classList.add('open');
            document.body.style.overflow='hidden';
        }

        function closeETFDetail() {
            document.getElementById('etfDetailModal').classList.remove('open');
            document.body.style.overflow='';
            currentDetailETF=null;
        }

        function addCurrentDetailToSlot() {
            if (!currentDetailETF) return;
            closeETFDetail();
            smartSelectETF(currentDetailETF.sym, parseFloat(currentDetailETF.data.last));
        }

        function getDecayInfo(leverage, volRange) {
            const daily = (leverage*leverage-leverage)*(volRange/100)*0.4;
            if (daily>5)  return {decayLabel:'ALTO '+daily.toFixed(1)+'%/d',  decayClass:'high'};
            if (daily>2)  return {decayLabel:'MEDIO '+daily.toFixed(1)+'%/d', decayClass:'medium'};
            return          {decayLabel:'BAJO '+daily.toFixed(2)+'%/d',        decayClass:'low'};
        }

        function updateDashRecovery(slotIdx) {
            const row=document.getElementById('dashRecRow-'+slotIdx);
            const fill=document.getElementById('dashRecFill-'+slotIdx);
            const pctEl=document.getElementById('dashRecPct-'+slotIdx);
            if (!row||!fill||!pctEl) return;
            const s=slots[slotIdx];
            if (!s||!s.name||!s.price) { row.style.display='none'; return; }
            const avg=calculateAvgPriceForSlotData(s,slotIdx);
            const liveD=allGateETFs.find(t=>t.currency_pair===s.name+'_USDT');
            const live=liveD?parseFloat(liveD.last):0;
            if (avg<=0||live<=0) { row.style.display='none'; return; }
            const roi=(botConfig.tp1Pct||50)/100, tgt=avg*(1+roi);
            const prog=Math.min(100,Math.max(0,((live-avg)/(tgt-avg))*100));
            const pnlP=((live-avg)/avg)*100;
            row.style.display='flex';
            fill.style.width=prog+'%';
            fill.style.background=pnlP>=0?'var(--long)':pnlP>-10?'var(--warning)':'var(--short)';
            pctEl.textContent=(pnlP>=0?'+':'')+pnlP.toFixed(1)+'%';
            pctEl.style.color=pnlP>=0?'var(--long)':'var(--short)';
        }

        // Hook: actualizar recovery y market bar en cada ciclo maestro

        // ══════════════════════════════════════════════════════════════
        //  SUPABASE INTEGRATION LAYER — SOLO URL + ANON KEY
        // ══════════════════════════════════════════════════════════════
        // ── Credenciales Supabase hardcodeadas — login siempre funciona ──
        const SB_URL_DEFAULT = 'https://arqrafxtpnnqzbpbxkzk.supabase.co';
        const SB_KEY_DEFAULT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFycXJhZnh0cG5ucXpicGJ4a3prIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIyODg3MjQsImV4cCI6MjA4Nzg2NDcyNH0.W6d1RorU6RlvVMZdGHH5oJGeq4gvvlSnXtSRUyDw3dA';
        const sb = {
            url:    localStorage.getItem('c5x_sb_url') || SB_URL_DEFAULT,
            key:    localStorage.getItem('c5x_sb_key') || SB_KEY_DEFAULT,
            active: false,
            async init() {
                if (!this.url||!this.key) return false;
                try {
                    const r=await fetch(`${this.url}/rest/v1/`,{headers:{'apikey':this.key,'Authorization':'Bearer '+this.key}});
                    this.active=r.ok; this._ui(this.active); return this.active;
                } catch(e) { this.active=false; this._ui(false); return false; }
            },
            async set(table,key,value) {
                const v=typeof value==='string'?value:JSON.stringify(value);
                localStorage.setItem('c5x_'+key,v);
                if (!this.active) return true;
                try {
                    await fetch(`${this.url}/rest/v1/${table}`,{method:'POST',headers:{'apikey':this.key,'Authorization':'Bearer '+this.key,'Content-Type':'application/json','Prefer':'resolution=merge-duplicates'},body:JSON.stringify({key,value:v,updated_at:new Date().toISOString()})});
                    return true;
                } catch(e) { return false; }
            },
            async get(table,key,fallback=null) {
                const local=localStorage.getItem('c5x_'+key);
                if (local) { try { return JSON.parse(local); } catch(e) { return local; } }
                if (!this.active) return fallback;
                try {
                    const r=await fetch(`${this.url}/rest/v1/${table}?key=eq.${key}&select=value`,{headers:{'apikey':this.key,'Authorization':'Bearer '+this.key}});
                    const d=await r.json();
                    if (d&&d[0]?.value) { try { return JSON.parse(d[0].value); } catch(e) { return d[0].value; } }
                    return fallback;
                } catch(e) { return fallback; }
            },
            async checkWhitelist(userId) {
                if (!this.active) return true;
                try {
                    const r=await fetch(`${this.url}/rest/v1/whitelist?user_id=eq.${userId}&select=user_id`,{headers:{'apikey':this.key,'Authorization':'Bearer '+this.key}});
                    const d=await r.json(); return Array.isArray(d)&&d.length>0;
                } catch(e) { return true; }
            },
            async list(prefix,_shared) {
                if (!this.active) return {keys:[]};
                try {
                    const r=await fetch(`${this.url}/rest/v1/kv_store?key=like.${encodeURIComponent(prefix+'%')}&select=key&order=key.asc&limit=100`,{headers:{'apikey':this.key,'Authorization':'Bearer '+this.key}});
                    const d=await r.json();
                    return Array.isArray(d)?{keys:d.map(row=>row.key)}:{keys:[]};
                } catch(e) { return {keys:[]}; }
            },
            async sendMessage(text,userKey,userName) {
                if (!this.active) return false;
                try {
                    const r=await fetch(`${this.url}/rest/v1/support_messages`,{method:'POST',headers:{'apikey':this.key,'Authorization':'Bearer '+this.key,'Content-Type':'application/json','Prefer':'return=minimal'},body:JSON.stringify({user_key:userKey||('user_'+Date.now()),text,sender:'user',user_name:userName||'Usuario',read:false,created_at:new Date().toISOString()})});
                    return r.ok;
                } catch(e) { return false; }
            },
            async fetchMessages(limit) {
                if (!this.active) return null;
                if (!limit) limit=50;
                try {
                    const r=await fetch(`${this.url}/rest/v1/support_messages?order=created_at.asc&limit=${limit}`,{headers:{'apikey':this.key,'Authorization':'Bearer '+this.key}});
                    const d=await r.json();
                    if (Array.isArray(d)) return d.map(row=>({id:row.id,text:row.text,from:row.from||'user',time:row.created_at?new Date(row.created_at).toLocaleString():'',read:row.read||false,type:row.type||'text',fileUrl:row.file_url||null,fileName:row.file_name||null,fileType:row.file_type||null}));
                    return null;
                } catch(e) { return null; }
            },
            // ── SUBIR ARCHIVO A SUPABASE STORAGE ──────────────────────────
            async uploadFile(file, userKey) {
                if (!this.active || !this.url || !this.key) return null;
                try {
                    const ext = file.name.split('.').pop();
                    const path = `support/${userKey||'user'}_${Date.now()}.${ext}`;
                    const r = await fetch(`${this.url}/storage/v1/object/support-files/${path}`, {
                        method: 'POST',
                        headers: { 'apikey': this.key, 'Authorization': 'Bearer ' + this.key, 'Content-Type': file.type, 'x-upsert': 'false' },
                        body: file
                    });
                    if (!r.ok) return null;
                    return `${this.url}/storage/v1/object/public/support-files/${path}`;
                } catch(e) { return null; }
            },
            // ── ENVIAR MENSAJE TIPO ARCHIVO ────────────────────────────────
            async sendFileMessage(fileUrl, fileName, fileType, userKey, userName) {
                if (!this.active) return false;
                try {
                    const r=await fetch(`${this.url}/rest/v1/support_messages`,{method:'POST',headers:{'apikey':this.key,'Authorization':'Bearer '+this.key,'Content-Type':'application/json','Prefer':'return=minimal'},body:JSON.stringify({user_key:userKey||('user_'+Date.now()),text:'[Archivo adjunto]',sender:'user',user_name:userName||'Usuario',read:false,type:'file',file_url:fileUrl,file_name:fileName,file_type:fileType,created_at:new Date().toISOString()})});
                    return r.ok;
                } catch(e) { return false; }
            },
            _ui(connected) {
                const dot=document.getElementById('sbStatusDot');
                const txt=document.getElementById('sbStatusText');
                const tag=document.getElementById('sbStatusTag');
                if (!dot) return;
                if (connected) { dot.className='sb-dot connected'; if(txt) txt.textContent='Sincronizado con la nube ✓'; if(tag){tag.textContent='SYNC ACTIVO';tag.className='sb-status-tag';} }
                else {
                    dot.className='sb-dot';
                    if(txt) txt.textContent = this.url ? 'Error conectando — revisa credenciales' : 'Datos guardados localmente en este dispositivo';
                    if(tag){tag.textContent='LOCAL';tag.className='sb-status-tag offline';}
                }
            }
        };

        function saveSupabaseConfig() {
            const url=document.getElementById('sbUrlInput')?.value?.trim();
            const key=document.getElementById('sbKeyInput')?.value?.trim();
            if (!url||!key) { showToast('⚠️ Completa URL y ANON KEY'); return; }
            sb.url=url; sb.key=key;
            localStorage.setItem('c5x_sb_url',url); localStorage.setItem('c5x_sb_key',key);
            showToast('💾 Config guardada — probando...'); testSupabaseConnection();
        }

        async function testSupabaseConnection() {
            const res=document.getElementById('sbTestResult');
            if (res) { res.style.display='block'; res.textContent='⏳ Conectando...'; }
            const ok=await sb.init();
            if (res) { res.textContent=ok?'✅ Conexión exitosa. Sync activo.':'❌ Error: verifica URL y ANON KEY.'; res.style.color=ok?'var(--long)':'var(--short)'; }
            showToast(ok?'✅ Supabase conectado':'❌ Error de conexión',3000);
        }

        function loadSupabaseConfigUI() {
            const urlEl=document.getElementById('sbUrlInput');
            const keyEl=document.getElementById('sbKeyInput');
            if (urlEl) urlEl.value=sb.url||'';
            if (keyEl) keyEl.value=sb.key?'••••••••':'';
            sb._ui(sb.active);
        }

        // Auto-init Supabase con credenciales hardcodeadas si no hay en localStorage
        setTimeout(async () => {
            if (!sb.url || !sb.key) {
                sb.url = SB_URL_DEFAULT;
                sb.key = SB_KEY_DEFAULT;
            }
            if (sb.url && sb.key && !sb.active) {
                const ok = await sb.init();
                if (ok) {
                    console.log('[5X] Supabase conectado automáticamente');
                    syncUsersFromCloud();
                }
            }
        }, 1500);
        document.addEventListener('keydown',e=>{ if(e.key==='Escape') closeETFDetail(); });



        // ══════════════════════════════════════════════════════════════
        //  ETF PRO TRADING — STOP-LOSS, POSITION SIZING, QUICK ORDER
        // ══════════════════════════════════════════════════════════════

        // ── Calculadora de tamaño de posición basado en riesgo % ─────
        function calcETFPositionSize(capital, riskPct, entryPrice, stopLossPrice) {
            if (!entryPrice || !stopLossPrice || entryPrice <= stopLossPrice) return 0;
            const riskAmount   = capital * (riskPct / 100);
            const priceRisk    = entryPrice - stopLossPrice;
            const pctRisk      = priceRisk / entryPrice;
            const positionUSD  = riskAmount / pctRisk;
            return Math.min(positionUSD, capital); // No más que el capital total
        }

        // ── Modal de quick order desde ETF detail ────────────────────
        function showETFQuickOrder(symbol, suggestedPrice) {
            closeETFDetail();
            // Usar el slot vacío más cercano y redirigir al flujo normal
            const idx = slots.findIndex(s => s.name === symbol);
            if (idx !== -1) {
                goToSlotLevels(idx);
                switchView('operate', false);
                showToast(`⚡ ${symbol} → SLOT ${idx+1} activo`);
            } else {
                smartSelectETF(symbol, suggestedPrice);
            }
        }

        // ── Alerta de divergencia ETF vs SPOT ────────────────────────
        // Compara el % de cambio esperado del ETF vs lo real
        function calcETFDivergence(etfChange, spotChange, leverage) {
            if (!spotChange || leverage <= 0) return 0;
            const expected = spotChange * leverage;
            const actual   = etfChange;
            return actual - expected; // positivo = ETF supera expectativa; negativo = decay visible
        }

        function getDivergenceInfo(divergence) {
            const abs = Math.abs(divergence);
            if (abs > 20)  return { label: `⚡ DIV ${divergence.toFixed(1)}%`, cls: 'extreme' };
            if (abs > 10)  return { label: `≈ DIV ${divergence.toFixed(1)}%`, cls: 'high' };
            return           { label: `≈ ${divergence.toFixed(1)}%`, cls: 'normal' };
        }

        // ── Render ETF card mejorada con divergencia ─────────────────
        // Reemplaza el render anterior añadiendo divergencia y botón de detalle
        function renderETFCardHTML(t, index) {
            const price    = parseFloat(t.last);
            const change   = parseFloat(t.change_percentage);
            const pairName = t.currency_pair.replace('_USDT','').replace('USDT','');
            const displayP = price < 1 ? price.toFixed(6) : price.toFixed(4);
            const nameColor = getCoinColor(pairName);
            const volume   = parseFloat(t.quote_volume) || 0;
            const volFmt   = volume >= 1e6 ? (volume/1e6).toFixed(2)+'M' : volume >= 1e3 ? (volume/1e3).toFixed(1)+'K' : volume.toFixed(0);
            const score    = t.score || 0;
            const zone     = t.zone  || 'WARM';
            const zoneColor = zone === 'GOLD' ? 'var(--zone-gold)' : zone === 'HOT' ? 'var(--zone-hot)' : 'var(--zone-warm)';
            const flashClass = zone === 'GOLD' ? 'flash-gold-card' : '';
            const levMatch = pairName.match(/([35])([LS])/);
            const lev      = levMatch ? parseInt(levMatch[1]) : 3;
            const isLong   = levMatch ? levMatch[2] === 'L' : true;
            const base     = pairName.replace(/[35][LS]$/,'');
            const spotT = window._allTickers && window._allTickers.find(tt => tt.currency_pair === base + '_USDT');
            const spotChg = spotT ? parseFloat(spotT.change_percentage) : 0;
            const div  = spotChg !== 0 ? calcETFDivergence(change, spotChg, lev) : null;
            const divInfo = div !== null ? getDivergenceInfo(div) : null;
            const inSlot  = slots.findIndex(s => s.name === pairName) !== -1;
            const { decayLabel, decayClass } = getDecayInfo(lev, t.volatilityRange || 0);
            const chgColor  = change >= 0 ? 'var(--long)' : 'var(--short)';
            const chgBg     = change >= 0 ? 'rgba(16,185,129,.13)' : 'rgba(239,68,68,.13)';
            const chgBorder = change >= 0 ? 'rgba(16,185,129,.3)' : 'rgba(239,68,68,.3)';
            const levBg     = isLong ? 'rgba(16,185,129,.13)' : 'rgba(239,68,68,.13)';
            const levBorder = isLong ? 'rgba(16,185,129,.35)' : 'rgba(239,68,68,.35)';
            const levColor  = isLong ? 'var(--long)' : 'var(--short)';

            return `<div class="etf-mc ${flashClass}" onclick="showETFDetail('${pairName}')">
                <div class="etf-mc-row1">
                    <div style="display:flex;align-items:center;gap:6px;flex:1;min-width:0;overflow:hidden;">
                        <div style="width:22px;height:22px;border-radius:50%;background:rgba(59,130,246,.1);border:1.5px solid var(--border);display:flex;align-items:center;justify-content:center;font-family:var(--font-head);font-size:9px;font-weight:900;color:var(--text-tertiary);flex-shrink:0;">${index+1}</div>
                        <span class="etf-mc-name" style="color:${nameColor};">${pairName}</span>
                        <span class="etf-mc-lev" style="background:${levBg};border:1px solid ${levBorder};color:${levColor};">${lev}X&nbsp;${isLong?'L':'S'}</span>
                        ${inSlot ? `<span class="etf-mc-slot-tag">⚡SLOT</span>` : ''}
                    </div>
                    <span class="etf-mc-chg" style="background:${chgBg};border:1px solid ${chgBorder};color:${chgColor};">${change>=0?'+':''}${change.toFixed(2)}%</span>
                </div>
                <div class="etf-mc-row2">
                    <div style="display:flex;flex-direction:column;gap:1px;">
                        <span class="etf-mc-price">$${displayP}</span>
                        ${spotChg !== 0 ? `<span class="etf-mc-meta" style="font-size:9px;">SPOT <span style="color:${spotChg>=0?'var(--long)':'var(--short)'};">${spotChg>=0?'+':''}${spotChg.toFixed(1)}%</span></span>` : '<span style="height:13px;display:block;"></span>'}
                    </div>
                    <div class="etf-mc-score-wrap">
                        <div class="etf-mc-score-lbl">SCORE</div>
                        <div class="etf-mc-score-val" style="color:${zoneColor};">${score}</div>
                    </div>
                </div>
                <div class="etf-mc-inforow">
                    <div class="etf-mc-inforow-left">
                        <span class="etf-mc-meta"><span style="opacity:.55;font-size:8px;">VOL</span> <strong style="color:var(--text-primary);font-weight:700;font-size:10px;">$${volFmt}</strong></span>
                        ${divInfo ? `<span class="etf-divergence ${divInfo.cls}" style="font-size:8px;padding:2px 5px;white-space:nowrap;">${divInfo.label}</span>` : ''}
                    </div>
                    <div class="etf-mc-inforow-right">
                        <span class="etf-decay-badge ${decayClass}" style="font-size:7px;padding:2px 6px;white-space:nowrap;">⏱ ${decayLabel}</span>
                    </div>
                </div>
            </div>`;
        }

        // ── Parche sobre filterETFs para usar renderETFCardHTML ───────
        // filterETFs_base is the original
        function filterETFs(query) {
            const grid       = document.getElementById('etfGrid');
            const desktopList = document.getElementById('desktop-etf-list');
            const term       = query.toUpperCase().trim();
            let sorted = [...allGateETFs];
            let filtered;
            if (term) {
                filtered = sorted.filter(t => t.currency_pair.includes(term)).slice(0, 10);
            } else {
                const byScore = [...sorted].sort((a,b) => (b.score||0)-(a.score||0));
                const byDrop  = [...sorted].sort((a,b) => parseFloat(a.change_percentage)-parseFloat(b.change_percentage));
                const topDrops = byDrop.slice(0,5);
                const topOpps  = byScore.filter(t => !topDrops.includes(t)).slice(0,5);
                const combined = [...topDrops,...topOpps];
                filtered = combined.sort((a,b) => {
                    const aF = etfFavorites.includes(a.currency_pair.replace('_',''));
                    const bF = etfFavorites.includes(b.currency_pair.replace('_',''));
                    if (aF&&!bF) return -1; if (!aF&&bF) return 1;
                    return parseFloat(a.change_percentage)-parseFloat(b.change_percentage);
                });
            }
            let htmlContent = '';
            if (!filtered.length) htmlContent = '<div style="text-align:center;padding:20px;color:var(--text-tertiary)">Sin resultados</div>';
            else filtered.forEach((t,i) => { htmlContent += renderETFCardHTML(t, i); });
            if (grid)       grid.innerHTML = htmlContent;
            if (desktopList) desktopList.innerHTML = htmlContent;
            updateETFMarketBar();
            if (currentETFTab==='positions') renderETFPositions();
        };

        // ── Guardar allTickers global para comparación spot ───────────
        const _origFetchAndCalc = fetchAndCalcTopDroppers;
        fetchAndCalcTopDroppers = async function() {
            const result = await _origFetchAndCalc.apply(this, arguments);
            // La función ya setea allGateETFs, ahora también exponemos el ticker completo
            try {
                const r = await callGatePublic("/spot/tickers");
                window._allTickers = Array.isArray(r) ? r : (r.result || r.data || []);
            } catch(e) {}
            return result;
        };

        // ── Panel de análisis rápido en la barra superior del ETF ─────
        // Se actualiza en cada masterTick si el tab ETF está activo
        function refreshETFActiveTab() {
            if (currentETFTab === 'heatmap')   renderETFHeatmap();
            if (currentETFTab === 'compare')   renderETFCompare();
            if (currentETFTab === 'positions') renderETFPositions();
        }



        // ══════════════════════════════════════════════════════════════
        //  SHORT ETF TRADER PRO — SALIDA AUTOMÁTICA + DIVERGENCIA +
        //  REBALANCES + MOMENTUM SCANNER
        // ══════════════════════════════════════════════════════════════

        // ── ESTADO GLOBAL SHORTS ─────────────────────────────────────
        let multiTPTargets    = [];    // [{pct, price, sizePct, done}]
        let trailingState     = null;  // {activated, maxPrice, activatePct, dropPct, slotIdx, sym}
        let divergenceAlerts  = [];    // [{sym, div, time}]
        let rebalanceHistory  = JSON.parse(localStorage.getItem('c5x_rebal_history') || '[]');
        let momentumCache     = {};    // {sym: {prev, curr, momentum, ts}}
        let divMonitorId      = null;
        let activeSellMode    = null;  // 'manual' | 'multitp' | 'trailing'

        // ── SELL MODAL — TABS ─────────────────────────────────────────
        function switchSellTab(tab) {
            ['manual','multitp','trail'].forEach(t => {
                document.getElementById('sellTab-'+t)?.classList.toggle('active', t===tab);
                document.getElementById('sellPanel-'+t)?.classList.toggle('active', t===tab);
            });
            if (tab === 'trail') updateTrailExplain();
            if (tab === 'multitp') buildMultiTPRows();
        }

        function updateTrailExplain() {
            const ap = botConfig.trailActivePct || 100;
            const dp = botConfig.trailDropPct   || 15;
            const apEl = document.getElementById('trailActivatePct');
            const dpEl = document.getElementById('trailDropPct');
            if (apEl) apEl.value = ap;
            if (dpEl) dpEl.value = dp;
            const el = document.getElementById('trailExplain');
            if (el) el.innerHTML = `El bot espera que el ETF suba <strong>+${ap}%</strong> desde tu promedio.<br>
                Cuando suba, activa el trailing. Si cae <strong>${dp}%</strong> desde el máximo alcanzado, vende todo con orden MARKET en Gate.io.`;
        }

        function buildMultiTPRows() {
            // No necesita generar HTML dinámico — el panel ya está fijo en el DOM
            // Solo actualiza los precios calculados
            updateMTPrices();
        }

        function updateMTPrices() {
            const s    = slots[activeIdx];
            const avg  = s ? calculateAvgPriceForSlotData(s, activeIdx) : 0;
            const fP   = p => !p || p <= 0 ? '—' : p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : '$'+p.toFixed(2);

            const tp1pct    = parseFloat(document.getElementById('tp1pct')?.value)    || 50;
            const trailAct  = parseFloat(document.getElementById('trailActPct')?.value)|| 100;
            const trailing  = parseFloat(document.getElementById('tp2trailing')?.value)|| 15;
            const rebuyPct  = parseFloat(document.getElementById('rebuyDropI')?.value) || 16;

            const tp1price  = avg > 0 ? avg * (1 + tp1pct / 100)  : 0;
            const trailprice= avg > 0 ? avg * (1 + trailAct / 100) : 0;

            const el1 = document.getElementById('tp1calcprice');
            const el2 = document.getElementById('tp2calcprice');
            if (el1) el1.textContent = fP(tp1price);
            if (el2) el2.textContent = fP(trailprice);

            const info = document.getElementById('mtpInfoBox');
            if (info && avg > 0) {
                info.innerHTML =
                    `🟢 <b>TP1</b>: vende 50% cuando llegue a <b>${fP(tp1price)}</b> (avg+${tp1pct}%)<br>` +
                    `📈 <b>TRAILING</b>: activa a <b>${fP(trailprice)}</b> (avg+${trailAct}%) · stop -${trailing}% desde el máximo<br>` +
                    `🔄 <b>REBUY</b>: si cae -${rebuyPct}% desde TP1 → 12 niveles nuevos · hasta 3 ciclos`;
            } else if (info) {
                info.textContent = 'Define un precio promedio para ver los cálculos';
            }
        }

        function updateTPPrice(inputId, priceId) {
            updateMTPrices();
        }

        // ── ABRIR SELL MODAL MEJORADO ─────────────────────────────────
        const _origOpenSellOptionsModal = openSellOptionsModal;
        // Override removed — new openSellOptionsModal already handles all UI with new HTML IDs

        // ── SELL CUSTOM % ─────────────────────────────────────────────
        function executeSellCustom() {
            const pct = parseFloat(document.getElementById('sellCustomPct')?.value);
            if (!pct || pct <= 0) return showToast('⚠️ Ingresa un % válido');
            executeSellOption(pct);
        }

        // ── CANCELAR SELL ACTIVO ──────────────────────────────────────
        function cancelActiveSell() {
            activeSellMode   = null;
            multiTPTargets   = [];
            trailingState    = null;
            activeSellTarget = null;
            stopTrailReminder();
            localStorage.removeItem('c5x_sell_target');
            localStorage.removeItem('c5x_trailing');
            localStorage.removeItem('c5x_multitp');
            closeModals();
            showToast('🚫 Salida automática cancelada');
        }

        // ── ACTIVAR ESTRATEGIA TP1 → TRAILING ────────────────────────
        function activateMultiTP() {
            const s   = slots[activeIdx];
            const avg = calculateAvgPriceForSlotData(s, activeIdx);
            if (avg <= 0) return showToast('⚠️ Sin precio promedio');

            const tp1pct       = parseFloat(document.getElementById('tp1pct')?.value)    || (botConfig.tp1Pct        || 50);
            const trailActPct  = parseFloat(document.getElementById('trailActPct')?.value)|| (botConfig.trailActivePct|| 100);
            const trailing     = parseFloat(document.getElementById('tp2trailing')?.value)|| (botConfig.trailDropPct  || 15);
            const rebuyPct     = parseFloat(document.getElementById('rebuyDropI')?.value) || (botConfig.rebuyDropPct  || 16);

            // Guardar en botConfig para coherencia con el auto-bot
            botConfig.tp1Pct        = tp1pct;
            botConfig.trailActivePct = trailActPct;
            botConfig.trailDropPct   = trailing;
            botConfig.rebuyDropPct   = rebuyPct;
            localStorage.setItem('c5x_bot_config', JSON.stringify(botConfig));

            const tp1price   = avg * (1 + tp1pct / 100);
            const trailPrice = avg * (1 + trailActPct / 100);
            const fP = p => p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : '$'+p.toFixed(2);

            // activeSellTarget unificado — checkSellTargets maneja toda la lógica
            activeSellTarget = {
                slotIndex:      activeIdx,
                type:           50,           // TP1 primero
                targetPrice:    tp1price,
                avgPrice:       avg,
                basePrice:      s.price,
                symbol:         s.name,
                tp1Done:        false,
                trailActivePct: trailActPct,
                trailDropPct:   trailing,
                rebuyDropPct:   rebuyPct,
                trailActivated: false,
                trailMax:       0,
                rebuyCount:     0
            };
            activeSellMode = 'multitp';
            localStorage.setItem('c5x_sell_target', JSON.stringify(activeSellTarget));
            // Limpiar multiTPTargets legacy para que checkAdvancedSellTargets no interfiera
            multiTPTargets = [];
            localStorage.removeItem('c5x_multitp');
            closeModals();
            // Iniciar recordatorio periódico (se actualiza al activar trailing)
            startTrailReminder(s.name, trailActPct, trailing);
            showToast(`⚡ Estrategia activa — ${s.name} | TP1 ${fP(tp1price)} · Trailing activa ${fP(trailPrice)}`, 3500, false, true);
            sendNativeNotif('⚡ Estrategia Activada', `${s.name}: TP1 avg+${tp1pct}% ${fP(tp1price)} · Trailing activa a avg+${trailActPct}% · Stop -${trailing}% desde máximo`);
        }

        // ── ACTIVAR TRAILING STOP ─────────────────────────────────────
        function activateTrailingStop() {
            const s   = slots[activeIdx];
            const avg = calculateAvgPriceForSlotData(s, activeIdx);
            if (avg <= 0) return showToast('⚠️ Sin precio promedio');
            // ── FIX TRAILING: usar botConfig como fuente única ──
            // Los inputs HTML se leen como override; si están vacíos se usa botConfig
            const apEl = document.getElementById('trailActivatePct');
            const dpEl = document.getElementById('trailDropPct');
            const activatePct = (apEl && apEl.value) ? parseFloat(apEl.value) : (botConfig.trailActivePct || 100);
            const dropPct     = (dpEl && dpEl.value) ? parseFloat(dpEl.value) : (botConfig.trailDropPct   || 15);
            // Guardar en botConfig para que el loop del bot use los mismos valores
            botConfig.trailActivePct = activatePct;
            botConfig.trailDropPct   = dropPct;
            const liveD = allGateETFs.find(t => t.currency_pair === s.name + '_USDT');
            const liveP = liveD ? parseFloat(liveD.last) : avg;
            trailingState = {
                activated:    false,
                maxPrice:     liveP,
                activatePrice:avg*(1+activatePct/100),
                activatePct,
                dropPct,
                slotIdx:      activeIdx,
                sym:          s.name,
                avgPrice:     avg
            };
            activeSellMode = 'trailing';
            localStorage.setItem('c5x_trailing', JSON.stringify(trailingState));
            closeModals();
            startSellMonitor();
            showToast(`🔵 Trailing activo: activa a +${activatePct}% · drop ${dropPct}%`, 3000, false, true);
        }

        // ── MONITOR DE VENTA (MULTI TP + TRAILING) ────────────────────
        let sellMonitorId = null;
        function startSellMonitor() {
            if (sellMonitorId) return; // ya corriendo
            sellMonitorId = setInterval(() => { checkAdvancedSellTargets(); }, 3000);
        }

        async function checkAdvancedSellTargets() {
            const fP = p => p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : '$'+p.toFixed(2);

            // A. ESTRATEGIA TP1 / TP2 / RETROCESO + TRAILING
            if (activeSellMode === 'multitp' && multiTPTargets.length) {
                for (const tp of multiTPTargets) {
                    if (tp.done) continue;
                    const s    = slots[tp.slotIdx];
                    if (!s || s.name !== tp.sym) continue;
                    const live = allGateETFs.find(t => t.currency_pair === tp.sym + '_USDT');
                    const lp   = live ? parseFloat(live.last) : 0;
                    if (!lp) continue;
                    const avg  = tp.avgPrice || calculateAvgPriceForSlotData(s, tp.slotIdx);
                    const roiNow = ((lp - avg) / avg * 100).toFixed(1);

                    if (tp.label === 'TP1') {
                        // TP1: precio fijo avg + tp1pct%
                        if (lp >= tp.price) {
                            tp.done = true;
                            tp.tp1SellPrice = lp; // guardar precio real de venta para rebuy
                            localStorage.setItem('c5x_multitp', JSON.stringify(multiTPTargets));
                            await executeGateSellPartial(tp.sym, tp.slotIdx, tp.sizePct);
                            showToast(`🎯 TP1 EJECUTADO! ${tp.sym} +${roiNow}% · Vendido ${tp.sizePct}%`, 4000, false, true);
                            sendNativeNotif(`🎯 TP1 — ${tp.sym}`, `+${roiNow}% · ${tp.sizePct}% vendido @${fP(lp)} · Esperando TP2 ${fP(multiTPTargets[1]?.price)}`, { requireInteraction: true, vibrate:[200,100,200] });
                        }
                    } else if (tp.label === 'TP2') {
                        // Solo monitorear TP2 si TP1 ya se ejecutó
                        const tp1 = multiTPTargets.find(t => t.label === 'TP1');
                        if (!tp1 || !tp1.done) continue;

                        // ── REBUY POST-TP1 HASTA 3 CICLOS — caída 16% desde precio TP1 ──
                        const tp1SellPx = tp1.tp1SellPrice || tp1.price;
                        const dropFromTP1 = tp1SellPx > 0 ? ((tp1SellPx - lp) / tp1SellPx * 100) : 0;
                        const rebuyThreshold = botConfig.rebuyDropPct || 16;
                        const _rebuyCountAdv = tp.rebuyCount || 0;

                        if (tp1SellPx > 0 && dropFromTP1 >= rebuyThreshold && _rebuyCountAdv < 3) {
                            tp.rebuyCount = _rebuyCountAdv + 1;
                            const cycleNum  = tp.rebuyCount;
                            const cycleLeft = 3 - cycleNum;
                            // Reset TP1 para que se pueda ejecutar de nuevo en el nuevo ciclo
                            tp1.done          = false;
                            tp1.tp1SellPrice  = 0;
                            localStorage.setItem('c5x_multitp', JSON.stringify(multiTPTargets));

                            // Resetear niveles del slot desde el nuevo precio base
                            const slotR = slots[tp.slotIdx];
                            if (slotR) {
                                // Acumular (no reemplazar) el 50% restante al blend
                                let _rS = 0, _rQ = 0;
                                const _lim3 = customMultipliers.length || 12;
                                for (let _k = 0; _k < _lim3; _k++) {
                                    const _bk = getOrderKey(tp.slotIdx, _k);
                                    if (activeOrders[_bk] && activeOrders[_bk].status === 'filled') {
                                        _rS += activeOrders[_bk].price * activeOrders[_bk].amount;
                                        _rQ += activeOrders[_bk].amount;
                                    }
                                }
                                slotR.rebuyOldSpent = (slotR.rebuyOldSpent || 0) + _rS * 0.50;
                                slotR.rebuyOldQty   = (slotR.rebuyOldQty   || 0) + _rQ * 0.50;
                                slotR.rebuyCount    = tp.rebuyCount;

                                slotR.price     = lp;

                                const filledBuys = (slotR.buys || []).filter(bi => {
                                    const bk = getOrderKey(tp.slotIdx, bi);
                                    return activeOrders[bk] && activeOrders[bk].status === 'filled';
                                });
                                slotR.buys = filledBuys;
                                slotR.multipleBuys = {};
                                const pfxR = `s${tp.slotIdx}_`;
                                Object.keys(activeOrders).forEach(k => {
                                    if (k.startsWith(pfxR) && activeOrders[k].status !== 'filled') delete activeOrders[k];
                                });
                                saveActiveOrders();
                                save();

                                if (tp.slotIdx === activeIdx) { calculate(); renderLevels(); }

                                const dropStr    = dropFromTP1.toFixed(1);
                                const newBaseStr = lp < 1 ? lp.toFixed(6) : lp.toFixed(4);
                                const tp1Str     = tp1SellPx < 1 ? tp1SellPx.toFixed(6) : tp1SellPx.toFixed(4);
                                showToast(`🔄 Rebuy ${cycleNum}/3 ${tp.sym}: −${dropStr}% → 12 niveles · ${cycleLeft} más`, 6000, false, true);
                                sendNativeNotif(`🔄 Rebuy ${cycleNum}/3 — ${tp.sym}`, `↓${dropStr}% desde TP1 $${tp1Str} → 12 niveles · Base $${newBaseStr} · ${cycleLeft} ciclo${cycleLeft !== 1 ? 's' : ''} restante${cycleLeft !== 1 ? 's' : ''}`);
                                if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 400]);
                            }
                        }

                        // Actualizar máximo alcanzado
                        if (lp > tp.maxPrice) {
                            tp.maxPrice = lp;
                            localStorage.setItem('c5x_multitp', JSON.stringify(multiTPTargets));
                        }

                        // Marcar cuando llega al fallback (avg + tp2FallbackPct%)
                        if (!tp.reachedFallback && lp >= tp.fallbackPrice) {
                            tp.reachedFallback = true;
                            localStorage.setItem('c5x_multitp', JSON.stringify(multiTPTargets));
                        }

                        // TP2 directo: precio base × multiplicador
                        if (lp >= tp.price) {
                            // Si sigue subiendo más allá de TP2 → trailing activo
                            const dropFromMax = tp.maxPrice > tp.price ? ((tp.maxPrice - lp) / tp.maxPrice * 100) : 0;
                            if (lp >= tp.price && dropFromMax < tp.trailingDrop) {
                                // Precio sigue subiendo o no ha caído aún → esperar trailing
                                // Notificar solo la primera vez que supera TP2
                                if (!tp.tp2Notified) {
                                    tp.tp2Notified = true;
                                    localStorage.setItem('c5x_multitp', JSON.stringify(multiTPTargets));
                                    sendNativeNotif(`📈 TP2 superado — ${tp.sym}`, `+${roiNow}% · Precio sigue subiendo → trailing -${tp.trailingDrop}% desde máx ${fP(tp.maxPrice)}`);
                                    showToast(`📈 ${tp.sym}: TP2 superado · Trailing activado -${tp.trailingDrop}% desde máx`, 4000, false, true);
                                }
                                continue; // seguir esperando el trailing
                            }
                            // Cayó trailingDrop% desde el máximo (que supera tp2) → ejecutar
                            if (lp >= tp.price && dropFromMax >= tp.trailingDrop) {
                                tp.done = true;
                                localStorage.setItem('c5x_multitp', JSON.stringify(multiTPTargets));
                                await executeGateSellPartial(tp.sym, tp.slotIdx, tp.sizePct);
                                showToast(`🎯 TP2 TRAILING! ${tp.sym} +${roiNow}% · Vendido ${tp.sizePct}% (caída -${dropFromMax.toFixed(1)}% desde máx)`, 5000, false, true);
                                sendNativeNotif(`🎯 TP2 TRAILING — ${tp.sym}`, `+${roiNow}% · ${tp.sizePct}% vendido @${fP(lp)} · Máx: ${fP(tp.maxPrice)}`, { requireInteraction: true, vibrate:[400,100,400] });
                                activeSellMode = null; multiTPTargets = [];
                                localStorage.removeItem('c5x_multitp');
                                return;
                            }
                        }

                        // Retroceso: llegó a fallback y cayó por debajo → vender resto
                        if (tp.reachedFallback && lp < tp.fallbackPrice) {
                            tp.done = true;
                            localStorage.setItem('c5x_multitp', JSON.stringify(multiTPTargets));
                            await executeGateSellPartial(tp.sym, tp.slotIdx, tp.sizePct);
                            showToast(`⚠️ RETROCESO! ${tp.sym} +${roiNow}% · Vendido ${tp.sizePct}% restante`, 5000, false, true);
                            sendNativeNotif(`⚠️ Retroceso TP2 — ${tp.sym}`, `+${roiNow}% · ${tp.sizePct}% vendido @${fP(lp)} · Caída desde avg+${((tp.fallbackPrice/avg-1)*100).toFixed(0)}%`, { requireInteraction: true, vibrate:[300,100,300] });
                            activeSellMode = null; multiTPTargets = [];
                            localStorage.removeItem('c5x_multitp');
                            return;
                        }
                    }
                }
            }

            // B. TRAILING STOP independiente
            if (activeSellMode === 'trailing' && trailingState) {
                const ts   = trailingState;
                const s    = slots[ts.slotIdx];
                if (!s || s.name !== ts.sym) { trailingState = null; return; }
                const live = allGateETFs.find(t => t.currency_pair === ts.sym + '_USDT');
                const lp   = live ? parseFloat(live.last) : 0;
                if (!lp) return;
                // Actualizar máximo
                if (lp > ts.maxPrice) {
                    ts.maxPrice = lp;
                    localStorage.setItem('c5x_trailing', JSON.stringify(ts));
                }
                // Activar trailing cuando supera el umbral
                if (!ts.activated && lp >= ts.activatePrice) {
                    ts.activated = true;
                    localStorage.setItem('c5x_trailing', JSON.stringify(ts));
                    showToast(`🔵 TRAILING ACTIVADO — ${ts.sym} alcanzó +${ts.activatePct}%`, 3000, false, true);
                    sendNativeNotif('🔵 Trailing Activado', `${ts.sym} subió +${ts.activatePct}%. Protegiendo ganancias — stop -${ts.dropPct}% desde máx`);
                }
                // Ejecutar si trailing activo y precio cae X%
                if (ts.activated) {
                    const dropFromMax = ((ts.maxPrice - lp) / ts.maxPrice) * 100;
                    const roiNow = (((lp - ts.avgPrice) / ts.avgPrice)*100).toFixed(1);
                    // Alerta cuando se acerca al stop
                    if (dropFromMax >= ts.dropPct * 0.80 && dropFromMax < ts.dropPct) {
                        sendNativeNotif(`⚠️ Stop Cercano — ${ts.sym}`, `+${roiNow}% · Caída ${dropFromMax.toFixed(1)}% de ${ts.dropPct}% · Máx: ${fP(ts.maxPrice)}`, { tag:'c5x-stop-warn' });
                    }
                    if (dropFromMax >= ts.dropPct) {
                        await executeGateSellAll(ts.sym, ts.slotIdx, lp);
                        showToast(`🔵 TRAILING STOP! ${ts.sym} +${roiNow}% · Caída -${dropFromMax.toFixed(1)}% desde máx`, 4000, false, true);
                        sendNativeNotif(`🔵 TRAILING STOP — ${ts.sym}`, `+${roiNow}% · Caída ${dropFromMax.toFixed(1)}% desde $${fP(ts.maxPrice)}. Gate.io OK`, { requireInteraction: true, vibrate:[400,100,400] });
                        trailingState  = null;
                        activeSellMode = null;
                        localStorage.removeItem('c5x_trailing');
                    }
                }
            }
        }

        // ── EJECUTAR SELL PARCIAL EN GATE.IO ─────────────────────────
        async function executeGateSellPartial(sym, slotIdx, sizePct) {
            if (!apiConfig.key || !apiConfig.secret) {
                showToast('⚠️ Sin API Key — venta manual necesaria'); return;
            }
            try {
                // Obtener balance disponible
                const wallet = await callGateApi('GET', '/spot/accounts');
                const base   = sym.replace('_USDT','');
                const acct   = Array.isArray(wallet) ? wallet.find(a => a.currency === base) : null;
                const avail  = acct ? parseFloat(acct.available) : 0;
                if (avail <= 0) { showToast(`⚠️ Sin balance de ${base}`); return; }
                const amount = (avail * (sizePct / 100)).toFixed(4);
                const body   = {
                    currency_pair: sym + '_USDT',
                    side: 'sell',
                    amount,
                    type: 'market',
                    account: 'spot',
                    time_in_force: 'ioc'
                };
                const result = await callGateApi('POST', '/spot/orders', body, true);
                if (result && result.id) {
                    console.log(`✅ SELL PARCIAL ${sizePct}% de ${sym} — Order ID: ${result.id}`);
                } else {
                    showToast(`⚠️ Error en orden sell de ${sym}`);
                }
            } catch(e) {
                console.error('executeGateSellPartial error:', e);
                showToast(`❌ Error sell ${sym}: ${e.message}`);
            }
        }

        async function executeGateSellAll(sym, slotIdx, currentPrice) {
            if (!apiConfig.key || !apiConfig.secret) {
                // Sin API: registrar como manual y limpiar slot
                const s = slots[slotIdx];
                if (s) executeSellNow(s, slotIdx);
                return;
            }
            await executeGateSellPartial(sym, slotIdx, 100);
            // Registrar en historial ANTES de limpiar
            const s = slots[slotIdx];
            if (s && s.name) {
                addToHistory && addToHistory(s, slotIdx, currentPrice, 'trailing_stop');
            }
            // Limpiar estado completo + refrescar UI
            _finalizeSlotSell(slotIdx);
        }

        // ══════════════════════════════════════════════════════════════
        //  DIVERGENCIA ETF vs SPOT — MONITOR Y ALERTAS
        // ══════════════════════════════════════════════════════════════
        const DIV_THRESHOLD = 15; // % de divergencia para alertar

        function monitorDivergences() {
            if (!allGateETFs.length || !window._allTickers) return;
            const newAlerts = [];
            allGateETFs.forEach(t => {
                const sym  = t.currency_pair.replace('_USDT','');
                const lm   = sym.match(/([35])([LS])/);
                if (!lm) return;
                const lev  = parseInt(lm[1]);
                const isS  = lm[2] === 'S';
                const base = sym.replace(/[35][LS]$/,'');
                const spotT = window._allTickers.find(tt => tt.currency_pair === base + '_USDT');
                if (!spotT) return;
                const etfChg  = parseFloat(t.change_percentage);
                const spotChg = parseFloat(spotT.change_percentage);
                const expected = isS ? -spotChg * lev : spotChg * lev;
                const div = etfChg - expected;
                if (Math.abs(div) >= DIV_THRESHOLD) {
                    newAlerts.push({ sym, etfChg, spotChg, div, lev, isS, base, time: Date.now() });
                }
            });
            // Actualizar y mostrar
            divergenceAlerts = newAlerts;
            renderDivergenceAlerts();
        }

        function renderDivergenceAlerts() {
            // En la barra de market del ETF
            const bar = document.getElementById('etfMarketBar');
            if (!bar) return;
            // Añadir pill de alerta si hay divergencias
            const extremes = divergenceAlerts.filter(a => Math.abs(a.div) >= 20);
            if (extremes.length) {
                const existing = bar.querySelector('.div-pill');
                if (!existing) {
                    const pill = document.createElement('div');
                    pill.className = 'etf-mkt-pill warn div-pill';
                    pill.style.cursor = 'pointer';
                    pill.onclick = () => switchETFTab('heatmap');
                    pill.innerHTML = `⚡ ${extremes.length} DIV EXTREMA`;
                    bar.appendChild(pill);
                }
            }
            // En tab MAPA — resaltar ETFs con divergencia alta
            if (currentETFTab === 'heatmap') renderETFHeatmap();
        }

        function getDivAlertForSym(sym) {
            return divergenceAlerts.find(a => a.sym === sym);
        }

        // ══════════════════════════════════════════════════════════════
        //  HISTORIAL DE REBALANCEOS ETF
        //  Gate.io rebalancea ETFs diariamente a las 00:00 UTC y cuando
        //  el NAV se mueve >15% en el día (rebalanceo extraordinario)
        // ══════════════════════════════════════════════════════════════
        function detectAndLogRebalance(sym, prevHigh, prevLow, prevClose, currOpen, lev) {
            if (!prevClose || !currOpen) return;
            // Estimación del costo de rebalanceo: basado en volatilidad del período anterior
            const dailyVol    = prevHigh > 0 ? ((prevHigh - prevLow) / prevLow) * 100 : 0;
            const dailyDecay  = (lev * lev - lev) * (dailyVol / 100) * 0.4;
            const rebalCost   = dailyDecay; // % estimado perdido
            const entry = {
                sym,
                date:      _fmtDate(new Date()),
                time:      _fmtTime(new Date()),
                prevClose,
                currOpen,
                gapPct:    ((currOpen - prevClose) / prevClose) * 100,
                vol:       dailyVol,
                decayCost: rebalCost,
                lev
            };
            // Mantener los últimos 30 rebalanceos
            rebalanceHistory = [entry, ...rebalanceHistory].slice(0, 30);
            localStorage.setItem('c5x_rebal_history', JSON.stringify(rebalanceHistory));
        }

        function renderRebalanceHistory() {
            const tab = document.getElementById('etfTab-positions');
            if (!tab || currentETFTab !== 'positions') return;
            // Añadir sección de rebalanceos debajo de posiciones
            const existing = document.getElementById('rebalSection');
            if (existing) existing.remove();
            if (!rebalanceHistory.length) return;
            const section = document.createElement('div');
            section.id = 'rebalSection';
            section.style.paddingBottom = '16px';
            const recent = rebalanceHistory.slice(0, 5);
            section.innerHTML = `
                <div style="padding:10px 10px 4px;font-family:var(--font-head);font-size:9px;font-weight:800;color:var(--text-tertiary);letter-spacing:1px;">
                    HISTORIAL DE REBALANCEOS
                </div>
                ${recent.map(r => {
                    const costCls = r.decayCost > 5 ? 'high' : r.decayCost > 2 ? 'medium' : 'low';
                    return `<div class="rebal-card">
                        <div class="rebal-header">
                            <span class="rebal-coin" style="color:${getCoinColor(r.sym)}">${r.sym}</span>
                            <span class="rebal-date">${r.date} ${r.time}</span>
                        </div>
                        <div class="rebal-grid">
                            <div><span class="rebal-stat-label">CIERRE PREV.</span><span class="rebal-stat-val">$${r.prevClose?.toFixed?.(6)||'—'}</span></div>
                            <div><span class="rebal-stat-label">APERTURA</span><span class="rebal-stat-val">$${r.currOpen?.toFixed?.(6)||'—'}</span></div>
                            <div><span class="rebal-stat-label">GAP</span><span class="rebal-stat-val" style="color:${r.gapPct>=0?'var(--long)':'var(--short)'}">${r.gapPct>=0?'+':''}${r.gapPct?.toFixed?.(2)||0}%</span></div>
                        </div>
                        <div>
                            <span class="rebal-cost-badge ${costCls}">⏱ DECAY ESTIMADO: ${r.decayCost?.toFixed?.(2)||0}%</span>
                            <span class="rebal-cost-badge low" style="margin-left:4px;">VOL ${r.vol?.toFixed?.(1)||0}%</span>
                        </div>
                    </div>`;
                }).join('')}`;
            tab.appendChild(section);
        }

        // ══════════════════════════════════════════════════════════════
        //  MOMENTUM SCANNER — SHORTS CON MAYOR ACELERACIÓN
        // ══════════════════════════════════════════════════════════════
        function calcMomentum(sym, currentChange) {
            const now  = Date.now();
            const prev = momentumCache[sym];
            if (!prev || now - prev.ts > 30000) {
                // Primera lectura o expirada
                momentumCache[sym] = { change: currentChange, ts: now, momentum: 0 };
                return 0;
            }
            // Momentum = aceleración del cambio (delta del delta)
            const momentum = currentChange - prev.change;
            momentumCache[sym] = { change: currentChange, ts: now, momentum };
            return momentum;
        }

        function renderMomentumScanner() {
            const container = document.getElementById('etfHeatmapGrid');
            if (!container || currentETFTab !== 'heatmap') return;
            // Solo shorts
            const shorts = allGateETFs
                .filter(t => t.currency_pair.includes('3S') || t.currency_pair.includes('5S'))
                .map(t => {
                    const sym = t.currency_pair.replace('_USDT','');
                    const chg = parseFloat(t.change_percentage);
                    const mom = calcMomentum(sym, chg);
                    return { ...t, sym, chg, mom };
                })
                .sort((a,b) => b.chg - a.chg); // más sube (mejor para short que estás vendiendo)
            if (!shorts.length) return; // Usar render normal si no hay shorts
            const fP = p => p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : '$'+p.toFixed(2);
            const maxMom = Math.max(...shorts.map(s => Math.abs(s.mom)), 1);
            container.innerHTML = `
                <div style="grid-column:1/-1;padding:4px 2px;font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);letter-spacing:.8px;font-weight:800;">
                    MOMENTUM SHORT ETFs — MAYOR SUBIDA (POSIBLE SALIDA) PRIMERO
                </div>
                ${shorts.map((t, i) => {
                    const isUp  = t.chg >= 0;
                    const zone  = isUp ? 'zone-up' : (t.zone === 'GOLD' ? 'zone-gold' : t.zone === 'HOT' ? 'zone-hot' : 'zone-warm');
                    const color = isUp ? 'var(--long)' : (t.score >= 80 ? 'var(--zone-gold)' : 'var(--short)');
                    const base  = t.sym.replace(/[35][LS]$/,'');
                    const levT  = t.sym.match(/[35][LS]$/)?.[0]||'';
                    const divA  = getDivAlertForSym(t.sym);
                    return `<div class="etf-hm-cell ${zone}${isUp?' zone-up':''}" onclick="showETFDetail('${t.sym}')">
                        <span class="etf-hm-lev">${levT}</span>
                        <span class="etf-hm-sym" style="color:${getCoinColor(base)}">${base}</span>
                        <span class="etf-hm-chg" style="color:${color}">${t.chg>=0?'+':''}${t.chg.toFixed(1)}%</span>
                        ${divA ? `<span style="font-size:7px;color:var(--warning);">⚡DIV</span>` : ''}
                    </div>`;
                }).join('')}`;
        }

        // ── SHORT FOCUS BAR en scanner ────────────────────────────────
        function renderShortFocusBar() {
            const bar = document.getElementById('etfMarketBar');
            if (!bar || !allGateETFs.length) return;
            const shorts = allGateETFs
                .filter(t => t.currency_pair.includes('3S') || t.currency_pair.includes('5S'))
                .sort((a,b) => parseFloat(b.change_percentage)-parseFloat(a.change_percentage)) // más subida primero (mejor posición)
                .slice(0, 8);
            if (!shorts.length) return;
            const fP = p => p < 0.01 ? '$'+p.toFixed(6) : p < 1 ? '$'+p.toFixed(4) : p.toFixed(2);
            // Mantener pills existentes (BTC, ETH) + añadir shorts — solo si no están ya
            // Limpiar shorts previos antes de re-añadir para evitar duplicados
            const shortPillEls = bar.querySelectorAll('.short-pill');
            shortPillEls.forEach(el => el.remove());
            const shortPills = shorts.map(t => {
                const sym  = t.currency_pair.replace('_USDT','');
                const chg  = parseFloat(t.change_percentage);
                const base = sym.replace(/[35][LS]$/,'');
                const spotT = window._allTickers?.find(tt => tt.currency_pair === base+'_USDT');
                const spotC = spotT ? parseFloat(spotT.change_percentage) : 0;
                const inSlot = slots.findIndex(s => s.name === sym) !== -1;
                return `<div class="short-pill${inSlot?' active':''}" onclick="showETFDetail('${sym}')">
                    <span class="short-pill-sym" style="color:${getCoinColor(sym)}">${sym}</span>
                    <span class="short-pill-chg" style="color:${chg>=0?'var(--long)':'var(--short)'}">${chg>=0?'+':''}${chg.toFixed(1)}%</span>
                    <span class="short-pill-spot">SPOT ${spotC>=0?'+':''}${spotC.toFixed(1)}%</span>
                </div>`;
            }).join('');
            bar.insertAdjacentHTML('beforeend', shortPills);
        }

        // ── HOOK: actualizar divergencias y momentum en cada tick ─────
        const _origRefreshETFActiveTab = refreshETFActiveTab;
        refreshETFActiveTab = function() {
            _origRefreshETFActiveTab();
            monitorDivergences();
            // Heatmap se auto-actualiza en switchETFTab y renderETFHeatmap
            // No forzar momentum scanner — el heatmap ya muestra los más caídos
            if (currentETFTab === 'positions') renderRebalanceHistory();
        };

        // HEATMAP: siempre muestra TODOS los ETFs por mayor caída
        // El momentum scanner se eliminó del heatmap — el heatmap es para
        // identificar oportunidades de COMPRA (más caído = más oportunidad)
        // renderETFHeatmap ya está ordenado por más negativo primero ✓

        // ── HOOK: updateETFMarketBar agrega short bar ─────────────────
        const _origUpdateMarketBar = updateETFMarketBar;
        updateETFMarketBar = function() {
            _origUpdateMarketBar();
            setTimeout(renderShortFocusBar, 50); // tras el render original
        };

        // ── HOOK: loadGateETFs activa monitor al cargar ───────────────
        const _origLoadGateETFs = loadGateETFs;
        loadGateETFs = async function() {
            await _origLoadGateETFs();
            startSellMonitor(); // activa monitor de salida si había estado guardado
            // Restaurar trailing desde localStorage
            const savedTrail = localStorage.getItem('c5x_trailing');
            if (savedTrail && !trailingState) {
                try { trailingState = JSON.parse(savedTrail); activeSellMode = 'trailing'; } catch(e) {}
            }
            const savedMulti = localStorage.getItem('c5x_multitp');
            if (savedMulti && !multiTPTargets.length) {
                try { multiTPTargets = JSON.parse(savedMulti); activeSellMode = 'multitp'; } catch(e) {}
            }
        };

        // ── INPUT LISTENERS trailing explain ──────────────────────────
        document.addEventListener('input', e => {
            if (e.target?.id === 'trailActivatePct' || e.target?.id === 'trailDropPct') updateTrailExplain();
        });




        // ════════════════════════════════════════════════════════
        //  selectDCAZone — abre dashboard con precio de entrada
        //  elegido desde las zonas DCA del modal de detalle
        // ════════════════════════════════════════════════════════
        function selectDCAZone(sym, entryPrice, zoneNum) {
            triggerHaptic();
            const zoneName = zoneNum === 1 ? 'AHORA' : zoneNum === 2 ? 'DCA –10%' : 'FONDO –20%';

            // Feedback visual: resaltar zona tocada
            const zones = document.querySelectorAll('.dca-selectable');
            zones.forEach((z, i) => {
                z.style.transform = i === zoneNum - 1 ? 'scale(0.97)' : 'scale(1)';
                z.style.opacity   = i === zoneNum - 1 ? '1' : '0.5';
            });

            // Breve delay para ver el feedback, luego navegar
            setTimeout(() => {
                closeETFDetail();

                // ¿Ya está en un slot? → activarlo con ese precio si es diferente
                const existingIdx = slots.findIndex(s => s.name === sym);
                if (existingIdx !== -1) {
                    // Actualizar precio base si es diferente al actual
                    if (Math.abs(slots[existingIdx].price - entryPrice) / entryPrice > 0.01) {
                        slots[existingIdx].price = entryPrice;
                        slots[existingIdx].buys  = [];       // reset compras con nuevo precio
                        save();
                        showToast(`✅ ${sym} → SLOT ${existingIdx+1} · Precio actualizado: $${entryPrice.toFixed(entryPrice < 1 ? 6 : 4)}`);
                    } else {
                        showToast(`⚡ ${sym} ya en SLOT ${existingIdx+1}`);
                    }
                    switchView('operate', false);
                    goToSlotLevels(existingIdx);
                    return;
                }

                // Buscar primer slot vacío
                const targetIdx = slots.findIndex(s => !s.name || s.name === '');
                if (targetIdx === -1) {
                    showToast('⚠️ No hay slots disponibles (5/5 ocupados)');
                    return;
                }

                // Asignar ETF con el precio de la zona elegida
                slots[targetIdx] = {
                    name:          sym,
                    price:         entryPrice,          // ← precio de la zona DCA elegida
                    initialPrice:  entryPrice,
                    buys:          [],
                    locked:        true,
                    note:          `Entrada zona ${zoneNum}: ${zoneName}`,
                    alerted:       false,
                    priceAdjusted: false,
                    strat:         'normal',
                    capital:       strategyParams.normal.capital || 5,
                    roi:           120,
                    multipleBuys:  {}
                };

                save();
                updateBodyMode(sym);
                renderAllDashboards();
                switchView('operate', false);
                goToSlotLevels(targetIdx);
                showToast(`✅ ${sym} → SLOT ${targetIdx+1} · Zona ${zoneNum} (${zoneName}) $${entryPrice.toFixed(entryPrice < 1 ? 6 : 4)}`);
            }, 200);
        }


        // ════════════════════════════════════════════════════════════
        //  SISTEMA DE USUARIOS — GESTIÓN POR ADMIN
        //  Usuarios guardados en localStorage (+ Supabase si conectado)
        //  Desactivados: solo ven pantalla de "Sin acceso + Soporte"
        // ════════════════════════════════════════════════════════════

        let appUsers = JSON.parse(localStorage.getItem('c5x_users') || '[]');

        // ── Cargar usuarios desde Supabase al iniciar ──────────────
        async function syncUsersFromCloud() {
            try {
                if (!sb.active) return;
                const data = await sb.get('kv_store', 'users_list', null);
                if (data && Array.isArray(data) && data.length > 0) {
                    appUsers = data;
                    localStorage.setItem('c5x_users', JSON.stringify(appUsers));
                    if(typeof renderUserList==='function') renderUserList();
                }
            } catch(e) { console.warn('syncUsers:', e); }
        }
        setTimeout(() => { if (sb.active) syncUsersFromCloud(); }, 3000);
        // ── FIX: ADMIN_PIN ahora devuelve el HASH almacenado, no el PIN raw ──
        const ADMIN_PIN = () => localStorage.getItem('c5x_pin_hash') || _DEFAULT_PIN_HASH;

        // ── Verificar acceso del usuario actual ──────────────────────
        function checkCurrentUserAccess() {
            const myPin = localStorage.getItem('c5x_my_pin');
            if (!myPin) return true; // sin PIN guardado = acceso libre (sesión inicial)
            const me = appUsers.find(u => u.pin === myPin);
            if (!me) return true; // PIN no en lista = acceso libre
            if (!me.active) {
                // Usuario desactivado → mostrar pantalla bloqueada
                showBlockedScreen(me.name);
                return false;
            }
            return true;
        }

        function showBlockedScreen(name) {
            // Ocultar toda la app y mostrar pantalla de "sin acceso"
            const app = document.getElementById('appRoot') || document.querySelector('.app-container');
            const blockedDiv = document.createElement('div');
            blockedDiv.id = 'blockedScreen';
            blockedDiv.style.cssText = 'position:fixed;inset:0;z-index:99999;background:var(--bg,#0b0e11);display:flex;flex-direction:column;align-items:center;justify-content:center;padding:30px;text-align:center;';
            blockedDiv.innerHTML = `
                <div style="font-size:48px;margin-bottom:16px;">🔒</div>
                <div style="font-family:'Space Grotesk',sans-serif;font-size:22px;font-weight:900;color:#fff;margin-bottom:8px;">Acceso Suspendido</div>
                <div style="font-family:'Space Grotesk',sans-serif;font-size:13px;color:#888;margin-bottom:30px;line-height:1.8;">
                    Hola ${name}, tu acceso a 5X está temporalmente suspendido.<br>
                    Contacta al administrador para más información.
                </div>
                <button onclick="showBlockedSupport()" style="background:#3b82f6;color:#fff;border:none;border-radius:16px;padding:14px 28px;font-family:'Space Grotesk',sans-serif;font-size:14px;font-weight:700;cursor:pointer;margin-bottom:12px;width:100%;max-width:280px;">
                    💬 Contactar al Admin (Soporte)
                </button>
                <div id="blockedChatArea" style="display:none;width:100%;max-width:320px;margin-top:16px;">
                    <textarea id="blockedMsgInput" placeholder="Escribe tu mensaje al admin..." rows="3"
                        style="width:100%;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.1);border-radius:12px;color:#fff;font-family:'Space Grotesk',sans-serif;font-size:12px;padding:12px;resize:none;outline:none;box-sizing:border-box;"></textarea>
                    <button onclick="sendBlockedMsg('${name}')" style="margin-top:8px;background:#3b82f6;color:#fff;border:none;border-radius:12px;padding:10px 20px;font-family:'Space Grotesk',sans-serif;font-size:13px;font-weight:700;cursor:pointer;width:100%;">
                        ✉️ Enviar mensaje
                    </button>
                </div>
            `;
            document.body.appendChild(blockedDiv);
        }

        function showBlockedSupport() {
            const chat = document.getElementById('blockedChatArea');
            if (chat) chat.style.display = 'block';
        }

        async function sendBlockedMsg(userName) {
            const inp = document.getElementById('blockedMsgInput');
            const txt = inp?.value?.trim();
            if (!txt) return;
            const msg = { id: Date.now(), text: `[${userName}] ${txt}`, from: 'user', time: new Date().toLocaleString(), user: userName, blocked: true };
            supportMessages.push(msg);
            localStorage.setItem('c5x_support_msgs', JSON.stringify(supportMessages));
            inp.value = '';
            try { const _u=localStorage.getItem('c5x_my_pin'); const _a=_u?appUsers.find(u=>u.pin===_u):null; await sb.sendMessage('[BLOQUEADO] '+msg.text,'blocked_'+Date.now(),_a?.name||'Usuario'); } catch(e) {}
            inp.placeholder = '✅ Mensaje enviado al admin';
            setTimeout(() => { inp.placeholder = 'Escribe otro mensaje...'; }, 3000);
        }

        // ── CRUD Usuarios ───────────────────────────────────────────
        function addUser() {
            const name = document.getElementById('newUserName')?.value?.trim();
            const pin  = document.getElementById('newUserPin')?.value?.trim();
            const note = document.getElementById('newUserNote')?.value?.trim();
            if (!name || !pin || pin.length !== 4 || isNaN(pin)) {
                return showToast('⚠️ Nombre y PIN de 4 dígitos requeridos');
            }
            if (appUsers.find(u => u.pin === pin)) {
                return showToast('⚠️ PIN ya existe — usa uno diferente');
            }
            const username = document.getElementById('newUserUsername')?.value?.trim() || name.toLowerCase().replace(/\s+/g,'_');
            const user = { id: Date.now(), name, username, pin, password: pin, note: note || '', active: true, createdAt: _fmtDate(new Date()) };
            appUsers.push(user);
            saveUsers();
            renderUserList();
            document.getElementById('newUserName').value = '';
            document.getElementById('newUserUsername') && (document.getElementById('newUserUsername').value = '');
            document.getElementById('newUserPin').value  = '';
            document.getElementById('newUserNote').value = '';
            showToast(`✅ Usuario "${name}" agregado · PIN: ${pin}`);
        }

        function toggleUserActive(userId) {
            const u = appUsers.find(u => u.id === userId);
            if (!u) return;
            u.active = !u.active;
            saveUsers();
            renderUserList();
            showToast(`${u.active ? '✅ Activado' : '🔴 Desactivado'}: ${u.name}`);
        }

        function deleteUser(userId) {
            const u = appUsers.find(u => u.id === userId);
            if (!u) return;
            showConfirmModal('Eliminar usuario', `¿Eliminar a "${u.name}" permanentemente?`, () => {
                appUsers = appUsers.filter(u => u.id !== userId);
                saveUsers();
                renderUserList();
                showToast(`🗑️ Usuario "${u.name}" eliminado`);
            });
        }

        function saveUsers() {
            localStorage.setItem('c5x_users', JSON.stringify(appUsers));
            // Sync a Supabase si está disponible
            try { sb.set('kv_store','users_list',appUsers); } catch(e) {}
        }

        function renderUserList() {
            const el = document.getElementById('userListContainer');
            if (!el) return;
            if (!appUsers.length) {
                el.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">Sin usuarios registrados</div>';
                return;
            }
            el.innerHTML = appUsers.map(u => `
                <div style="display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--surface);border:1px solid ${u.active ? 'var(--border)' : 'rgba(239,68,68,.3)'};border-radius:14px;transition:border-color .2s;">
                    <!-- Avatar inicial -->
                    <div style="width:36px;height:36px;border-radius:50%;background:${u.active ? 'rgba(59,130,246,.15)' : 'rgba(239,68,68,.15)'};border:2px solid ${u.active ? 'var(--brand)' : 'var(--short)'};display:flex;align-items:center;justify-content:center;flex-shrink:0;font-family:var(--font-head);font-size:14px;font-weight:900;color:${u.active ? 'var(--brand)' : 'var(--short)'};">
                        ${u.name.charAt(0).toUpperCase()}
                    </div>
                    <!-- Info -->
                    <div style="flex:1;min-width:0;">
                        <div style="font-family:var(--font-head);font-size:11px;font-weight:800;color:var(--text-primary);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${u.name}</div>
                        <div style="font-family:var(--font-num);font-size:9px;color:var(--text-tertiary);">PIN: ${u.pin} · ${u.createdAt}</div>
                        ${u.note ? `<div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);margin-top:1px;">${u.note}</div>` : ''}
                    </div>
                    <!-- Estado -->
                    <div style="font-family:var(--font-head);font-size:8px;font-weight:800;color:${u.active ? 'var(--long)' : 'var(--short)'};flex-shrink:0;">
                        ${u.active ? '● ACTIVO' : '○ INACTIVO'}
                    </div>
                    <!-- Controles -->
                    <div style="display:flex;flex-direction:column;gap:4px;flex-shrink:0;">
                        <button onclick="toggleUserActive(${u.id})" style="padding:5px 8px;border-radius:8px;border:1px solid ${u.active ? 'var(--short)' : 'var(--long)'};background:transparent;color:${u.active ? 'var(--short)' : 'var(--long)'};font-family:var(--font-head);font-size:8px;font-weight:800;cursor:pointer;white-space:nowrap;">
                            ${u.active ? '🔴 DESACT.' : '✅ ACTIVAR'}
                        </button>
                        <button onclick="deleteUser(${u.id})" style="padding:5px 8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text-tertiary);font-family:var(--font-head);font-size:8px;cursor:pointer;">
                            🗑️
                        </button>
                    </div>
                </div>`).join('');
        }

        // ── Admin PIN toggle ─────────────────────────────────────────
        function toggleAdminMode() {
            const chk = document.getElementById('adminModeToggle');
            if (chk && !chk.checked) {
                setAdminMode(false);
                updateAdminModeUI();
            }
            // Para activar, requiere PIN
        }

        function verifyAdminPin() {
            const inp = document.getElementById('adminPinInput');
            const pin = inp?.value?.trim();
            // ── FIX: comparar hash del PIN ingresado vs hash almacenado ──
            if (_hashPin(pin) === ADMIN_PIN()) {
                setAdminMode(true);
                if (inp) inp.value = '';
                updateAdminModeUI();
                applyRoleVisibility();
                renderUserList();
            } else {
                showToast('⛔ PIN incorrecto');
                if (inp) { inp.style.borderColor = 'var(--short)'; setTimeout(() => inp.style.borderColor = '', 1500); }
            }
        }

        function updateAdminModeUI() {
            const toggle     = document.getElementById('adminModeToggle');
            const status     = document.getElementById('adminModeStatus');
            const pinCard    = document.getElementById('adminPinCard');
            const activeCard = document.getElementById('adminActiveCard');
            if (toggle) toggle.checked = isSuperAdmin;
            if (status) status.textContent = isSuperAdmin ? 'Todas las opciones avanzadas visibles' : '';
            if (pinCard)    pinCard.style.display    = isSuperAdmin ? 'none' : 'flex';
            if (activeCard) activeCard.style.display = isSuperAdmin ? 'flex' : 'none';
            const pinInp = document.getElementById('adminPinInput');
            if (pinInp) pinInp.value = '';
        }

        // ── Hook: cargar usuario list al abrir ajustes ───────────────
        const _origLoadSettings = loadSettingsValues;
        loadSettingsValues = function() {
            _origLoadSettings();
            renderUserList();
            updateAdminModeUI();
            applyRoleVisibility();
        };

        // ══ FAQ TOGGLE ══
        function toggleFAQ(el) {
            el.classList.toggle('open');
        }

        // ══ SUPPORT CHAT — Supabase ══
        let supportMessages = JSON.parse(localStorage.getItem('c5x_support_msgs') || '[]');

        // ── Estado del archivo adjunto pendiente en soporte ──────────────
        let _supportPendingFile = null;

        function handleSupportFileSelect(input) {
            const file = input.files[0];
            if (!file) return;
            const maxMB = 5;
            if (file.size > maxMB * 1024 * 1024) { showToast(`⚠️ Archivo muy grande (máx ${maxMB}MB)`); input.value = ''; return; }
            _supportPendingFile = file;
            // Mostrar preview
            const prev = document.getElementById('supportFilePreview');
            const icon = document.getElementById('supportFilePreviewIcon');
            const name = document.getElementById('supportFilePreviewName');
            const size = document.getElementById('supportFilePreviewSize');
            if (prev) { prev.style.display = 'flex'; }
            if (icon) icon.textContent = file.type.startsWith('image/') ? '🖼️' : '📄';
            if (name) name.textContent = file.name;
            if (size) size.textContent = (file.size / 1024 > 1024 ? (file.size/1024/1024).toFixed(1)+'MB' : (file.size/1024).toFixed(0)+'KB');
        }

        function clearSupportFile() {
            _supportPendingFile = null;
            const prev = document.getElementById('supportFilePreview');
            if (prev) prev.style.display = 'none';
            const fi = document.getElementById('supportFileInput');
            if (fi) fi.value = '';
        }

        async function sendSupportMsg() {
            const inp = document.getElementById('supportMsgInput');
            const txt = inp?.value?.trim();
            const myPin=localStorage.getItem('c5x_my_pin');
            const activeUser=myPin?appUsers.find(u=>u.pin===myPin):null;
            const userKey='user_'+Date.now();
            const userName=activeUser?.name||'Usuario';

            // ── ENVÍO DE ARCHIVO ADJUNTO ──────────────────────────────────
            if (_supportPendingFile) {
                const file = _supportPendingFile;
                clearSupportFile();
                showToast('📤 Subiendo archivo...', 3000);
                let fileUrl = null;
                // Intentar subir a Supabase Storage
                if (sb.active) {
                    fileUrl = await sb.uploadFile(file, myPin || 'anon');
                }
                // Si Supabase no disponible → convertir a base64 local (solo preview)
                if (!fileUrl) {
                    fileUrl = await new Promise(res => {
                        const r = new FileReader();
                        r.onload = e => res(e.target.result);
                        r.readAsDataURL(file);
                    });
                }
                const msg = {
                    id: Date.now(), type: 'file', from: 'user',
                    time: new Date().toLocaleString(),
                    text: '[Archivo adjunto]',
                    fileUrl, fileName: file.name, fileType: file.type, read: false
                };
                supportMessages.push(msg);
                localStorage.setItem('c5x_support_msgs', JSON.stringify(supportMessages));
                renderSupportChat();
                if (sb.active && fileUrl && !fileUrl.startsWith('data:')) {
                    const ok = await sb.sendFileMessage(fileUrl, file.name, file.type, userKey, userName);
                    showToast(ok ? '✅ Archivo enviado al admin' : '💾 Guardado local (sin Supabase)', 3000, false, ok);
                } else {
                    showToast('💾 Archivo guardado local (Supabase no activo)', 2500);
                }
                // Si también hay texto, enviarlo como mensaje separado
                if (txt) { inp.value = ''; await _sendTextMsg(txt, userKey, userName); }
                return;
            }

            // ── ENVÍO DE TEXTO PURO ───────────────────────────────────────
            if (!txt) return;
            inp.value = '';
            await _sendTextMsg(txt, userKey, userName);
        }

        async function _sendTextMsg(txt, userKey, userName) {
            const msg = {
                id: Date.now(), text: txt, type: 'text',
                from: 'user', time: new Date().toLocaleString(), read: false
            };
            supportMessages.push(msg);
            localStorage.setItem('c5x_support_msgs', JSON.stringify(supportMessages));
            renderSupportChat();
            try {
                const ok=await sb.sendMessage(txt, userKey, userName);
                showToast(ok?'💬 Mensaje enviado al admin':'💬 Guardado local (sin Supabase)',2000,false,ok);
            } catch(e) {
                showToast('💬 Guardado local (sin Supabase activo)', 2000);
            }
        }

        async function loadSupportMessages() {
            try {
                const remote=await sb.fetchMessages(50);
                if (remote&&remote.length) {
                    supportMessages=remote;
                    localStorage.setItem('c5x_support_msgs',JSON.stringify(supportMessages));
                }
            } catch(e) {}
            renderSupportChat();
        }

        function renderSupportChat() {
            const el = document.getElementById('supportMsgs');
            if (!el) return;
            if (!supportMessages.length) {
                el.innerHTML = '<div style="text-align:center;padding:30px 20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;line-height:2;">💬 Sin mensajes aún.<br>Escribe tu consulta abajo.</div>';
                return;
            }
            el.innerHTML = supportMessages.map(m => {
                const isAdmin = m.from === 'admin' || m.sender === 'admin';
                const align = isAdmin ? 'flex-start' : 'flex-end';
                const senderName = m.user_name || m.userName || '';
                const adminLabel = isAdmin 
                    ? '<div style="font-family:var(--font-head);font-size:8px;color:var(--brand);font-weight:800;margin-bottom:2px;">👑 ADMIN</div>' 
                    : (senderName ? `<div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);font-weight:700;margin-bottom:2px;text-align:right;">👤 ${senderName}</div>` : '');
                // ── Mensaje tipo ARCHIVO ──────────────────────────────────
                if (m.type === 'file' && m.fileUrl) {
                    const isImg = m.fileType && m.fileType.startsWith('image/');
                    const fileContent = isImg
                        ? `<img src="${m.fileUrl}" class="support-msg-img" onclick="window.open('${m.fileUrl}','_blank')" alt="${m.fileName||'imagen'}">`
                        : `<div class="support-msg-file"><span class="support-msg-file-icon">${m.fileType&&m.fileType.includes('pdf')?'📄':'📎'}</span><div class="support-msg-file-info"><div class="support-msg-file-name">${m.fileName||'Archivo'}</div><a class="support-msg-file-link" href="${m.fileUrl}" target="_blank" rel="noopener">Ver / Descargar →</a></div></div>`;
                    return `<div style="display:flex;flex-direction:column;align-items:${align};">${adminLabel}${fileContent}<div class="support-msg-time">${m.time}</div></div>`;
                }
                // ── Mensaje tipo TEXTO (default) ──────────────────────────
                const timeLabel = `<div class="support-msg-time">${senderName && !isAdmin ? senderName + ' · ' : ''}${m.time}</div>`;
                return `<div style="display:flex;flex-direction:column;align-items:${align};">${adminLabel}<div class="support-msg ${isAdmin?'admin':'mine'}">${m.text}</div>${timeLabel}</div>`;
            }).join('');
            // Scroll al final
            el.scrollTop = el.scrollHeight;
        }

        // ══ STRATEGY PARAMS DISPLAY ══
        function renderStrategyParams() {
            const el = document.getElementById('strategyCurrentParams');
            if (!el) return;
            const p   = strategyParams.normal;
            const bc  = botConfig;
            const tp1  = bc.tp1Pct         || 50;
            const tact = bc.trailActivePct || 100;
            const trd  = bc.trailDropPct   || 15;
            const rb   = bc.rebuyDropPct   || 16;
            const cd   = bc.crashDrop      || 8;
            const cf   = bc.crashFast      || 3;
            el.innerHTML = `
                💰 Capital base por nivel: <strong>$${p.capital}</strong><br>
                📉 Escalón N2 (inicial): <strong>−${p.desc}%</strong><br>
                📉 Incremento por nivel: <strong>+${p.inc}% / nivel</strong> (N3=−${p.desc+p.inc}%, N4=−${p.desc+p.inc*2}%...)<br>
                🎚️ Niveles máx auto: <strong>${bc.maxLevels || 12}</strong><br>
                <span style="color:var(--long)">🟢 TP1: avg +${tp1}% → vende 50% automáticamente</span><br>
                <span style="color:var(--brand)">📈 TRAILING: activa cuando precio ≥ precio_TP1 +${tact}% → stop −${trd}% desde máximo → vende 50% restante</span><br>
                <span style="color:var(--warning)">🔄 Rebuy post-TP1: −${rb}% desde precio TP1 → 12 nuevos niveles · acumula 50% al promedio · hasta <b>3 ciclos</b></span><br>
                🤝 Compras manuales en AUTO: <strong>permitidas en cualquier nivel para promediar</strong><br>
                ⚡ Crash activo: caída &gt;${cd}%/2min · Rápida: &gt;${cf}%/2min → compra acumulada multi-nivel<br>
                🧠 Contexto mercado: <strong>${bc.contextAware !== false ? 'ACTIVO' : 'DESACTIVADO'}</strong><br>
                ⏸️ Pausa rebalanceo Gate.io: <strong>${bc.rebalPause ? 'ACTIVO (±35min UTC 00:00)' : 'DESACTIVADO'}</strong>`;
        }


        const MASTER_SECS = 10;
        let masterClockId = null;

        function startMasterClock() {
            if (masterClockId) clearInterval(masterClockId);
            masterClockId = setInterval(masterTick, MASTER_SECS * 1000);
        }

        let _masterTickCount = 0;
        function masterTick() {
            _masterTickCount++;
            // 1. Ticker del header (si no está fijado)
            if (!isTickerPinned && !isHeaderPinnedByScroll) {
                // Garantizar monedas base si lista quedó vacía
                if (!tickerAssets || tickerAssets.length === 0) {
                    tickerAssets = ["BTC","ETH","SUI","AVAX","BNB"];
                    localStorage.setItem('c5x_ticker_assets', JSON.stringify(tickerAssets));
                    assetIdx = 0;
                }
                assetIdx = (assetIdx + 1) % tickerAssets.length;
                localStorage.setItem('c5x_ticker_index', assetIdx);
                updateTicker();
            }

            // 2. Radar — rotar UI cada tick, re-fetch datos cada 6 ticks (≈60s)
            tickRadar();
            if (_masterTickCount % 6 === 0) {
                fetchAndCalcTopDroppers().catch(() => {});
            }

            // 3. Mercado Live del dashboard
            gdTickerIdx = (gdTickerIdx + 1) % GD_ASSETS.length;
            updateGdMarketCard();

            // 4. Portafolio 5X
            tickGdDual();

            // 5. Resetear barra de progreso del mercado
            gdProgressMs = 0;
            const bar = document.getElementById('gdMcProgress');
            if (bar) bar.style.width = '0%';

            // 6. Actualizar tabs ETF activos y recovery
            try {
                refreshETFActiveTab();
                for (let i = 0; i < slots.length; i++) updateDashRecovery(i);
                updateRebalStatus();
            } catch(e) {}
        }
        // ════════════════════════════════════════════════════════
        document.addEventListener('DOMContentLoaded', function() {
            updateETFFloatButtonVisibility();
            updateHeaderForPanel(0);
            const container = document.getElementById('panelsContainer');
            if (container) {
                container.setAttribute('data-active', '0');
                // PC: sin transform inicial
                if (window.innerWidth < 1024) container.style.transform = 'translateX(0%)';
            }
            switchPanel(0);
            _updatePanelNavUI(0);

            // ── FIX OFFLINE: detectar pérdida/recuperación de conexión ──
            function _handleOffline() {
                showToast('⚠️ Sin conexión — el bot está pausado', 4000, false, false);
                // Marcar dot del radar como offline si existe
                const dot = document.querySelector('.radar-status-dot');
                if (dot) dot.className = 'radar-status-dot offline';
                console.warn('[5X] Red offline — llamadas a Gate.io suspendidas');
            }
            function _handleOnline() {
                showToast('✅ Conexión restaurada', 2500, false, true);
                const dot = document.querySelector('.radar-status-dot');
                if (dot) dot.className = 'radar-status-dot online';
                console.info('[5X] Red online — reanudando operaciones');
            }
            window.addEventListener('offline', _handleOffline);
            window.addEventListener('online',  _handleOnline);
            // Estado inicial
            if (!navigator.onLine) _handleOffline();
        });

        // ════════════════════════════════════════════════════════
        //  MEJORA 6 — BOT LIVE DASHBOARD
        // ════════════════════════════════════════════════════════
        let _botDashInterval = null;

        // Activar punto verde en nav cuando hay slots en auto
        function updateBotDashNavDot() {
            const dot = document.getElementById('botDashNavDot');
            if (!dot) return;
            const hasAuto = slots.some((s, i) => s && s.name && (slotModes[i] || 'manual') === 'auto');
            dot.style.display = hasAuto ? 'block' : 'none';
        }

        function pauseAllSlots() {
            slots.forEach((s, i) => { if (s && s.name) setSlotMode(i, 'manual'); });
            updateTradingModeUI && updateTradingModeUI();
            showToast('⏸ Todos los slots pausados');
            refreshBotDash();
        }

        function refreshBotDash() {
            updateBotDashNavDot();
            if (!document.getElementById('section-botdash')?.classList.contains('active')) return;
            renderBotDashSlots();
            renderBotDashLog();
        }

        function renderBotDashSlots() {
            const container = document.getElementById('botDashSlots');
            if (!container) return;

            let totalPnl = 0, totalCap = 0, activeCount = 0;
            let html = '';

            slots.forEach((s, i) => {
                if (!s || !s.name) return;
                const mode   = slotModes[i] || 'manual';
                const isAuto = mode === 'auto';
                const live   = allGateETFs && allGateETFs.find(t => t.currency_pair === s.name + '_USDT');
                const price  = live ? parseFloat(live.last) : (s.price || 0);
                const avg    = calculateAvgPriceForSlotData(s, i);
                const roiNow = avg > 0 ? ((price - avg) / avg * 100) : 0;
                const dynTarget = getDynamicTargetRoi(s.name, i);

                // Capital invertido en este slot
                let capInvested = 0;
                const limit = customMultipliers.length || 12;
                for (let l = 0; l < limit; l++) {
                    const key = getOrderKey(i, l);
                    if (activeOrders[key] && activeOrders[key].status === 'filled') {
                        capInvested += activeOrders[key].price * activeOrders[key].amount;
                    } else if (s.buys && s.buys.includes(l) && !activeOrders[key]) {
                        capInvested += (customMultipliers[l] || 1) * strategyParams.normal.capital;
                    }
                }

                const pnlUsd = avg > 0 && capInvested > 0 ? (roiNow / 100) * capInvested : 0;
                if (isAuto) { totalPnl += pnlUsd; totalCap += capInvested; activeCount++; }

                const roiColor  = roiNow >= 0 ? 'var(--long)' : 'var(--short)';
                const progPct   = dynTarget > 0 ? Math.min(Math.max((roiNow / dynTarget) * 100, 0), 100) : 0;
                const modeColor = isAuto ? 'var(--long)' : 'var(--border)';
                const levelsHit = s.buys ? s.buys.length : 0;
                const tp1Done   = trailingStopData[i]?.exits?.tp1;
                const tp2Done   = trailingStopData[i]?.exits?.tp2;

                html += `<div style="background:var(--surface);border:1px solid ${isAuto ? 'rgba(59,130,246,.3)' : 'var(--border)'};border-radius:14px;padding:12px 14px;">
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
                        <div style="width:34px;height:34px;border-radius:50%;background:rgba(59,130,246,.1);border:2px solid ${modeColor};display:flex;align-items:center;justify-content:center;font-family:var(--font-head);font-size:9px;font-weight:900;color:var(--brand);flex-shrink:0;">${(s.name||'').substring(0,3)}</div>
                        <div style="flex:1;">
                            <div style="font-family:var(--font-head);font-size:11px;font-weight:900;color:var(--text-primary);">${s.name}</div>
                            <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);">N${levelsHit} comprados · $${capInvested.toFixed(2)} invertidos</div>
                        </div>
                        <div style="text-align:right;">
                            <div style="font-family:var(--font-num);font-size:15px;font-weight:800;color:${roiColor};">${pnlUsd >= 0 ? '+' : ''}$${pnlUsd.toFixed(2)}</div>
                            <div style="font-family:var(--font-num);font-size:10px;color:${roiColor};">${roiNow >= 0 ? '+' : ''}${roiNow.toFixed(1)}%</div>
                        </div>
                    </div>
                    <!-- Barra de progreso hacia objetivo dinámico -->
                    <div style="margin-bottom:4px;">
                        <div style="display:flex;justify-content:space-between;font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);margin-bottom:3px;">
                            <span>0%</span>
                            <span style="color:var(--brand);">🎯 OBJ DIN: ${dynTarget.toFixed(0)}%</span>
                            <span>${dynTarget.toFixed(0)}%</span>
                        </div>
                        <div style="height:5px;background:var(--bg);border-radius:3px;overflow:hidden;">
                            <div style="height:100%;width:${progPct}%;background:${roiNow >= dynTarget * 0.9 ? 'var(--long)' : roiNow >= dynTarget * 0.7 ? 'var(--warning)' : 'var(--brand)'};border-radius:3px;transition:width .5s;"></div>
                        </div>
                    </div>
                    <!-- TP badges -->
                    <div style="display:flex;gap:5px;margin-top:5px;">
                        <span style="font-family:var(--font-head);font-size:7px;padding:2px 7px;border-radius:6px;background:${tp1Done ? 'rgba(16,185,129,.2)' : 'var(--bg)'};color:${tp1Done ? 'var(--long)' : 'var(--text-tertiary)'};border:1px solid ${tp1Done ? 'var(--long)' : 'var(--border)'};">TP1 ${tp1Done ? '✓' : `@avg+${botConfig.tp1Pct||50}%`}</span>
                        <span style="font-family:var(--font-head);font-size:7px;padding:2px 7px;border-radius:6px;background:${tp2Done ? 'rgba(16,185,129,.2)' : 'var(--bg)'};color:${tp2Done ? 'var(--long)' : 'var(--text-tertiary)'};border:1px solid ${tp2Done ? 'var(--long)' : 'var(--border)'};">TP2 ${tp2Done ? '✓' : `TP1+${botConfig.trailActivePct||100}%`}</span>
                        <span style="font-family:var(--font-head);font-size:7px;padding:2px 7px;border-radius:6px;background:${isAuto ? 'rgba(59,130,246,.1)' : 'var(--bg)'};color:${isAuto ? 'var(--brand)' : 'var(--text-tertiary)'};border:1px solid ${isAuto ? 'var(--brand)' : 'var(--border)'};">${isAuto ? '🤖 AUTO' : '✋ MANUAL'}</span>
                        ${live ? `<span style="font-family:var(--font-num);font-size:7px;padding:2px 7px;border-radius:6px;background:var(--bg);color:var(--text-tertiary);border:1px solid var(--border);">$${parseFloat(live.last).toFixed(parseFloat(live.last)<1?6:4)}</span>` : ''}
                    </div>
                </div>`;
            });

            if (!html) html = '<div style="text-align:center;padding:20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">Sin slots configurados</div>';
            container.innerHTML = html;

            // Stats globales
            const elSlots = document.getElementById('bdStatSlots');
            const elPnl   = document.getElementById('bdStatPnl');
            const elCap   = document.getElementById('bdStatCap');
            if (elSlots) elSlots.textContent = `${activeCount}/${slots.filter(s=>s&&s.name).length}`;
            if (elPnl)   { elPnl.textContent = (totalPnl >= 0 ? '+' : '') + '$' + totalPnl.toFixed(2); elPnl.style.color = totalPnl >= 0 ? 'var(--long)' : 'var(--short)'; }
            if (elCap)   elCap.textContent = '$' + totalCap.toFixed(0);
        }

        function renderBotDashLog() {
            const el = document.getElementById('botDashLog');
            if (!el) return;
            const logs = JSON.parse(localStorage.getItem('c5x_bot_log') || '[]');
            if (!logs.length) { el.innerHTML = '<span style="color:var(--text-tertiary)">Sin actividad reciente</span>'; return; }
            const colors = { buy: '#3b82f6', sell: '#10b981', tp: '#f59e0b', trail: '#8b5cf6', info: '#6b7280', circuit: '#ef4444', pause: '#f59e0b', warn: '#ef4444' };
            el.innerHTML = [...logs].reverse().slice(0, 60).map(l => {
                const c = colors[l.type] || '#6b7280';
                return `<div style="color:${c};border-left:2px solid ${c};padding-left:6px;margin-bottom:4px;">[${l.time}] ${l.msg}</div>`;
            }).join('');
        }

        function clearBotLog() {
            localStorage.removeItem('c5x_bot_log');
            renderBotDashLog();
        }

        // Auto-refresh del dashboard cuando está visible
        const _origSwitchView = typeof switchView === 'function' ? switchView : null;
        if (_origSwitchView) {
            switchView = function(view, ...rest) {
                _origSwitchView(view, ...rest);
                if (view === 'botdash') {
                    refreshBotDash();
                    if (_botDashInterval) clearInterval(_botDashInterval);
                    _botDashInterval = setInterval(refreshBotDash, 4000);
                } else {
                    if (_botDashInterval) { clearInterval(_botDashInterval); _botDashInterval = null; }
                }
            };
        }

        // ════════════════════════════════════════════════════════
        //  MEJORA 8 — BACKTESTER
        // ════════════════════════════════════════════════════════
        async function runBacktest() {
            const coin    = document.getElementById('btCoin')?.value || 'BTC5L';
            const minutes = parseInt(document.getElementById('btPeriod')?.value || '1440');
            const el      = document.getElementById('btResult');
            if (!el) return;

            el.innerHTML = '<span style="color:var(--brand);">⏳ Descargando datos históricos de Gate.io…</span>';

            try {
                // Obtener velas de Gate.io: intervalo 5min
                const interval  = '5m';
                const limit     = Math.min(Math.floor(minutes / 5), 288);
                const candles   = await callGatePublic('/spot/candlesticks', {
                    currency_pair: coin + '_USDT',
                    interval,
                    limit: String(limit)
                });

                if (!Array.isArray(candles) || candles.length < 10) {
                    el.innerHTML = '<span style="color:var(--danger);">❌ No hay datos para este par. Verifica que el ETF existe en Gate.io.</span>';
                    return;
                }

                // Gate.io formato: [timestamp, volume, close, high, low, open, ...]
                const prices = candles.map(c => parseFloat(c[2])); // close prices
                const entryPrice = prices[0];
                const baseCapital = strategyParams.normal.capital || 5;

                // Simular estrategia
                let buys = [], totalSpent = 0, totalQty = 0, trades = 0;
                const targetRoiSim = getDynamicTargetRoi(coin, activeIdx);
                let maxDrawdown = 0, peakPrice = entryPrice;

                // Simular niveles con precios reales del historial
                let currentP = entryPrice;
                for (let l = 0; l < 12; l++) {
                    const step     = getStepForLevel('normal', l) || 7;
                    const lvlPrice = l === 0 ? entryPrice : currentP * (1 - step / 100);
                    currentP = lvlPrice;
                    const mult = customMultipliers[l] || 1;
                    const usd  = baseCapital * mult;
                    buys.push({ level: l + 1, price: lvlPrice, usd, qty: usd / lvlPrice, hit: false, hitTime: null });
                }

                // Replay sobre el historial de precios
                let maxPriceSeen = entryPrice;
                prices.forEach((p, idx) => {
                    const minutesSinceStart = idx * 5;
                    buys.forEach(b => {
                        if (!b.hit && p <= b.price) {
                            b.hit = true; b.hitTime = minutesSinceStart;
                            totalSpent += b.usd; totalQty += b.qty; trades++;
                        }
                    });
                    if (p > maxPriceSeen) maxPriceSeen = p;
                    const drawdown = totalQty > 0 ? ((p - (totalSpent / totalQty)) / (totalSpent / totalQty)) * 100 : 0;
                    if (drawdown < maxDrawdown) maxDrawdown = drawdown;
                });

                const lastPrice  = prices[prices.length - 1];
                const avgPrice   = totalQty > 0 ? totalSpent / totalQty : entryPrice;
                const finalRoi   = totalQty > 0 ? ((lastPrice - avgPrice) / avgPrice * 100) : 0;
                const finalPnl   = totalQty > 0 ? (lastPrice - avgPrice) * totalQty : 0;
                const targetPrice = avgPrice * (1 + targetRoiSim / 100);
                const wouldClose  = maxPriceSeen >= targetPrice;
                const tp1Hit      = maxPriceSeen >= avgPrice * (1 + targetRoiSim * 0.7 / 100);
                const tp2Hit      = maxPriceSeen >= avgPrice * (1 + targetRoiSim * 0.9 / 100);
                const priceChange = ((lastPrice - entryPrice) / entryPrice * 100).toFixed(1);

                const color = finalPnl >= 0 ? 'var(--long)' : 'var(--short)';
                const period = minutes >= 10080 ? '7 días' : minutes >= 4320 ? '3 días' : '24h';

                el.innerHTML = `
                    <div style="text-align:left;">
                        <div style="font-family:var(--font-head);font-size:10px;font-weight:800;color:var(--text-primary);margin-bottom:8px;letter-spacing:.5px;">
                            📊 ${coin} — Últimas ${period} (${limit} velas de 5min)
                        </div>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:5px;margin-bottom:8px;">
                            <div style="background:var(--bg);border-radius:8px;padding:7px;"><div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);">NIVELES COMPRADOS</div><div style="font-family:var(--font-num);font-size:16px;font-weight:800;color:var(--brand);">${trades}/12</div></div>
                            <div style="background:var(--bg);border-radius:8px;padding:7px;"><div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);">CAPITAL DESPLEGADO</div><div style="font-family:var(--font-num);font-size:16px;font-weight:800;color:var(--text-primary);">$${totalSpent.toFixed(1)}</div></div>
                            <div style="background:var(--bg);border-radius:8px;padding:7px;"><div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);">ROI FINAL</div><div style="font-family:var(--font-num);font-size:16px;font-weight:800;color:${color};">${finalRoi >= 0 ? '+' : ''}${finalRoi.toFixed(1)}%</div></div>
                            <div style="background:var(--bg);border-radius:8px;padding:7px;"><div style="font-family:var(--font-head);font-size:7px;color:var(--text-tertiary);">PnL SIMULADO</div><div style="font-family:var(--font-num);font-size:16px;font-weight:800;color:${color};">${finalPnl >= 0 ? '+' : ''}$${finalPnl.toFixed(2)}</div></div>
                        </div>
                        <div style="background:var(--bg);border-radius:10px;padding:8px;margin-bottom:6px;font-family:var(--font-head);font-size:9px;line-height:2;">
                            🎯 <b>ROI objetivo dinámico:</b> ${targetRoiSim.toFixed(0)}% (TP1 ${botConfig.tp1Pct||50}% + trailing ${botConfig.trailActivePct||100}%)<br>
                            📈 <b>Variación real del ETF:</b> ${priceChange}%<br>
                            📉 <b>Drawdown máximo:</b> ${maxDrawdown.toFixed(1)}%<br>
                            TP1 (70%): <span style="color:${tp1Hit ? 'var(--long)' : 'var(--danger)'};">${tp1Hit ? '✅ alcanzado' : '❌ no alcanzado'}</span><br>
                            TP2 (90%): <span style="color:${tp2Hit ? 'var(--long)' : 'var(--danger)'};">${tp2Hit ? '✅ alcanzado' : '❌ no alcanzado'}</span><br>
                            🏁 <b>Cierre completo:</b> <span style="color:${wouldClose ? 'var(--long)' : 'var(--danger)'};">${wouldClose ? '✅ hubiese cerrado' : '❌ posición seguiría abierta'}</span>
                        </div>
                        <div style="font-family:var(--font-head);font-size:8px;color:var(--text-tertiary);">
                            ⚠️ Simulación sobre precios históricos reales de Gate.io. No incluye fees ni slippage.
                        </div>
                    </div>`;
            } catch(e) {
                el.innerHTML = `<span style="color:var(--danger);">❌ Error: ${e.message}. Verifica conexión a Gate.io.</span>`;
            }
        }

        // Actualizar dot del nav en cada ciclo del bot
        // Hook post-ciclo para actualizar nav dot
        setInterval(updateBotDashNavDot, 5000);

        let currentRadarSort = 'drop';

        function setRadarSort(sort, btn) {
            currentRadarSort = sort;
            // Estilos de botones
            document.querySelectorAll('.radar-filter-btn').forEach(b => {
                b.style.borderColor   = 'var(--border)';
                b.style.background    = 'transparent';
                b.style.color         = 'var(--text-tertiary)';
            });
            if (btn) {
                btn.style.borderColor = sort === 'gold' ? 'rgba(245,158,11,.6)' : 'var(--brand)';
                btn.style.background  = sort === 'gold' ? 'rgba(245,158,11,.15)' : 'rgba(59,130,246,.15)';
                btn.style.color       = sort === 'gold' ? 'var(--warning)' : 'var(--brand)';
            }
            applyRadarSort();
        }

        function applyRadarSort() {
            if (!allGateETFs || !allGateETFs.length) return;
            let list = [...allGateETFs];

            switch(currentRadarSort) {
                case 'score':
                    list.sort((a, b) => (b.score || 0) - (a.score || 0));
                    break;
                case 'drop':
                    list.sort((a, b) => parseFloat(a.change_percentage) - parseFloat(b.change_percentage));
                    break;
                case 'volume':
                    list.sort((a, b) => parseFloat(b.quote_volume) - parseFloat(a.quote_volume));
                    break;
                case 'gain':
                    list.sort((a, b) => parseFloat(b.change_percentage) - parseFloat(a.change_percentage));
                    break;
                case 'lev5':
                    list = list.filter(t => t.currency_pair.includes('5L') || t.currency_pair.includes('5S'));
                    list.sort((a, b) => (b.score || 0) - (a.score || 0));
                    break;
                case 'lev3':
                    list = list.filter(t => t.currency_pair.includes('3L') || t.currency_pair.includes('3S'));
                    list.sort((a, b) => (b.score || 0) - (a.score || 0));
                    break;
                case 'gold':
                    list = list.filter(t => t.zone === 'GOLD' || t.zone === 'HOT');
                    list.sort((a, b) => (b.score || 0) - (a.score || 0));
                    break;
            }

            const top = list.slice(0, monitorLimit);
            const grid = document.getElementById('etfGrid');
            if (!grid) return;
            if (!top.length) {
                grid.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-tertiary);font-size:10px;">Sin resultados para este filtro</div>';
                return;
            }
            grid.innerHTML = top.map((t, i) => renderETFCardHTML(t, i)).join('');
        }

        // Enganchar applyRadarSort al final de filterETFs
        const _origFilterETFs = filterETFs;
        filterETFs = function(query) {
            if (query && query.trim()) {
                _origFilterETFs(query);
            } else {
                applyRadarSort();
                if (typeof updateETFMarketBar === 'function') updateETFMarketBar();
            }
        };

        // ════════════════════════════════════════════════════════
        //  REFINAMIENTO 2 — HISTORIAL: STATS + COIN MÁS OPERADO
        // ════════════════════════════════════════════════════════
        const _origRenderHistory = renderHistory;
        renderHistory = function() {
            _origRenderHistory.apply(this, arguments);
            renderHistoryStats();
        };

        function renderHistoryStats() {
            if (!history || !history.length) return;
            const profits = history.map(h => h.netProfit !== undefined ? parseFloat(h.netProfit) : (parseFloat(h.profit) || 0));
            const total   = profits.length;
            const wins    = profits.filter(p => p > 0).length;
            const net     = profits.reduce((s, p) => s + p, 0);
            const best    = Math.max(...profits);

            // Cards superiores
            const elOps = document.getElementById('statTotalOps');
            const elWr  = document.getElementById('statWinRate');
            const elBest = document.getElementById('statBestOp');
            const elNet  = document.getElementById('statNetTotal');
            if (elOps)  elOps.textContent  = total;
            if (elWr)   { elWr.textContent = Math.round((wins / total) * 100) + '%'; elWr.style.color = wins/total >= 0.5 ? 'var(--long)' : 'var(--short)'; }
            if (elBest) { elBest.textContent = '+$' + best.toFixed(2); }
            if (elNet)  { elNet.textContent = (net >= 0 ? '+' : '') + '$' + net.toFixed(2); elNet.style.color = net >= 0 ? 'var(--long)' : 'var(--short)'; }

            // Coin más operado
            const coinStats = {};
            history.forEach(h => {
                if (!coinStats[h.coin]) coinStats[h.coin] = { ops: 0, pnl: 0 };
                coinStats[h.coin].ops++;
                coinStats[h.coin].pnl += h.netProfit !== undefined ? parseFloat(h.netProfit) : (parseFloat(h.profit) || 0);
            });
            const topCoin = Object.entries(coinStats).sort((a, b) => b[1].ops - a[1].ops)[0];
            const tcBar   = document.getElementById('topCoinBar');
            const tcName  = document.getElementById('topCoinName');
            const tcPnl   = document.getElementById('topCoinPnl');
            if (topCoin && tcBar && tcName && tcPnl) {
                tcBar.style.display = 'flex';
                tcName.textContent  = topCoin[0];
                tcPnl.textContent   = (topCoin[1].pnl >= 0 ? '+' : '') + '$' + topCoin[1].pnl.toFixed(2);
                tcPnl.style.color   = topCoin[1].pnl >= 0 ? 'var(--long)' : 'var(--short)';
            }
        }

        // ════════════════════════════════════════════════════════
        //  REFINAMIENTO 3 — NOTIFICACIONES MÁS DETALLADAS
        // ════════════════════════════════════════════════════════
        // Wrapper que enriquece sendNativeNotif con precio de entrada y ROI
        const _origSendNotif = sendNativeNotif;
        sendNativeNotif = function(title, body, opts = {}) {
            // Enriquecer con precio actual del slot activo si está disponible
            const slot = slots && slots[activeIdx];
            if (slot && slot.name && (title.includes(slot.name) || body.includes(slot.name))) {
                const live = allGateETFs && allGateETFs.find(t => t.currency_pair === slot.name + '_USDT');
                if (live && slot.price) {
                    const entryPrice  = slot.price;
                    const currentPrice = parseFloat(live.last);
                    const roiLive     = ((currentPrice - entryPrice) / entryPrice * 100).toFixed(2);
                    const invested    = slot.levels
                        ? slot.levels.filter(l => l.executed).reduce((s, l) => s + (parseFloat(l.amount) || 0), 0)
                        : 0;
                    // Solo añadir si el body no ya tiene precio
                    if (!body.includes('Entrada:')) {
                        body = body + ` | Entrada: $${entryPrice < 1 ? entryPrice.toFixed(6) : entryPrice.toFixed(4)} | Actual: $${currentPrice < 1 ? currentPrice.toFixed(6) : currentPrice.toFixed(4)} | ROI vivo: ${roiLive >= 0 ? '+' : ''}${roiLive}%` + (invested > 0 ? ` | Inv: $${invested.toFixed(2)}` : '');
                    }
                }
            }
            return _origSendNotif(title, body, opts);
        };

        // ════════════════════════════════════════════════════════
        //  REFINAMIENTO 4 — PANEL ADMIN: TRADES GLOBALES
        // ════════════════════════════════════════════════════════
        async function renderAdminTrades() {
            const container = document.getElementById('adminTradesContainer');
            if (!container) return;
            container.innerHTML = '<div style="text-align:center;padding:14px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">⏳ Cargando...</div>';

            // Historial propio del admin
            let allTrades = (history || []).map(h => ({ ...h, _user: 'ADMIN' }));

            // Si Supabase activo, intentar cargar trades de usuarios
            if (sb && sb.active && _supabaseClient) {
                try {
                    const { data } = await _supabaseClient
                        .from('kv_store')
                        .select('key, value')
                        .like('key', 'history_%')
                        .limit(50);
                    if (Array.isArray(data)) {
                        data.forEach(row => {
                            try {
                                const userName = row.key.replace('history_', '');
                                const userHistory = JSON.parse(row.value);
                                if (Array.isArray(userHistory)) {
                                    userHistory.forEach(h => allTrades.push({ ...h, _user: userName }));
                                }
                            } catch(_) {}
                        });
                    }
                } catch(e) {}
            }

            if (!allTrades.length) {
                container.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-tertiary);font-family:var(--font-head);font-size:9px;">Sin operaciones registradas</div>';
                return;
            }

            // Ordenar por fecha descendente
            allTrades.sort((a, b) => (b.id || 0) - (a.id || 0));

            // Calcular stats globales
            const allProfits = allTrades.map(h => h.netProfit !== undefined ? parseFloat(h.netProfit) : (parseFloat(h.profit) || 0));
            const globalNet  = allProfits.reduce((s, p) => s + p, 0);
            const globalWins = allProfits.filter(p => p > 0).length;
            const globalWr   = allTrades.length ? Math.round((globalWins / allTrades.length) * 100) : 0;

            const elOps = document.getElementById('adminStatOps');
            const elNet = document.getElementById('adminStatNet');
            const elWr  = document.getElementById('adminStatWr');
            if (elOps) elOps.textContent  = allTrades.length;
            if (elNet) { elNet.textContent = (globalNet >= 0 ? '+' : '') + '$' + globalNet.toFixed(2); elNet.style.color = globalNet >= 0 ? 'var(--long)' : 'var(--short)'; }
            if (elWr)  { elWr.textContent  = globalWr + '%'; elWr.style.color = globalWr >= 50 ? 'var(--long)' : 'var(--short)'; }

            // Renderizar cards de trades
            container.innerHTML = allTrades.slice(0, 30).map(h => {
                const pnl    = h.netProfit !== undefined ? parseFloat(h.netProfit) : (parseFloat(h.profit) || 0);
                const isWin  = pnl >= 0;
                const color  = getCoinColor ? getCoinColor(h.coin) : 'var(--brand)';
                return `<div style="display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--surface);border:1px solid var(--border);border-radius:12px;">
                    <div style="width:32px;height:32px;border-radius:50%;background:rgba(59,130,246,.12);border:1.5px solid var(--brand);display:flex;align-items:center;justify-content:center;font-family:var(--font-head);font-size:9px;font-weight:900;color:${color};flex-shrink:0;">${(h.coin||'?').substring(0,3)}</div>
                    <div style="flex:1;min-width:0;">
                        <div style="font-family:var(--font-head);font-size:11px;font-weight:800;color:${color};">${h.coin||'?'}</div>
                        <div style="font-family:var(--font-num);font-size:9px;color:var(--text-tertiary);">${h.date||''} ${h.time||''}</div>
                        <div style="font-family:var(--font-head);font-size:8px;color:var(--brand);letter-spacing:.3px;">👤 ${h._user}</div>
                    </div>
                    <div style="text-align:right;flex-shrink:0;">
                        <div style="font-family:var(--font-num);font-size:13px;font-weight:800;color:${isWin ? 'var(--long)' : 'var(--short)'};">${isWin?'+':''}$${pnl.toFixed(2)}</div>
                        <div style="font-family:var(--font-head);font-size:9px;color:var(--text-tertiary);">${h.roi||''}</div>
                    </div>
                </div>`;
            }).join('');
        }
    </script>
    <!-- ═══ BOTÓN FLOTANTE ETF ═══ -->
    <!-- Posicionado al final del body para evitar problemas de z-index y overflow -->
    <div class="etf-float-btn anim-click" id="etfFloatBtn" onclick="goToETFMonitor()" title="Monitor ETF" style="display:none;">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="12" cy="12" r="9.5" stroke="rgba(52,211,153,0.30)" stroke-width="1.2"/>
            <circle cx="12" cy="12" r="6" stroke="rgba(52,211,153,0.55)" stroke-width="1.4"/>
            <circle cx="12" cy="12" r="2.5" fill="#34d399"/>
            <line x1="12" y1="2" x2="12" y2="5.5" stroke="rgba(245,245,245,0.5)" stroke-width="1.5" stroke-linecap="round"/>
            <line x1="12" y1="18.5" x2="12" y2="22" stroke="rgba(245,245,245,0.5)" stroke-width="1.5" stroke-linecap="round"/>
            <line x1="2" y1="12" x2="5.5" y2="12" stroke="rgba(245,245,245,0.5)" stroke-width="1.5" stroke-linecap="round"/>
            <line x1="18.5" y1="12" x2="22" y2="12" stroke="rgba(245,245,245,0.5)" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
    </div>
</body>
</html>